?execute object/reader
?common=3
?file newtape = symbol/pascal2 serial
?data card
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 10003000
%                                                                     % 10004000
%                                                                     % 10005000
%               *                                 *                   % 10006000
%               *  p a s c a l   c o m p i l e r  *                   % 10007000
%               ***********************************                   % 10008000
%                                                                     % 10009000
%                                                                     % 10010000
%                 written 1975 by                                     % 10011000
%                    dag f. langmyhr,                                 % 10012000
%                       heriot-watt university,                       % 10013000
%                          edinburgh.                                 % 10014000
%                                                                     % 10015000
%                                                                     % 10016000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 10017000
%                                                                     % 10018000
%                                                                     % 10019000
%                 part 1:  declarations.                              % 10020000
%                          -------------                              % 10021000
%                                                                     % 10022000
%                                                                     % 10023000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 10024000
                                                                        10025000
                                                                        10026000
begin                                                                   10027000
define edition="2.3"#;                                                  10028000
integer numerrs,       % @r+21: number of erros in program.             10029000
        savefactor,    % @r+22: savefactor for code file.               10030000
                       %          >0  compile to library.               10031000
                       %          =0  compile and run.                  10032000
                       %          <0  compile for syntax.               10033000
        cardcnt;       % @r+23: number of cards read.                   10034000
file card "source" (2,10,150);              % source code input file    10035000
file lines 1 (2,17);                      % print file.                 10036000
file pascalgol disk serial [20:610] (2,10,150,save 0);  % code file     10037000
define linesperpage=58#,                                                10038000
       maxint=549755813887#;                                            10039000
                                                                        10040000
%*** compiler constants ***                                             10041000
define maxtables  =50#,      %max number of name tables.                10042000
       maxnames   =997#,     %max names in each table.                  10043000
       maxlevel   =15#,      %max depth of procedure declarations.      10044000
       maxcases   =211#,     %max labels in a case-statement.           10045000
       maxlabs    =110#,     %max number of labels.                     10046000
       maxparams  =210#,     %max number of parameters in whole program.10047000
       maxtypes   =1022#,    %max number of different types.            10048000
       maxconsts  =210#,     %size of constant table.                   10049000
       maxtemps   =5#,       %number of extra vars in each procedure.   10050000
       maxwithsyms=250#,     %max number of symbols used by with-statms.10051000
       maxsyms    =810#,     %max number of symbols in one expression.  10052000
       listlength =810#,     %max length of var and param lists.        10053000
       maxextfiles=20#,      %max number of external files.             10054000
       maxfiles   =20#,      %max number of files declared at one time. 10055000
       maxpntrs   =50#;      %max number of undeclared pointers.        10056000
                                                                        10057000
%*** name tables ***                                                    10058000
array nametab1,nametab2,nametab3[0:maxtables,0:maxnames];               10059000
define namelength  =[41:6]#,                                            10060000
       type        =[9:10]#,                                            10061000
       idclass     =[12:3]#,                                            10062000
             var  =0#,                                                  10063000
             const=1#,                                                  10064000
             func =2#,                                                  10065000
             proc =3#,                                                  10066000
             types=4#,                                                  10067000
       info        =[23:11]#,                                           10068000
       formal      =[24:1]#,                                            10069000
       forwarddef  =[25:1]#,                                            10070000
       externalfile=[26:1]#;                                            10071000
                                                                        10072000
%*** display vector ***                                                 10073000
array display[0:maxlevel];                                              10074000
define rectype       =[9:10]#,                                          10075000
       firstwithsym  =[19:10]#,                                         10076000
       lastwithsym   =[29:10]#,                                         10077000
       numpntrsinwith=[35:6]#,                                          10078000
       bracketsinwith=[36:1]#,                                          10079000
       nametab       =[46:7]#;                                          10080000
                                                                        10081000
%*** type tables ***                                                    10082000
array typetab1,typetab2,typetab3[0:maxtypes];                           10083000
define form  =[3:4]#,                                                   10084000
           numeric =0#,                                                 10085000
           symbolic=1#,                                                 10086000
           subtype =2#,                                                 10087000
               maintype=[33:10]#,                                       10088000
           char    =3#,                                                 10089000
           floating=4#,                                                 10090000
           alfa    =5#,                                                 10091000
           set     =6#,                                                 10092000
               settype =[33:10]#,                                       10093000
           pointers=7#,                                                 10094000
               pointtype=[33:10]#,                                      10095000
           arrays  =8#,                                                 10096000
               inxtype =[33:10]#,                                       10097000
               arrtype =[43:10]#,                                       10098000
           record  =9#,                                                 10099000
               rectab  =[33:10]#,                                       10100000
           files   =10#,                                                10101000
               filetype=[33:10]#,                                       10102000
           textfile=11#,                                                10103000
       size  =[15:12]#,                                                 10104000
       struct=[23:8]#;                                                  10105000
integer numtypes;                                                       10106000
                                                                        10107000
%*** parameter table ***                                                10108000
array paramtab[0:maxparams];                                            10109000
define paramname =[9:10]#,                                              10110000
       paramkind =[13:4]#,                                              10111000
       paramlevel=[23:10]#,                                             10112000
       paramtype =[33:10]#,                                             10113000
       paramfile =[34:1]#;                                              10114000
integer numparams;                                                      10115000
                                                                        10116000
%*** constant table ***                                                 10117000
array consttab[0:maxconsts];                                            10118000
integer numconsts;                                                      10119000
                                                                        10120000
%*** label table ***                                                    10121000
array labtab[0:maxlabs];                                                10122000
define labval=[14:15]#,                                                 10123000
       labdef=[15:1]#;                                                  10124000
integer numlabs,firstlab;                                               10125000
                                                                        10126000
%*** tables for i/o and character handling ***                          10127000
array ch[0:0], text[0:1], string[0:11];                                 10128000
  pointer charpnt,textpnt,textpnt0,stringpnt;                           10129000
array icard[0:9], line[0:16], xline[0:10], algolcard[0:9];              10130000
  pointer cardpnt,linepnt,xlinepnt,algolpnt;                            10131000
  integer charcnt,algolcnt,margincnt;                                   10132000
array headtext[0:10], errline[0:16];                                    10133000
  integer linecnt,pagecnt,errinx;                                       10134000
                                                                        10135000
%*** xref file and table ***                                            10136000
file xreffile disk serial [20:3100] (2,3,15);                           10137000
array blocktab[0:maxtables], xrefline[0:16];                            10138000
  integer numxref,numblocks;  pointer xrefpnt;                          10139000
                                                                        10140000
%*** other tables ***                                                   10141000
integer array varlist[0:listlength];    % temporary list of variables.  10142000
  integer varindex,firstvar;                                            10143000
array symtab[0:maxsyms];                     % used by "expression".    10144000
  integer numsyms;                                                      10145000
array withtab[0:maxwithsyms];                % used by "withstat".      10146000
  integer nwithsyms;                                                    10147000
integer array symbol[0:64];                  % used by "insymbol".      10148000
integer array symkind[0:61];                 % used in error recovery.  10149000
array pntrtab1,pntrtab2,pntrtab3[0:maxpntrs];% used for forward pointers10150000
  integer numpntrs;                                                     10151000
array extfiletab[0:maxextfiles];             % external files.          10152000
  integer numextfiles;                                                  10153000
array filetab[0:maxfiles];                   % files in use.            10154000
  integer numfiles;                                                     10155000
boolean array err[0:119];                    % records error messages.  10156000
                                                                        10157000
%*** compile time options ***                                           10158000
boolean listoption,reswordoption,checkoption,dumpoption,xrefoption;     10159000
integer cardlength;                                                     10160000
                                                                        10161000
%*** intrinsic types ***                                                10162000
integer inttype,realtype,alfatype,chartype,booltype,niltype,texttype,   10163000
  inputfile,outputfile,emptyset;                                        10164000
boolean inputdecl,outputdecl;                                           10165000
                                                                        10166000
%*** temporary variables ***                                            10167000
integer t1,t2,t3,t4,t5;                                                 10168000
                                                                        10169000
%*** other variables ***                                                10170000
alpha user;                   % the user number found on the  user card.10171000
                                                                        10172000
integer curlevel,             % current procedure level.                10173000
        toplevel,             % top level in display vector.            10174000
        numbegins,            % number of "begin"s in the program.      10175000
        numcases,             % number of case-statements in program.   10176000
        numreps,              % number of repeat-statements in program. 10177000
        numtemps,             % number of temporary variables in use.   10178000
        curfunc,              % index of function currently compiled.   10179000
        cursy,                % last symbol read by scanner.            10180000
        curtype,              % type of entity last compiled.           10181000
        curmode,              % current expression mode.                10182000
        lastrec;              % last record table defined.              10183000
                                                                        10184000
label endofinput;                                                       10185000
                                                                        10186000
format noerrors ("no errors detected."),                                10187000
       errors   (i5," errors detected"/),                               10188000
       alist    ("$ set list single"),                                  10189000
       noalist  ("$ reset list"),                                       10190000
       lastline ("; terminate: end of pascal program."),                10191000
       termmess ("****  end-of-input.    compilation terminated.");     10192000
monitor expovr:=realoverflow;                                           10193000
                                                                        10194000
%*** scanner symbols ***                                                10195000
define   identifier=1#, intconst=2#,   realconst=3#,  alfaconst=4#,     10196000
         charconst=5#,  notsy=6#,      asterisk=7#,   slash=8#,         10197000
         andsy=9#,      divsy=10#,     modsy=11#,     plus=12#,         10198000
         minus=13#,     orsy=14#,      lsssy=15#,     leqsy=16#,        10199000
         geqsy=17#,     gtrsy=18#,     neqsy=19#,     eqlsy=20#,        10200000
         insy=21#,      lpar=22#,      rpar=23#,      lbracket=24#,     10201000
         rbracket=25#,  doubledot=26#, comma=27#,     semicolon=28#,    10202000
         dot=29#,       arrow=30#,     colon=31#,     assignsy=32#,     10203000
         beginsy=33#,   endsy=34#,     ifsy=35#,      thensy=36#,       10204000
         elsesy=37#,    casesy=38#,    ofsy=39#,      repeatsy=40#,     10205000
         untilsy=41#,   whilesy=42#,   dosy=43#,      forsy=44#,        10206000
         tosy=45#,      downtosy=46#,  gotosy=47#,    nilsy=48#,        10207000
         typesy=49#,    arraysy=50#,   recordsy=51#,  filesy=52#,       10208000
         setsy=53#,     constsy=54#,   varsy=55#,     labelsy=56#,      10209000
         funcsy=57#,    procsy=58#,    withsy=59#,    programsy=60#,    10210000
         packedsy=61#;                                                  10211000
                                                                        10212000
define initial=0#, middle=1#, terminal=2#;                              10213000
define number=0#, bitpattern=1#;                                        10214000
$ page                                                                  10215000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%20001000
%                                                                      %20002000
%                                                                      %20003000
%                                                                      %20004000
%                 part 2:   compiler utility routines.                 %20005000
%                           --------------------------                 %20006000
%                                                                      %20007000
%                                                                      %20008000
%                                                                      %20009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%20010000
                                                                        20011000
                                                                        20012000
procedure insymbol;    forward;                                         20013000
procedure writealgol;   forward;                                        20014000
procedure newxref(name1,name2,table,decl);                              20015000
value name1, name2, table, decl;                                        20016000
real name1, name2;                                                      20017000
integer table;                                                          20018000
boolean decl;                                                           20019000
forward;                                                                20020000
                                                                        20021000
define ndigits(n)=                                                      20022000
if n{ 9 then 1 else                                                     20023000
if n{99 then 2 else 3 digits#;                                          20024000
                                                                        20025000
define heading=                                                         20026000
begin comment *** prints a heading on top of a new page. ;              20027000
    pagecnt:=pagecnt+1;                                                 20028000
    replace pointer(headtext[*])+85 by pagecnt for ndigits(pagecnt);    20029000
    write(lines[page]);                                                 20030000
    write(lines[dbl],11,headtext[*]);                                   20031000
    linecnt:=2;                                                         20032000
end of heading#;                                                        20033000
                                                                        20034000
                                                                        20035000
define printline=             %*** prints a source code line.           20036000
begin                                                                   20037000
    replace linepnt-8 by cardcnt for 5 digits;                          20038000
    if linecnt}linesperpage then heading;                               20039000
    if reswordoption then                                               20040000
    begin                                                               20041000
      write(lines[no],11,xline[*]);                                     20042000
      write(lines[no],11,xline[*]);                                     20043000
    end;                                                                20044000
    write(lines,17,line[*]);                                            20045000
    linecnt:=linecnt+1;                                                 20046000
end of printline#;                                                      20047000
                                                                        20048000
                                                                        20049000
define newcard=               %*** reads a new source code card.        20050000
begin                                                                   20051000
    if listoption then printline;                                       20052000
    if errinx>0 then printerrors;                                       20053000
    read(card,10,icard[*]) [endofinput];                                20054000
    cardpnt:=pointer(icard[*]);                                         20055000
    replace linepnt by cardpnt for 10 words, " " for 6 words;           20056000
    replace xlinepnt by " " for 10 words;                               20057000
    charcnt:=cardlength;                                                20058000
    margincnt:=85;                                                      20059000
    cardcnt:=cardcnt+1;                                                 20060000
end#;                                                                   20061000
                                                                        20062000
                                                                        20063000
define gen(t,n,start)=        %*** generate a text "t", consisting of   20064000
begin                         %*** "n" letters, starting at "start".    20065000
    if algolcnt<n then writealgol;                                      20066000
    text[0]:=t;                                                         20067000
    replace algolpnt:algolpnt by textpnt0+start for n;                  20068000
    algolcnt:=algolcnt-n;                                               20069000
end#;                                                                   20070000
                                                                        20071000
                                                                        20072000
define genid(l,num,ndig)=     %*** generate an xalgol identifier.       20073000
begin                                                                   20074000
    if algolcnt{ndig then writealgol;                                   20075000
    ch[0]:=l;                                                           20076000
    replace algolpnt:algolpnt by charpnt for 1, num for ndig digits;    20077000
    algolcnt:=algolcnt-ndig-1;                                          20078000
end#;                                                                   20079000
                                                                        20080000
                                                                        20081000
integer nabs,nsize;                                                     20082000
                                                                        20083000
define genint(n)=                                                       20084000
begin                                                                   20085000
    nabs:=abs(n);  if n<0 then gen("-",1,7);                            20086000
    nsize:=if nabs{       9 then 1 else                                 20087000
           if nabs{     999 then 3 else                                 20088000
           if nabs{   99999 then 5 else                                 20089000
           if nabs{99999999 then 8 else 12;                             20090000
    if algolcnt<nsize then writealgol;                                  20091000
    if nsize=12 then                                                    20092000
    replace algolpnt:algolpnt by (nabs div 1000000) for 6 digits,       20093000
                           entier(nabs mod 1000000) for 6 digits else   20094000
    replace algolpnt:algolpnt by nabs for nsize digits;                 20095000
    algolcnt:=algolcnt-nsize;                                           20096000
end of genint#;                                                         20097000
                                                                        20098000
                                                                        20099000
procedure genreal(x);                                                   20100000
value x; real x;                                                        20101000
begin                                                                   20102000
  real absx;                                                            20103000
  integer power,v1,v2;                                                  20104000
                                                                        20105000
  if x.[46:5]=0 then                                                    20106000
  begin                                                                 20107000
    if algolcnt<9 then writealgol;                                      20108000
    text[0]:=x;                                                         20109000
    replace algolpnt:algolpnt by """, textpnt for 7, """;               20110000
    algolcnt:=algolcnt-9;                                               20111000
  end else                                                              20112000
  begin                                                                 20113000
    if algolcnt<22 then writealgol;                                     20114000
    if x<0 then gen("(-",2,6);                                          20115000
    absx:=abs(x);                                                       20116000
    if absx> 0 then                                                     20117000
    begin                                                               20118000
      while absx}1@7 do begin absx:=absx/10; power:=power+1; end;       20119000
      while absx<1@6 do begin absx:=absx/10; power:=power-1; end;       20120000
      v1:=entier(absx);                                                 20121000
      v2:=entier((absx-v1)|1000000);                                    20122000
      replace algolpnt:algolpnt by v1 for 7 digits, ".",                20123000
        v2 for 6 digits, "@";                                           20124000
      algolcnt:=algolcnt-15;                                            20125000
      if power<0 then gen("-",1,7);                                     20126000
      power:=abs(power);                                                20127000
      replace algolpnt:algolpnt by power for 2 digits;                  20128000
      algolcnt:=algolcnt-2;                                             20129000
    end else gen("0",1,7);                                              20130000
    if x<0 then gen(")",1,7);                                           20131000
  end;                                                                  20132000
end of genreal;                                                         20133000
                                                                        20134000
                                                                        20135000
integer typeindex;                                                      20136000
                                                                        20137000
define newtype=                                                         20138000
begin                                                                   20139000
    if numtypes}maxtypes then begin error(45);numtypes:=maxtypes-20 end;20140000
    typeindex:=numtypes:=numtypes+1;                                    20141000
end #;                                                                  20142000
                                                                        20143000
                                                                        20144000
procedure writealgol;         %*** writes a completed xalgol card to    20145000
begin                         %*** the file.                            20146000
    replace pointer(algolcard[9]) by cardcnt for 8 digits;              20147000
    write(pascalgol,10,algolcard[*]);                                   20148000
    if dumpoption then write(lines,10,algolcard[*]);                    20149000
    algolpnt:=pointer(algolcard[*]);  algolcnt:=71;                     20150000
    replace algolpnt by " " for 9 words;                                20151000
end of writealgol;                                                      20152000
                                                                        20153000
                                                                        20154000
define margin(letter,num)=                                              20155000
begin comment *** places information in the margin. ;                   20156000
    if margincnt{118 then                                               20157000
    begin text[0]:=letter;                                              20158000
          replace linepnt+margincnt by textpnt+5 for 2,                 20159000
                  num for ndigits(num);                                 20160000
          margincnt:=margincnt+6;                                       20161000
    end;                                                                20162000
end of margin#;                                                         20163000
                                                                        20164000
                                                                        20165000
procedure skip(symbol);       %*** skip symbols to recover from error   20166000
value symbol; integer symbol; %*** condition.                           20167000
begin                                                                   20168000
    while cursy!symbol and symkind[cursy]=middle do                     20169000
    if cursy=recordsy then                                              20170000
    begin do begin insymbol;                                            20171000
                   skip(99);                                            20172000
          end until cursy!semicolon and cursy!casesy;                   20173000
    end else insymbol;                                                  20174000
end of skip;                                                            20175000
                                                                        20176000
                                                                        20177000
procedure error(errnum);                                                20178000
value errnum;  integer errnum;                                          20179000
begin comment *** arrange error indicator. ;                            20180000
    numerrs:=numerrs+1;                                                 20181000
    err[errnum]:=true;                                                  20182000
    errinx:=max(errinx,cardlength-2-charcnt);                           20183000
    if errinx{115 then                                                  20184000
    begin replace pointer(errline[1])+errinx by "|",                    20185000
              errnum for ndigits(errnum);                               20186000
          errinx:=errinx+(if errnum{ 9 then 2 else                      20187000
                          if errnum{99 then 3 else 4);                  20188000
end end of error;                                                       20189000
                                                                        20190000
                                                                        20191000
procedure printerrors;                                                  20192000
begin comment *** print error indicators. ;                             20193000
    if not listoption then printline;                                   20194000
    write(lines,17,errline[*]);                                         20195000
    linecnt:=linecnt+1;                                                 20196000
    replace pointer(errline[1]) by " " for 16 words;                    20197000
    errinx:=0;                                                          20198000
end of print errors;                                                    20199000
                                                                        20200000
                                                                        20201000
define hash(n) = (n).[35:36] mod maxnames#;                             20202000
                                                                        20203000
integer thislevel,thistab,thisindex;                                    20204000
alpha thisid,tname;                                                     20205000
boolean found;                                                          20206000
                                                                        20207000
define searchtab(tab)=        %*** search name table "tab" for the      20208000
begin                         %*** identifier just read.                20209000
      thisindex:=hash(curname1);                                        20210000
      tname:=nametab1[tab,thisindex];                                   20211000
      while (if tname=curname1 then nametab2[tab,thisindex]!curname2    20212000
                               else tname!0) do                         20213000
      begin                                                             20214000
        thisindex:=if thisindex=0 then maxnames else thisindex-1;       20215000
        tname:=nametab1[tab,thisindex];                                 20216000
      end;                                                              20217000
      found:=tname!0;                                                   20218000
    if xrefoption then                                                  20219000
    if found then newxref(curname1,curname2,tab,false);                 20220000
end of searchtab#;                                                      20221000
                                                                        20222000
define search=                %*** search all tables currently in use.  20223000
begin                                                                   20224000
    thislevel:=toplevel+1;                                              20225000
    do begin                                                            20226000
      thislevel:=thislevel-1;                                           20227000
      thistab:=if thislevel{curlevel then thislevel                     20228000
                                     else display[thislevel].nametab;   20229000
      searchtab(thistab);                                               20230000
    end until found or thislevel=0;                                     20231000
    thisid:=nametab3[thistab,thisindex];                                20232000
end of search #;                                                        20233000
                                                                        20234000
                                                                        20235000
define newname(name1,name2,tab) =                                       20236000
begin               %*** enter a new name into the name table "tab".    20237000
      thisindex:=hash(name1);                                           20238000
      tname:=nametab1[tab,thisindex];                                   20239000
      while(if tname=name1 then nametab2[tab,thisindex]!name2           20240000
                           else tname!0) do                             20241000
      begin                                                             20242000
        thisindex:=if thisindex=0 then maxnames else thisindex-1;       20243000
        tname:=nametab1[tab,thisindex];                                 20244000
      end;                                                              20245000
      if tname!0 then error(2);                                         20246000
      nametab1[tab,thisindex]:=name1;                                   20247000
      nametab2[tab,thisindex]:=name2;                                   20248000
    if xrefoption then newxref(name1,name2,tab,true);                   20249000
end of newname #;                                                       20250000
                                                                        20251000
                                                                        20300000
procedure initialize;                   %*** initialization ***         20301000
begin                                   %**********************         20302000
    integer t1,t3;                                                      20303000
    alpha a;                                                            20304000
    fill symkind[*] with 28(middle),terminal,4(middle),initial,terminal,20305000
      initial,middle,terminal,initial,middle,initial,terminal,initial,  20306000
      middle,initial,2(middle),initial,middle,initial,4(middle),        20307000
      7(initial),middle;                                                20308000
                                                                        20309000
    fill symbol[*] with 10(0),0,arrow,0,colon,gtrsy,geqsy,plus,9(0),    20310000
      dot,lbracket,andsy,lpar,lsssy,arrow,0,9(0),0,asterisk,minus,      20311000
      rpar,semicolon,leqsy,0,slash,8(0),comma,0,neqsy,eqlsy,rbracket,   20312000
      0,doubledot;                                                      20313000
                                                                        20314000
    linepnt :=pointer(line[1]);                                         20315000
    xlinepnt:=pointer(xline[1]);                                        20316000
    replace linepnt-8 by "     => ", " " for 16 words;                  20317000
    replace xlinepnt-8 by " " for 11 words;                             20318000
    replace pointer(errline[*]) by "****    ", " " for 16 words;        20319000
    algolpnt:=pointer(algolcard[*]);  algolcnt:=71;                     20320000
    replace algolpnt by " " for 9 words;                                20321000
    charpnt:=pointer(ch[*])+7;                                          20322000
    textpnt:=pointer(text[*])+1;  textpnt0:=textpnt-1;                  20323000
    replace textpnt by " " for 15;                                      20324000
    stringpnt:=pointer(string[*]);                                      20325000
    replace pointer(headtext[*]) by " " for 10 words, "page    ";       20326000
    replace pointer(headtext[*]) by "pascal(", edition, ")/b-5700";     20327000
    text[0]:=time(5);                                                   20328000
    replace pointer(headtext[*])+45 by textpnt+3 for 2, "/",            20329000
      textpnt+1 for 2, "/", textpnt+5 for 2;                            20330000
    t1:=time(1)/3600;                                                   20331000
    replace pointer(headtext[*])+57 by (t1 div 60) for 2 digits, ":",   20332000
      entier(t1 mod 60) for 2 digits;                                   20333000
    heading;                                                            20334000
                                                                        20335000
    %*** initialize intrinsic types, constants etc. ***                 20336000
                                                                        20337000
    inttype:=t3:=1;                     %*** "integer" ***              20338000
    t1:=numeric;  t1.size:=1;   t1.struct:=0;                           20339000
    typetab1[1]:=t1;  typetab2[1]:=-maxint;  typetab3[1]:=maxint;       20340000
    newname("7intege", "r", 0);  t3.idclass:=types;                     20341000
    nametab3[0,thisindex]:=t3;                                          20342000
    realtype:=t3:=2;                    %*** "real" ***                 20343000
    t1.form:=floating;   typetab1[2]:=t1;                               20344000
    newname("400real", 0,0);  t3.idclass:=types;                        20345000
    nametab3[0,thisindex]:=t3;                                          20346000
    alfatype:=t3:=3;                    %*** "alfa" ***                 20347000
    t1.form:=alfa;  typetab1[3]:=t1;                                    20348000
    newname("400alfa",0,0);  t3.idclass:=types;                         20349000
    nametab3[0,thisindex]:=t3;                                          20350000
    booltype:=t3:=4;                    %*** "boolean" ***              20351000
    t1.form:=symbolic;  typetab1[4]:=t1;  typetab3[4]:=1;               20352000
    newname("7boolea", "n",0); t3.idclass:=types;                       20353000
    nametab3[0,thisindex]:=t3;                                          20354000
    booltype:=t3:=5;                    %*** "char" ***                 20355000
    t1.form:=char;  typetab1[5]:=t1;  typetab3[5]:=63;                  20356000
    newname("400char", 0,0); t3.idclass:=types;                         20357000
    nametab3[0,thisindex]:=t3;                                          20358000
    t3:=booltype;  t3.idclass:=const;    %*** "false" ***               20359000
    newname("50false",0,0);  nametab3[0,thisindex]:=t3;                 20360000
    t3.info:=1;                         %*** "true" ***                 20361000
    newname("400true",0,0);  nametab3[0,thisindex]:=t3;                 20362000
    numtypes:=5;                                                        20363000
    niltype:=-1;                        %*** type of "nil" ***          20364000
    emptyset:=-2;                       %*** type of [] ***             20365000
    newname("6maxint",0,0);   t3:=inttype;        %*** "maxint" ***     20366000
    t3.idclass:=const;  t3.info:=1024;                                  20367000
    nametab3[0,thisindex]:=t3;                                          20368000
    numconsts:=1;  consttab[1]:=maxint;                                 20369000
                                                                        20370000
    t3:=0;    t3.idclass:=proc;         %*** procedures ***             20371000
    for a:="3000get", "3000new", "400pack", "400page", "3000put",       20372000
           "400read", "6readln", "50reset", "6unpack", "50write" do     20373000
    begin                                                               20374000
        newname(a,0,0);   nametab3[0,thisindex]:=t3;                    20375000
    end;                                                                20376000
    newname("7dispos","e",0);   nametab3[0,thisindex]:=t3;              20377000
    newname("7rewrit","e",0);   nametab3[0,thisindex]:=t3;              20378000
    newname("7writel","n",0);   nametab3[0,thisindex]:=t3;              20379000
                                                                        20380000
    t3.idclass:=func;                  %*** functions ***               20381000
    for a:="3000abs", "6arctan", "3000chr", "3000cos", "3000eof",       20382000
           "400eoln", "3000exp", "20000ln", "3000odd", "400pred",       20383000
           "400succ", "50round", "3000sin", "3000sqr", "400sqrt",       20384000
           "50trunc", "6concat", "400time", "400date", "6iotime",       20385000
           "400user", "3000ord"                                         20386000
    do begin                                                            20387000
        newname(a,0,0);  nametab3[0,thisindex]:=t3;                     20388000
    end;                                                                20389000
    newname("7elapse","d",0);   nametab3[0,thisindex]:=t3;              20390000
    newname("7weekda","y",0);   nametab3[0,thisindex]:=t3;              20391000
                                                                        20392000
    texttype:=t3:=numtypes:=numtypes+1;  %*** "text" ***                20393000
    t1 := textfile;  t1.struct := 1;  typetab1[texttype] := t1;         20394000
    t3.idclass := types;                                                20395000
    newname("400text",0,0);  nametab3[0,thisindex]:=t3;                 20396000
    t3:=texttype;  t3.idclass:=var;      %*** "input" ***               20397000
    t3.externalfile:=1;                                                 20398000
    newname("50input",0,0);   inputfile:=thisindex;                     20399000
    nametab3[0,thisindex]:=t3;                                          20400000
    newname("6output",0,0);              %*** "output" ***              20401000
    nametab3[0,thisindex]:=t3;  outputfile:=thisindex;                  20402000
end of intialized;                                                      20403000
                                                                        20404000
                                                                        20500000
                                                                        20501000
%***  xref routines ***                                                 20502000
%**********************                                                 20503000
                                                                        20504000
define xrefcard=[16:17]#,                                               20505000
       xrefblock=[26:10]#;                                              20506000
real a0,b0,a1,b1,lasta0,lasta1;                                         20507000
integer nl,lastblock,a2,ax;                                             20508000
                                                                        20509000
procedure newxref(name1,name2,table,decl);                              20510000
value name1,name2,table,decl;                                           20511000
real name1,name2;                                                       20512000
integer table;                                                          20513000
boolean decl;                                                           20514000
begin                                                                   20515000
    nl:=name1.namelength;                                               20516000
    if nl<7 then name1:=0&name1[41:41:6]&name1[35:6|nl-1:6|nl]          20517000
            else name2:=0&name2[35:6|(nl-6)-1:6|(nl-6)];                20518000
    ax:=cardcnt;  ax.xrefblock:=blocktab[table];                        20519000
    if decl then ax:=ax-100000000000;                                   20520000
    write(xreffile,*,name1,name2,ax);                                   20521000
end of newxref;                                                         20522000
                                                                        20523000
procedure xrefmax(a);                                                   20524000
array a[0];                                                             20525000
begin                                                                   20526000
    a[0]:="azzzzzz";  a[1]:="zzzzzz"; a[2]:=9999999999;                 20527000
end of xrefmax;                                                         20528000
                                                                        20529000
                                                                        20530000
boolean procedure xrefcompare(a,b);                                     20531000
array a,b[0];                                                           20532000
begin                                                                   20533000
    a0:=a[0];  b0:=b[0];   a1:=a[1];  b1:=b[1];                         20534000
    xrefcompare:=                                                       20535000
    if a0.[35:36]!b0.[35:36] then a0.[35:36]<b0.[35:36] else            20536000
    if a1!b1 then a1<b1 else                                            20537000
    if a0!b0 then a0.namelength<b0.namelength else                      20538000
    a[2] leq b[2];                                                      20539000
end of xrefcompare;                                                     20540000
                                                                        20541000
                                                                        20542000
procedure printxref(finis,a);                                           20543000
value finis;  boolean finis;                                            20544000
array a[0];                                                             20545000
begin                                                                   20546000
    if finis then                                                       20547000
    begin                                                               20548000
      write(lines,17,xrefline[*]);                                      20549000
      close(lines);                                                     20550000
      close(xreffile);                                                  20551000
    end                                                                 20552000
    else                                                                20553000
    begin                                                               20554000
    a0:=a[0];   a1:=a[1];   a2:=a[2];                                   20555000
      if a0=lasta0 and a1=lasta1 and a2.xrefblock=lastblock then        20556000
      begin                                                             20557000
        if numxref=15 then                                              20558000
        begin                                                           20559000
          write(lines,17,xrefline[*]);  linecnt:=linecnt+1;             20560000
          if linecnt>linesperpage then heading;                         20561000
          xrefpnt:=pointer(xrefline[*]);  numxref:=0;                   20562000
          replace xrefpnt by " " for 17 words;  xrefpnt:=xrefpnt+24;    20563000
        end;                                                            20564000
        replace xrefpnt by a2.xrefcard for 5 digits;                    20565000
        xrefpnt:=xrefpnt+7;  numxref:=numxref+1;                        20566000
      end else                                                          20567000
      if a2<0 then                                                      20568000
      begin                                                             20569000
        a2:=a2+100000000000;                                            20570000
        write(lines,17,xrefline[*]);  linecnt:=linecnt+1;               20571000
        if linecnt>linesperpage then heading;                           20572000
        xrefpnt:=pointer(xrefline[*]);  numxref:=0;                     20573000
        replace xrefpnt by " " for 17 words;                            20574000
        text[0]:=a0.[35:36];  lasta0:=a0;                               20575000
        replace xrefpnt by textpnt+1 for a0.namelength;                 20576000
        text[0]:=lasta1:=a1;                                            20577000
        if a0.namelength>6 then                                         20578000
        replace xrefpnt+6 by textpnt+1 for a0.namelength-6;             20579000
        replace xrefpnt+17 by a2.xrefcard for 5 digits;                 20580000
        xrefpnt:=xrefpnt+24;  lastblock:=a2.xrefblock;                  20581000
      end;                                                              20582000
    end;                                                                20583000
end of printxref;                                                       20584000
                                                                        20585000
                                                                        20800000
                                                                        20801000
integer tt1,tt2,f1,f2,lt,rt;                                            20802000
                                                                        20803000
define checktypes(lefttype,righttype)=                                  20804000
begin                                                                   20805000
    if lefttype>0 and righttype>0 then                                  20806000
    if lefttype!righttype then                                          20807000
    begin                                                               20808000
      lt:=lefttype;        rt:=righttype;                               20809000
      tt1:=typetab1[lt];   tt2:=typetab1[rt];                           20810000
      f1:=tt1.form;        f2:=tt2.form;                                20811000
      if lt!realtype or f2!numeric then                                 20812000
      if(f1!set and lt!emptyset)or(f2!set and rt!emptyset)then          20813000
      if(f1!pointers and lt!niltype)or(f2!pointers and rt!niltype)then  20814000
      begin                                                             20815000
        if f1=set and f2=set then                                       20816000
        begin                                                           20817000
          lt:=tt1.settype;     rt:=tt2.settype;                         20818000
          tt1:=typetab1[lt];   tt2:=typetab1[rt];                       20819000
          f1:=tt1.form;        f2:=tt2.form;                            20820000
        end;                                                            20821000
        if f1=pointers and f2=pointers then                             20822000
        begin                                                           20823000
          lt:=tt1.pointtype;   rt:=tt2.pointtype;                       20824000
          tt1:=typetab1[lt];   tt2:=typetab1[rt];                       20825000
          f1:=tt1.form;        f2:=tt2.form;                            20826000
        end;                                                            20827000
        while f1=subtype do                                             20828000
        begin lt:=tt1.maintype;   tt1:=typetab1[lt];  f1:=tt1.form end; 20829000
        while f2=subtype do                                             20830000
        begin rt:=tt2.maintype;   tt2:=typetab1[rt];  f2:=tt2.form end; 20831000
        if lt>0 and rt>0 then                                           20832000
        if lt!rt then                                                   20833000
        if f1!numeric or f2!numeric then                                20834000
        if f1!char or f2!char then error(17);                           20835000
      end;                                                              20836000
    end;                                                                20837000
end of checktypes#;                                                     20838000
                                                                        20839000
                                                                        20840000
integer filename;                                                       20841000
boolean lparfound;                                                      20842000
                                                                        20843000
define fileparam(defaultfile)=%*** checks the first parameter to see    20844000
begin                         %*** if it is a file.                     20845000
    insymbol;  filename:=curtype:=0;                                    20846000
    lparfound:=cursy=lpar;                                              20847000
    if lparfound then                                                   20848000
    begin                                                               20849000
      insymbol;                                                         20850000
      if cursy=identifier then                                          20851000
      begin                                                             20852000
        search;                                                         20853000
        if found then                                                   20854000
        begin                                                           20855000
          if thisid.idclass=var then                                    20856000
          begin                                                         20857000
            curtype:=thisid.type;                                       20858000
            if typetab1[curtype].form}files then                        20859000
            begin                                                       20860000
              filename:=1000|thislevel+thisindex;                       20861000
              insymbol;                                                 20862000
     end end end end;                                                   20863000
     if symkind[cursy]=terminal then error(46);                         20864000
   end;                                                                 20865000
   if filename=0 then filename:=defaultfile;                            20866000
   if (filename=inputfile and not inputdecl) or                         20867000
       (filename=outputfile and not outputdecl) then error(96);         20868000
end of fileparam#;                                                      20869000
                                                                        20870000
                                                                        20871000
integer tform;                                                          20872000
boolean signed,negative;                                                20873000
                                                                        20874000
define constant(cval,ctype)=           %*** <constant> ***              20875000
begin                                  %******************              20876000
    if cursy=minus or cursy=plus then                                   20877000
    begin signed:=true; negative:=cursy=minus;                          20878000
          insymbol;                                                     20879000
    end else signed:=negative:=false;                                   20880000
    if cursy=intconst then                                              20881000
    begin ctype:=inttype;                                               20882000
          cval:=if negative then -curval else curval;                   20883000
    end else                                                            20884000
    if cursy=charconst then                                             20885000
    begin if signed then error(29);                                     20886000
          ctype:=chartype;  cval:=curval;                               20887000
    end else                                                            20888000
    if cursy=realconst then                                             20889000
    begin ctype:=realtype;                                              20890000
          cval:=if negative then -curval else curval;                   20891000
    end else                                                            20892000
    if cursy=alfaconst then                                             20893000
    begin if signed then error(29);                                     20894000
          if curlength>7 then error(41);                                20895000
          ctype:=alfatype;  cval:=curval;                               20896000
    end else                                                            20897000
    if cursy=identifier then                                            20898000
    begin                                                               20899000
      search;                                                           20900000
      if found then                                                     20901000
      begin                                                             20902000
       if thisid.idclass=const and not boolean(thisid.formal) then      20903000
        begin                                                           20904000
          if typetab1[thisid.type].form{alfa then                       20905000
          begin                                                         20906000
            cval:=thisid.info;                                          20907000
            if cval>1023 then cval:=consttab[cval-1023];                20908000
            ctype:=thisid.type;                                         20909000
            if signed then                                              20910000
            begin                                                       20911000
                tform:=typetab1[thisid.type].form;                      20912000
                if tform!numeric and tform!floating then error(29) else%20913000
                if negative then cval:=-cval;                           20914000
            end;                                                        20915000
          end else begin error(48); cval:=ctype:=0 end;                 20916000
        end else begin error(32); cval:=ctype:=0 end;                   20917000
      end else begin error(1); cval:=ctype:=0 end;                      20918000
    end else begin error(32); cval:=ctype:=0 end;                       20919000
    insymbol;                                                           20920000
end of constant#;                                                       20921000
$ page                                                                  20922000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%30001000
%                                                                      %30002000
%                                                                      %30003000
%                                                                      %30004000
%                  part 3:  the scanner.                               %30005000
%                           ------------                               %30006000
%                                                                      %30007000
%                                                                      %30008000
%                                                                      %30009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%30010000
%                                                                       30011000
%                 internal      internal          symbol                30012000
%   symbol         number         name             kind                 30013000
%                                                                       30014000
%   identifier        1         identifier        middle                30015000
%   122               2         intconst          middle                30016000
%   2.5               3         realconst         middle                30017000
%   "abcd"            4         alfaconst         middle                30018000
%   "c"               5         charconst         middle                30019000
%   not               6         notsy             middle                30020000
%   *                 7         asterisk          middle                30021000
%   /                 8         slash             middle                30022000
%   &    and          9         andsy             middle                30023000
%   div              10         divsy             middle                30024000
%   mod              11         modsy             middle                30025000
%   +                12         plus              middle                30026000
%   -                13         minus             middle                30027000
%   or               14         orsy              middle                30028000
%   <    lss         15         lsssy             middle                30029000
%   <=   leq   {     16         leqsy             middle                30030000
%   >=   geq   }     17         geqsy             middle                30031000
%   >    gtr         18         gtrsy             middle                30032000
%   <>   neq   !     19         neqsy             middle                30033000
%   =    eql         30         eqlsy             middle                20034000
%   in               21         insy              middle                30035000
%   (                22         lpar              middle                30036000
%   )                23         rpar              middle                30037000
%   [                24         lbracket          middle                30038000
%   ]                25         rbracket          middle                30039000
%   ..               26         doubledot         middle                30040000
%   ,                27         comma             middle                30041000
%   ;                28         semicolon         terminal              30042000
%   .                29         dot               middle                30043000
%   ~     @          30         arrow             middle                30044000
%   :                31         colon             middle                30045000
%   :=               32         assignsy          middle                30046000
%   begin            33         beginsy           initial               30047000
%   end              34         endsy             terminal              30048000
%   if               35         ifsy              initial               30049000
%   then             36         thensy            middle                30050000
%   else             37         elsesy            terminal              30051000
%   case             38         casesy            initial               30052000
%   of               39         ofsy              middle                30053000
%   repeat           40         repeatsy          initial               30054000
%   until            41         untilsy           terminal              30055000
%   while            42         whilesy           initial               30056000
%   do               43         dosy              middle                30057000
%   for              44         forsy             initial               30058000
%   to               45         tosy              middle                30059000
%   downto           46         downtosy          middle                30060000
%   goto             47         gotosy            initial               30061000
%   nil              48         nilsy             middle                30062000
%   type             49         typesy            initial               30063000
%   array            50         arraysy           middle                30064000
%   record           51         recordsy          middle                30065000
%   file             52         filesy            middle                30066000
%   set              53         setsy             middle                30067000
%   const            54         constsy           initial               30068000
%   var              55         varsy             initial               30069000
%   label            56         labelsy           initial               30070000
%   function         57         funcsy            initial               30071000
%   procedure        58         procsy            initial               30072000
%   with             59         withsy            initial               30073000
%   program          60         programsy         initial               30074000
%   packed           61         packedsy          middle                30075000
                                                                        30076000
                                                                        30077000
define blank=48#, equal=61#, quotes=63#, dollar=42#,                    30078000
       letter(c)=(17{c and c{25)or(33{c and c{41)or(50{c and c{57)#,    30079000
       alfanum(c)=(letter(c) or c{9)#;                                  30080000
                                                                        30081000
real curval;                                                            30082000
alpha curname1,curname2,c,cx;                                           30083000
integer curlength,lastcharpos;                                          30084000
boolean finis;                                                          30085000
                                                                        30086000
define nextchar=                                                        30087000
begin comment *** read next character. ***;                             30088000
    if charcnt=0 then c:=blank else                                     30089000
    begin                                                               30090000
        replace charpnt by cardpnt:cardpnt for 1;                       30091000
        c:=ch[0]; charcnt:=charcnt-1;                                   30092000
end end #;                                                              30093000
                                                                        30094000
                                                                        30095000
                                                                        30096000
procedure insymbol;                                                     30097000
begin comment *** reads the next symbol. ***;                           30098000
    integer scale,exp;                                                  30099000
    boolean negexp;                                                     30100000
    label start,overflow;                                               30101000
                                                                        30102000
start:                                                                  30103000
    if c=blank then                                                     30104000
    begin scan cardpnt:cardpnt for charcnt:charcnt while =" ";          30105000
          if charcnt=0 then begin newcard; go to start end;             30106000
          nextchar;                                                     30107000
    end;                                                                30108000
    if letter(c) then                                                   30109000
    begin                                                               30110000
        curlength:=1;  curname1:=c;  curname2:=0;                       30111000
        nextchar;                                                       30112000
        while alfanum(c) and curlength<6 do                             30113000
        begin curname1:=c&curname1[35:29:30];                           30114000
              curlength:=curlength+1;  nextchar;                        30115000
        end;                                                            30116000
        if curlength=6 then                                             30117000
        begin                                                           30118000
            while alfanum(c) and curlength<12 do                        30119000
            begin curname2:=c&curname2[35:29:30];                       30120000
                  curlength:=curlength+1;  nextchar;                    30121000
            end;                                                        30122000
            while alfanum(c) do nextchar;                               30123000
        end;                                                            30124000
        curname1.namelength:=curlength;                                 30125000
        case curlength of                                               30126000
        begin ;                                                         30127000
          cursy:=identifier;                                            30128000
          cursy:=if curname1="20000if" then ifsy else                   30129000
                 if curname1="20000do" then dosy else                   30130000
                 if curname1="20000to" then tosy else                   30131000
                 if curname1="20000or" then orsy else                   30132000
                 if curname1="20000of" then ofsy else                   30133000
                 if curname1="20000in" then insy else identifier;       30134000
          cursy:=if curname1="3010end" then endsy else                  30135000
                 if curname1="3010for" then forsy else                  30136000
                 if curname1="3010div" then divsy else                  30137000
                 if curname1="3010mod" then modsy else                  30138000
                 if curname1="3010nil" then nilsy else                  30139000
                 if curname1="3010and" then andsy else                  30140000
                 if curname1="3010not" then notsy else                  30141000
                 if curname1="3010var" then varsy else                  30142000
                 if curname1="3010set" then setsy else                  30143000
                 if curname1="3010lss" then lsssy else                  30144000
                 if curname1="3010leq" then leqsy else                  30145000
                 if curname1="3010geq" then geqsy else                  30146000
                 if curname1="3010gtr" then gtrsy else                  30147000
                 if curname1="3010neq" then neqsy else                  30148000
                 if curname1="3010eql" then eqlsy else identifier;      30149000
          cursy:=if curname1="400then" then thensy else                 30150000
                 if curname1="400else" then elsesy else                 30151000
                 if curname1="400with" then withsy else                 30152000
                 if curname1="400case" then casesy else                 30153000
                 if curname1="400goto" then gotosy else                 30154000
                 if curname1="400type" then typesy else                 30155000
                 if curname1="400file" then filesy else identifier;     30156000
          cursy:=if curname1="50begin" then beginsy else                30157000
                 if curname1="50while" then whilesy else                30158000
                 if curname1="50until" then untilsy else                30159000
                 if curname1="50array" then arraysy else                30160000
                 if curname1="50const" then constsy else                30161000
                 if curname1="50label" then labelsy else identifier;    30162000
          cursy:=if curname1="6repeat" then repeatsy else               30163000
                 if curname1="6downto" then downtosy else               30164000
                 if curname1="6record" then recordsy else               30165000
                 if curname1="6packed" then packedsy else identifier;   30166000
          cursy:=if curname1="7progra" and curname2="m" then programsy %30167000
                                        else identifier;                30168000
          cursy:=if curname1="8functi" and curname2="on" then funcsy    30169000
                                        else identifier;                30170000
          cursy:=if curname1="9proced" and curname2="ure" then procsy   30171000
                                        else identifier;                30172000
          cursy:=identifier;      % 10 characters.                      30173000
          cursy:=identifier;      % 11 characters.                      30174000
          cursy:=identifier;      % 12 characters.                      30175000
        end of case;                                                    30176000
        if reswordoption and cursy!identifier then                      30177000
        begin t1:=cardlength-charcnt-curlength;                         30178000
              if charcnt=0 then cardpnt:=cardpnt+1 else t1:=t1-1;       30179000
              replace xlinepnt+t1 by cardpnt-(curlength+1)              30180000
                                                  for curlength;        30181000
        end;                                                            30182000
    end of letter else                                                  30183000
    if c{9 then                                                         30184000
    begin                                                               30185000
        curval:=c;   cursy:=intconst;                                   30186000
        nextchar;                                                       30187000
        while c{9 do begin curval:=10|curval+c; nextchar end;           30188000
        if c="." then                                                   30189000
        begin                                                           30190000
            nextchar;                                                   30191000
            if c{9 then                                                 30192000
            begin cursy:=realconst;                                     30193000
                  do begin curval:=10|curval+c;                         30194000
                           scale:=scale-1;  nextchar;                   30195000
                  end until c>9;                                        30196000
            end else if c="." then c:=64       % special mark for ".."  30197000
                              else error(4);                            30198000
        end;                                                            30199000
        if c="e" then                                                   30200000
        begin                                                           30201000
            cursy:=realconst;  nextchar;                                30202000
            if c="+" or c="-" then begin negexp:=c="-"; nextchar end;   30203000
            if c{9 then                                                 30204000
            begin exp:=c;  nextchar;                                    30205000
                  while c{9 do begin exp:=10|exp+c; nextchar end;       30206000
                  if negexp then exp:=-exp;                             30207000
            end else error(4);                                          30208000
            scale:=scale+exp;                                           30209000
        end;                                                            30210000
        if cursy=realconst then                                         30211000
        begin                                                           30212000
          realoverflow:=overflow;                                       30213000
          curval:=curval|10*scale;                                      30214000
          realoverflow:=0;                                              30215000
        end else                                                        30216000
        if curval>maxint then                                           30217000
        begin                                                           30218000
overflow:   error(14);  curval:=0;  realoverflow:=0;                    30219000
        end;                                                            30220000
    end of digit else                                                   30221000
    if c=quotes then                                                    30222000
    begin                                                               30223000
        cursy:=alfaconst;  curlength:=0;  nextchar;                     30224000
        finis:=false;                                                   30225000
        do begin                                                        30226000
            if c=quotes then begin nextchar; finis:=c!quotes end else   30227000
            if charcnt=0 then begin error(6); finis:=true end;          30228000
            if not finis then                                           30229000
            begin                                                       30230000
                replace stringpnt+curlength by charpnt for 1;           30231000
                curlength:=curlength+1;                                 30232000
                nextchar;                                               30233000
        end end until finis;                                            30234000
        if curlength=0 then error(4) else                               30235000
        if curlength=1 then                                             30236000
        begin cursy:=charconst;                                         30237000
              replace charpnt by stringpnt for 1;  curval:=ch[0];       30238000
        end else                                                        30239000
        if curlength{7 then                                             30240000
        begin text[0]:="       ";                                       30241000
              replace textpnt by stringpnt for curlength;               30242000
              curval:=text[0];                                          30243000
        end;                                                            30244000
    end of strings  else                                                30245000
    begin                                                               30246000
        cursy:=symbol[c];  nextchar;                                    30247000
        if cursy=colon and c=equal then                                 30248000
           begin cursy:=assignsy; nextchar end else                     30249000
        if cursy=dot and c="." then                                     30250000
           begin cursy:=doubledot; nextchar end else                    30251000
        if cursy=lsssy and c=equal then                                 30252000
           begin cursy:=leqsy; nextchar end else                        30253000
        if cursy=lsssy and c=">" then                                   30254000
           begin cursy:=neqsy; nextchar end else                        30255000
        if cursy=gtrsy and c=equal then                                 30256000
           begin cursy:=geqsy; nextchar end else                        30257000
        if cursy=lpar and c="*" then                                    30258000
        begin                      % *** comment ***                    30259000
            nextchar;                                                   30260000
            if c=dollar then      %  dollar indicates compiler options. 30261000
            do begin                                                    30262000
              nextchar; cx:=c;  nextchar;                               30263000
              if cx="l" then if c=1 then heading                        30264000
                                    else listoption:=c="+"   else       30265000
              if cx="r" then reswordoption:=c="+"            else       30266000
              if cx="c" then checkoption:=c="+"              else       30267000
              if cx="d" then dumpoption:=c="+"               else       30268000
              if cx="x" then xrefoption:=c="+"               else       30269000
              if cx="a" then                                            30270000
                if c="+" then write(pascalgol,alist)                    30271000
                         else write(pascalgol,noalist)   else           30272000
              if cx="t" then                                            30273000
              begin lastcharpos := charcnt - cardlength;                30274000
                    cardlength:=10|c;                                   30275000
                    nextchar; cardlength:=cardlength+c;                 30276000
                    if cardlength{9 or cardlength>80 then               30277000
                    begin error(14); cardlength:=72 end;                30278000
                    charcnt:=max(0,lastcharpos+cardlength-1);           30279000
              end;                                                      30280000
              nextchar;                                                 30281000
           end until c!",";                                             30282000
           finis:=false;                                                30283000
           do begin                                                     30284000
             if c!"*" then                                              30285000
             scan cardpnt:cardpnt for charcnt:charcnt until ="*";       30286000
             if charcnt=0 then newcard else                             30287000
             begin nextchar;                                            30288000
                   while c="*" do nextchar;                             30289000
                   finis:=c=")";                                        30290000
           end end until finis;                                         30291000
           nextchar;                                                    30292000
           go to start;                                                 30293000
       end of comment;                                                  30294000
   end;                                                                 30295000
end of insymbol;                                                        30296000
$ page                                                                  30297000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%40001000
%                                                                      %40002000
%                                                                      %40003000
%                                                                      %40004000
%                  part 4:  expression parser.                         %40005000
%                           ------------------                         %40006000
%                                                                      %40007000
%                                                                      %40008000
%                                                                      %40009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%40010000
                                                                        40011000
                                                                        40012000
procedure expression;  forward;                                         40013000
procedure concat;      forward;                                         40014000
                                                                        40015000
alpha tempsym;                                                          40016000
real sx;                                                                40017000
integer exprlevel,tx;                                                   40018000
                                                                        40019000
define puttext(t)=                                                      40020000
begin                                                                   40021000
    if numsyms=maxsyms then                                             40022000
    begin error(71);                                                    40023000
          numsyms:=1;                                                   40024000
    end else numsyms:=numsyms+1;                                        40025000
    symtab[numsyms]:=t;                                                 40026000
end of puttext #;                                                       40027000
                                                                        40028000
define putsym(s)=                                                       40029000
begin                                                                   40030000
    tempsym:=(s)&1[41:5:6];                                             40031000
    puttext(tempsym);                                                   40032000
end of putsym #;                                                        40033000
                                                                        40034000
define putconst(val)=                                                   40035000
begin                                                                   40036000
    puttext("2000000");                                                 40037000
    puttext(val);                                                       40038000
end of putconst #;                                                      40039000
                                                                        40040000
define putdummy=                                                        40041000
begin                                                                   40042000
    puttext("3000000");                                                 40043000
end of putdummy #;                                                      40044000
                                                                        40045000
define putid(l,num,numdig)=                                             40046000
begin                                                                   40047000
    text[0]:="      " & l [35:5:6];                                     40048000
    replace textpnt+2 by num for numdig digits;                         40049000
    puttext(text[0]);                                                   40050000
end of putid#;                                                          40051000
                                                                        40052000
define writeexpr=                                                       40053000
begin                                                                   40054000
    for t1:=1 step 1 until numsyms do                                   40055000
    begin                                                               40056000
       sx:=symtab[t1];  tx:=sx.[41:6];                                  40057000
       if tx=0 then gen(sx,7,2) else                                    40058000
       if tx=3 then             else                                    40059000
       if tx=1 then gen(sx,7,1) else                                    40060000
       begin                                                            40061000
           t1:=t1+1;  sx:=symtab[t1];                                   40062000
           if sx.[44:6]=0 then genint(sx) else genreal(sx);             40063000
    end end;                                                            40064000
    numsyms:=0;                                                         40065000
end of writeexpr#;                                                      40066000
                                                                        40067000
                                                                        40068000
define checkexpr(llim,ulim)=                                            40069000
begin                                                                   40070000
    puttext("check(");                                                  40071000
    expression;                                                         40072000
    putsym(",");  putconst(llim);                                       40073000
    putsym(",");  putconst(ulim);                                       40074000
    putsym(",");  putconst(cardcnt);                                    40075000
    putsym(")");                                                        40076000
end of checkexpr#;                                                      40077000
                                                                        40078000
                                                                        40079000
boolean simplevariable,insidebrackets;                                  40080000
integer numpointers;                                                    40081000
                                                                        40082000
procedure variable;                                                     40083000
begin                                                                   40084000
    integer startsym,llim,ulim;                                         40085000
    real t;                                                             40086000
    boolean inbracket,inrecord;                                         40087000
    label addaddr;                                                      40088000
                                                                        40089000
    startsym:=numsyms+1;                                                40090000
    if thislevel>curlevel then         % variable in field list of      40091000
    begin                              % record used in with-statement  40092000
      t:=display[thislevel];                                            40093000
      t4:=t.firstwithsym;  t5:=t.lastwithsym;                           40094000
      for t3:=t4 step 1 until t5 do puttext(withtab[t3]);               40095000
      inrecord:=true;                                                   40096000
      inbracket:=boolean(t.bracketsinwith);                             40097000
      numpointers:=numpointers+t.numpntrsinwith;                        40098000
      simplevariable:=false;                                            40099000
      curtype:=t.rectype;  t:=typetab1[curtype];                        40100000
      go to addaddr;                                                    40101000
    end;                                                                40102000
    if thislevel>1 and thislevel<curlevel then error(5);                40103000
    curtype:=thisid.type;  simplevariable:=true;                        40104000
    putid("v",1000|thislevel+thisindex,5);                              40105000
    insymbol;                                                           40106000
    if cursy=lbracket or cursy=dot or cursy=arrow then                  40107000
    begin                                                               40108000
      simplevariable:=false;                                            40109000
      do begin                                                          40110000
        if cursy=lbracket then                                          40111000
        begin                                                           40112000
          if not(inbracket or inrecord) then                            40113000
          begin putsym("["); inbracket:=true end;                       40114000
          do begin                                                      40115000
            t:=typetab1[curtype];                                       40116000
            llim:=typetab2[curtype];  ulim:=typetab3[curtype];          40117000
            if t.form!arrays then error(12);                            40118000
            if inrecord then puttext("    +(");                         40119000
            insymbol;                                                   40120000
            if checkoption then checkexpr(llim,ulim) else expression;   40121000
            checktypes(t.inxtype,curtype);                              40122000
            curtype:=t.arrtype;                                         40123000
            if inrecord then                                            40124000
            begin                                                       40125000
              if llim<0 then begin putsym("+"); putconst(-llim) end else40126000
              if llim>0 then begin putsym("-"); putconst( llim) end;    40127000
              putsym(")");                                              40128000
              if typetab1[curtype].size>1 then                          40129000
              begin putsym("|"); putconst(typetab1[curtype].size) end;  40130000
            end else if typetab1[curtype].struct>0 then putsym(",");    40131000
          end until cursy!comma;                                        40132000
          if cursy!rbracket then                                        40133000
          begin error(59);  skip(rbracket);                             40134000
                if cursy=rbracket then insymbol;                        40135000
          end else insymbol;                                            40136000
        end of brackets else                                            40137000
        if cursy=dot then                                               40138000
        begin                                                           40139000
          if not(inbracket or inrecord) then                            40140000
          begin putsym("["); inbracket:=true end;                       40141000
          t:=typetab1[curtype];                                         40142000
          if t.form!record then error(12);                              40143000
          insymbol;                                                     40144000
          if cursy=identifier then                                      40145000
          begin                                                         40146000
            searchtab(t.rectab);                                        40147000
            if found then                                               40148000
            begin                                                       40149000
              thisid:=nametab3[t.rectab,thisindex];                     40150000
 addaddr:     putsym("+");                                              40151000
              putconst(thisid.info); curtype:=thisid.type;              40152000
            end else begin error(1); curtype:=0 end;                    40153000
          end else begin error(9); curtype:=0 end;                      40154000
          inrecord:=true;                                               40155000
          insymbol;                                                     40156000
        end of dot else                                                 40157000
        begin  % cursy=arrow                                            40158000
          t:=typetab1[curtype];                                         40159000
          if t.form=files then                                          40160000
          begin                                                         40161000
            curtype:=t.filetype;                                        40162000
            if typetab1[curtype].struct=0 then puttext("   [0]");       40163000
          end else                                                      40164000
          if t.form=textfile then                                       40165000
          begin                                                         40166000
            symtab[numsyms]:=symtab[numsyms] & "i" [35:5:6];            40167000
              putsym(".");  puttext("lastch");                          40168000
            curtype:=chartype;                                          40169000
          end else                                                      40170000
          if t.form=pointers then                                       40171000
          begin                                                         40172000
            if inbracket then putsym("]");                              40173000
            inbracket:=false;                                           40174000
            if numsyms+2{maxsyms then                                   40175000
            begin                                                       40176000
              for t1:=numsyms step -1 until startsym do                 40177000
              symtab[t1+2]:=symtab[t1];                                 40178000
              symtab[startsym]:="  mem[";                               40179000
              symtab[startsym+1]:="  (t:=";                             40180000
              numsyms:=numsyms+2;  numpointers:=numpointers+1;          40181000
              inrecord:=true;                                           40182000
            end else error(63);                                         40183000
            curtype:=t.pointtype;                                       40184000
          end else begin error(12); curtype:=0 end;                     40185000
          insymbol;                                                     40186000
        end of arrow;                                                   40187000
      end until cursy!lbracket and cursy!dot and cursy!arrow;           40188000
      if typetab1[curtype].struct=0 then                                40189000
      begin                                                             40190000
        if inbracket then putsym("]");                                  40191000
        while numpointers>0 do                                          40192000
        begin puttext("-1)div");  puttext(" 1022,");                    40193000
              puttext(" t mod");  puttext(" 1022]");                    40194000
              numpointers:=numpointers-1;                               40195000
        end;                                                            40196000
      end;                                                              40197000
    end;                                                                40198000
    insidebrackets:=inbracket;                                          40199000
    curmode:=number;                                                    40200000
end of variable;                                                        40201000
                                                                        40202000
                                                                        40203000
procedure passparams;                                                   40204000
begin                                                                   40205000
    integer npars,param,ptype,p,firstsym;                               40206000
    boolean formalproc,check;                                           40207000
    label exit;                                                         40208000
                                                                        40209000
    putid("v",1000|thislevel+thisindex,5);                              40210000
    p:=thisid.info;                                                     40211000
    formalproc:=boolean(thisid.formal);                                 40212000
    npars:=paramtab[p];  p:=p+1;                                        40213000
    if formalproc then npars:=9999;                                     40214000
    insymbol;                                                           40215000
    if cursy=lpar then                                                  40216000
    begin                                                               40217000
      putsym("(");                                                      40218000
      do begin                                                          40219000
        insymbol;                                                       40220000
        if npars=0 then begin error(3); skip(rpar); go to exit end;     40221000
        param:=paramtab[p];  p:=p+1;                                    40222000
        ptype:=param.paramtype;                                         40223000
        if param.paramkind=const then                                   40224000
        begin                                                           40225000
          check:=checkoption and typetab1[ptype].form leq char;         40226000
          if check then puttext("check(");                              40227000
          putdummy; firstsym:=numsyms;                                  40228000
          exprlevel:=exprlevel+1;                                       40229000
          expression;  exprlevel:=exprlevel-1;                          40230000
          if curmode=bitpattern then                                    40231000
          begin symtab[firstsym]:=" real("; putsym(")"); end;           40232000
          if check then                                                 40233000
          begin                                                         40234000
            putsym(","); putconst(typetab2[ptype]);                     40235000
            putsym(","); putconst(typetab3[ptype]);                     40236000
            putsym(","); putconst(cardcnt); putsym(")");                40237000
          end;                                                          40238000
        end else                                                        40239000
        if param.paramkind=var then                                     40240000
        begin                                                           40241000
          if cursy=identifier then                                      40242000
          begin                                                         40243000
            search;                                                     40244000
            if found then                                               40245000
            begin                                                       40246000
              if thisid.idclass=var or                                  40247000
                 thisid.idclass=const and boolean(thisid.formal) then   40248000
              begin                                                     40249000
                if param.paramfile=1 then                               40250000
                begin                                                   40251000
                  curtype:=thisid.type;                                 40252000
                  putid("v",1000|thislevel+thisindex,5); putsym(",");   40253000
                  putid("f",1000|thislevel+thisindex,5); putsym(",");   40254000
                  putid("i",1000|thislevel+thisindex,5);                40255000
                  insymbol;                                             40256000
                end else                                                40257000
                begin                                                   40258000
                  variable;                                             40259000
                  if typetab1[curtype].struct>0 then                    40260000
                  if not simplevariable then error(92);                 40261000
                end;                                                    40262000
              end else begin error(8); curtype:=0 end;                  40263000
            end else begin error(1); curtype:=0 end;                    40264000
          end else begin error(9); curtype:=0 end;                      40265000
        end else                                                        40266000
        begin                                                           40267000
          if cursy=identifier then                                      40268000
          begin                                                         40269000
            search;                                                     40270000
            if found then                                               40271000
            begin                                                       40272000
              if thisid.idclass!param.paramkind then error(91);         40273000
              putid("v",1000|thislevel+thisindex,5);                    40274000
              curtype:=if thisid.idclass=func then thisid.type else 0;  40275000
              insymbol;                                                 40276000
            end else begin error(1); curtype:=0 end;                    40277000
          end else begin error(9); curtype:=0 end;                      40278000
        end;                                                            40279000
        checktypes(ptype,curtype);                                      40280000
        npars:=npars-1;                                                 40281000
        if cursy=comma then putsym(",");                                40282000
      end until cursy!comma;                                            40283000
      if cursy!rpar then begin error(89); skip(rpar) end;               40284000
exit: putsym(")");                                                      40285000
      if cursy=rpar then insymbol;                                      40286000
    end;                                                                40287000
    if npars>0 and not formalproc then error(3);                        40288000
    curmode:=number;                                                    40289000
end of passparams;                                                      40290000
                                                                        40291000
                                                                        40292000
procedure factor;                                %*** factor ***        40293000
begin                                            %**************        40294000
    integer startsym,stype,t;                                           40295000
    boolean first;                                                      40296000
    real val;                                                           40297000
                                                                        40298000
    define parameter=        %*** check that the function has 1 param.  40299000
    begin                                                               40300000
        insymbol;                                                       40301000
        if cursy=lpar then                                              40302000
        begin                                                           40303000
          putsym("(");  insymbol;  expression;                          40304000
          if typetab1[curtype].form=numeric then curtype:=inttype;      40305000
          if cursy!rpar then begin error(3); skip(rpar) end;            40306000
          putsym(")");  if cursy=rpar then insymbol;                    40307000
        end else error(3);                                              40308000
    end of parameter#;                                                  40309000
                                                                        40310000
    curmode:=number;                                                    40311000
    if cursy=identifier then                                            40312000
    begin                                                               40313000
      search;                                                           40314000
      if found then                                                     40315000
      begin                                                             40316000
        if thisid.idclass=var or                                        40317000
           thisid.idclass=const and boolean(thisid.formal)              40318000
        then variable else                                              40319000
        if thisid.idclass=const then                                    40320000
        begin                                                           40321000
         if thisid.info{1023 then putconst(thisid.info)                 40322000
                             else putconst(consttab[thisid.info-1023]); 40323000
          curtype:=thisid.type; curmode:=number;                        40324000
          insymbol;                                                     40325000
        end else                                                        40326000
        if thisid.idclass=func then                                     40327000
        begin                                                           40328000
          if thistab=0 then            %*** intrinsic function ***      40329000
          begin                                                         40330000
            integer dummy;                                              40350000
            if curname1="3000abs" then            % "abs"               40351000
            begin                                                       40352000
              puttext("   abs"); parameter;                             40353000
              if curtype!realtype and curtype!inttype then error(67);   40354000
            end else                                                    40355000
            if curname1="3000chr" then            % "chr"               40356000
            begin                                                       40357000
              insymbol;                                                 40358000
              if cursy=lpar then                                        40359000
              begin insymbol;  checkexpr(0,63);                         40360000
                 if typetab1[curtype].form!numeric then error(67);      40361000
                 if cursy!rpar then begin error(46); skip(rpar) end;    40362000
                 if cursy=rpar then insymbol;                           40363000
           end else error(58);                                          40364000
           curtype:=chartype;                                           40365000
         end else                                                       40366000
         if curname1="3000eof" or                 % "eof"/"eoln"        40367000
            curname1="400eoln" then                                     40368000
         begin                                                          40369000
           first:=curname1="3000eof";                                   40370000
           fileparam(inputfile);                                        40371000
           putid("i",filename,5);                                       40372000
           puttext(if first then "  .eof" else " .eoln");               40373000
           if lparfound then                                            40374000
           begin                                                        40375000
             if cursy!rpar then begin error(46); skip(rpar) end;        40376000
             if cursy=rpar then insymbol;                               40377000
           end;                                                         40378000
           curtype:=booltype;                                           40379000
         end else                                                       40380000
         if curname1="3000odd" then              % "odd"                40381000
         begin                                                          40382000
           puttext("   odd");  parameter;                               40383000
           if curtype!inttype then error(67);                           40384000
           curtype:=booltype;  curmode:=bitpattern;                     40385000
         end else                                                       40386000
         if curname1="3000ord" then              % "ord"                40387000
         begin                                                          40388000
             putsym("("); insymbol;                                     40389000
             if cursy=lpar then                                         40390000
             begin                                                      40391000
               insymbol;  expression;                                   40392000
               if typetab1[curtype].form>char then error(67);           40393000
               if cursy!rpar then begin error(46); skip(rpar) end;      40394000
               insymbol;                                                40395000
             end else error(58);                                        40396000
             curtype:=inttype;  putsym(")");                            40397000
           end else                                                     40398000
           if curname1="400pred" or              % "pred"/"succ"        40399000
              curname1="400succ" then                                   40400000
           begin                                                        40401000
              first:=curname1="400pred";                                40402000
              puttext("check(");  insymbol;                             40403000
              if cursy=lpar then                                        40404000
              begin                                                     40405000
                insymbol;  expression;                                  40406000
                putsym(if first then "-" else "+");  putsym("1");       40407000
                if typetab1[curtype].form>char then error(67);          40408000
                putsym(",");  putconst(typetab2[curtype]);              40409000
                putsym(",");  putconst(typetab3[curtype]);              40410000
                putsym(",");  putconst(cardcnt);                        40411000
                putsym(")");                                            40412000
                if cursy!rpar then begin error(46); skip(rpar) end;     40413000
                if cursy=rpar then insymbol;                            40414000
              end else begin error(58); curtype:=0 end;                 40415000
            end else                                                    40416000
            if curname1="50round" then            % "round"             40417000
            begin                                                       40418000
              puttext(" round"); parameter;                             40419000
              if curtype!realtype then error(67);                       40420000
              numsyms:=numsyms-1;  putsym(",");                         40421000
              putconst(cardcnt);  putsym(")");                          40422000
              curtype:=inttype;                                         40423000
            end else                                                    40424000
            if curname1="3000sqr" then            % "sqr"               40425000
            begin                                                       40426000
              puttext("   sqr");  parameter;                            40427000
              numsyms:=numsyms-1; putsym(",");                          40428000
              putconst(cardcnt); putsym(")");                           40429000
              if curtype!realtype and curtype!inttype then error(67);   40430000
            end else                                                    40431000
            if curname1="50trunc" then            % "trunc"             40432000
            begin                                                       40433000
              puttext(" trunc");  parameter;                            40434000
              numsyms:=numsyms-1; putsym(",");                          40434000
              putconst(cardcnt); putsym(")");                           40436000
              if curtype!realtype then error(67);                       40437000
              curtype:=inttype;                                         40438000
            end else                                                    40439000
            if curname1="6concat" then            % "concat"            40440000
            concat else                                                 40441000
            if curname1="400time" then            % "time"              40442000
            begin                                                       40443000
              puttext("(time(");  puttext("1)/60");                     40444000
              curtype:=realtype;  insymbol                              40445000
            end else                                                    40446000
            if curname1="400date" then            % "date"              40447000
            begin                                                       40448000
              puttext("curdat");                                        40449000
              curtype:=alfatype;  insymbol;                             40450000
            end else                                                    40451000
            if curname1="7elapse" and curname2="d" then   % "elapsed"   40452000
            begin                                                       40453000
              puttext("(time(");  puttext("2)/60)");                    40454000
              curtype:=realtype;  insymbol;                             40455000
            end else                                                    40456000
            if curname1="6iotime" then            % "iotime"            40457000
            begin                                                       40458000
              puttext("(time(");  puttext("3)/60)");                    40459000
              curtype:=realtype;  insymbol;                             40460000
            end else                                                    40461000
            if curname1="7weekda" and curname2="y" then  % "weekday"    40462000
            begin                                                       40463000
              puttext("weekda");                                        40464000
              curtype:=alfatype;  insymbol;                             40465000
            end else if curname1="400user" then   % "user"              40466000
            begin                                                       40467000
              puttext("  time");  puttext("  (-1)");                    40468000
              curtype:=alfatype;  insymbol;                             40469000
            end else                              % "sin", "cos" etc.   40470000
            begin                                                       40471000
              puttext(if curname1="3000sin" then "   sin" else          40472000
                      if curname1="3000cos" then "   cos" else          40473000
                      if curname1="6arctan" then "arctan" else          40474000
                      if curname1="400sqrt" then "  sqrt" else          40475000
                      if curname1="3000exp" then "   exp" else          40476000
                        "    ln");                                      40477000
              parameter;                                                40478000
              if curtype!realtype and curtype!inttype then error(67);   40479000
              curtype:=realtype;                                        40480000
            end;                                                        40481000
         end of intrinsic functions else                                40482000
         begin                                                          40483000
           t:=thisid.type;                                              40484000
           passparams;                                                  40485000
           curtype:=t;                                                  40486000
         end;                                                           40487000
       end of functions  else                                           40488000
       if thisid.idclass=proc then                                      40489000
       begin                                                            40490000
         error(68);  passparams;                                        40491000
         curtype:=0;                                                    40492000
       end else begin error(69); curtype:=0; insymbol end;              40493000
     end else begin error(1); curtype:=0; insymbol end;                 40494000
   end of identifier else                                               40495000
   if cursy{charconst then                                              40496000
   begin                                                                40497000
     constant(val,curtype);  putconst(val);                             40498000
   end else                                                             40499000
   if cursy=notsy then                                                  40500000
   begin                                                                40501000
     puttext("  not ");  putdummy;  startsym:=numsyms;                  40502000
     insymbol;  factor;                                                 40503000
     if curtype>0 then                                                  40504000
     if curtype!booltype then begin error(17); curtype:=0 end;          40505000
     if curmode=number then                                             40506000
     begin symtab[startsym]:="     b(";  putsym(")");                   40507000
           curmode:=bitpattern;                                         40508000
     end;                                                               40509000
   end else                                                             40510000
   if cursy=nilsy then                                                  40511000
   begin                                                                40512000
     putconst(0);  curtype:=niltype;                                    40513000
     insymbol;                                                          40514000
   end else                                                             40515000
   if cursy=lpar then                                                   40516000
   begin                                                                40517000
     putsym("(");                                                       40518000
     insymbol; expression;                                              40519000
     if cursy!rpar then begin error(46); skip(rpar) end;                40520000
     putsym(")");                                                       40521000
     insymbol;                                                          40522000
   end else                                                             40523000
   if cursy=lbracket then            %*** set constant ***              40524000
   begin                                                                40525000
     insymbol;                                                          40526000
     if cursy=rbracket then                                             40527000
     begin                                                              40528000
       putconst(0);  curtype:=emptyset;  curmode:=number;               40529000
       insymbol;                                                        40530000
     end else                                                           40531000
     begin                                                              40532000
       first:=true;                                                     40533000
       do begin                                                         40534000
         if first then first:=false else insymbol;                      40535000
         puttext("   bit(");  startsym:=numsyms;                        40536000
         expression;                                                    40537000
         if stype=0 then                                                40538000
         begin stype:=curtype;                                          40539000
               if typetab1[curtype].form>char then error(72);           40540000
         end else checktypes(stype,curtype);                            40541000
         if cursy=doubledot then                                        40542000
         begin                                                          40543000
           putsym(",");  symtab[startsym]:=" bits(";                    40544000
           insymbol;  expression;                                       40545000
           if stype=0 then                                              40546000
           begin stype:=curtype;                                        40547000
                if typetab1[curtype].form>char then error(72);          40548000
           end else checktypes(stype,curtype);                          40549000
         end;                                                           40550000
         putsym(",");  putconst(cardcnt);  putsym(")");                 40551000
         if cursy=comma then puttext("     or");                        40552000
       end until cursy!comma;                                           40553000
       if cursy!rbracket then                                           40554000
       begin error(59);  skip(rbracket);                                40555000
             if cursy=rbracket then insymbol;                           40556000
       end else insymbol;                                               40557000
       newtype;  t1:=set;  t1.size:=1;  t1.struct:=0;                   40558000
       t1.settype:=stype;  typetab1[typeindex]:=t1;                     40559000
       curtype:=typeindex;                                              40560000
       curmode:=bitpattern;                                             40561000
     end;                                                               40562000
   end of set constant else begin error(99); insymbol end;              40563000
end of factor;                                                          40564000
                                                                        40565000
                                                                        40566000
procedure term;                         %*** term ***                   40567000
begin                                   %************                   40568000
    integer startsym,mode,type1,muloptr,f;                              40569000
    putdummy;  startsym:=numsyms;                                       40570000
    factor;                                                             40571000
    mode:=curmode;                                                      40572000
    while cursy}asterisk and cursy{modsy do  % "*","/","div","mod","and"40573000
    begin                                                               40574000
      type1:=curtype;  muloptr:=cursy;                                  40575000
      f:=typetab1[type1].form;                                          40576000
      if f=numeric or f=floating then                                   40577000
      begin                                                             40578000
        mode:=number;                                                   40579000
        if cursy=asterisk then putsym("|") else                         40580000
        if cursy=slash   then putsym("/") else                          40581000
        if cursy=andsy   then error(64)   else                          40582000
        begin                                                           40583000
          if f=floating then error(64);                                 40584000
          if cursy=divsy then puttext("   div") else puttext("   mod"); 40585000
      end end else                                                      40586000
      if curtype=booltype or f=set then                                 40587000
      begin                                                             40588000
        mode:=bitpattern;                                               40589000
        if curmode!mode then                                            40590000
        begin symtab[startsym]:="    b("; putsym(")") end;              40591000
        puttext("  and ");                                              40592000
        if cursy!(if f=set then asterisk else andsy) then error(64);    40593000
      end else error(64);                                               40594000
      putdummy;  startsym:=numsyms;                                     40595000
      insymbol;  factor;                                                40596000
      if curtype>0 and type1>0 then                                     40597000
      begin                                                             40598000
        if curtype!type1 then                                           40599000
        begin                                                           40600000
          if typetab1[type1].form!numeric or curtype!realtype then      40601000
          checktypes(type1,curtype);                                    40602000
          if type1=realtype then curtype:=realtype;                     40603000
        end;                                                            40604000
        if curtype=realtype and muloptr}divsy then error(65);           40605000
      end;                                                              40606000
      if muloptr=slash then curtype:=realtype;                          40607000
      if curtype=0 then curtype:=type1;                                 40608000
    end of while loop;                                                  40609000
    if mode=bitpattern and curmode!mode then                            40610000
    begin symtab[startsym]:="    b("; putsym(")") end;                  40611000
    curmode:=mode;                                                      40612000
end of term;                                                            40613000
                                                                        40614000
                                                                        40615000
procedure simpleexpression;         %*** simple expression ***          40616000
begin                               %*************************          40617000
    integer startsym,mode,type1,f;                                      40618000
    boolean signed;                                                     40619000
                                                                        40620000
    putdummy;  startsym:=numsyms;                                       40621000
    if cursy=plus or cursy=minus then                                   40622000
    begin signed:=true;                                                 40623000
          putsym(if cursy=plus then"+" else "-");                       40624000
          insymbol;                                                     40625000
    end;                                                                40626000
    term;                                                               40627000
    mode:=curmode;                                                      40628000
    if signed then                                                      40629000
    begin f:=typetab1[curtype].form;                                    40630000
          if f!numeric and f!floating then error(29);                   40631000
    end;                                                                40632000
    while cursy}plus and cursy{orsy do      % "+","-","or"              40633000
    begin                                                               40634000
      type1:=curtype;  f:=typetab1[type1].form;                         40635000
      if f=numeric or f=floating then                                   40636000
      begin mode:=number;                                               40637000
            if cursy=plus then putsym("+") else                         40638000
            if cursy=minus then putsym("-") else error(64);             40639000
      end else                                                          40640000
      if curtype=booltype then                                          40641000
      begin                                                             40642000
        mode:=bitpattern;                                               40643000
        if curmode!mode then                                            40644000
        begin symtab[startsym]:="    b("; putsym(")") end;              40645000
        if cursy=orsy then puttext("    or") else error(64);            40646000
      end else                                                          40647000
      if f=set then                                                     40648000
      begin                                                             40649000
        mode:=bitpattern;                                               40650000
        if curmode!mode then                                            40651000
        begin symtab[startsym]:="    b("; putsym(")"); end;             40652000
        if cursy=plus then puttext("    or") else                       40653000
        if cursy=minus then begin puttext("   and");puttext("  not ")end40654000
        else error(64);                                                 40655000
      end else error(64);                                               40656000
      insymbol;                                                         40657000
      putdummy;  startsym:=numsyms;                                     40658000
      term;                                                             40659000
      if curtype>0 and type1>0 then                                     40660000
      begin                                                             40661000
        if curtype!type1 then                                           40662000
        begin                                                           40663000
          if typetab1[type1].form!numeric or curtype!realtype then      40664000
          checktypes(type1,curtype);                                    40665000
          if type1=realtype then curtype:=realtype;                     40666000
      end end;                                                          40667000
      if curtype=0 then curtype:=type1;                                 40668000
    end of while loop;                                                  40669000
    if mode=bitpattern and curmode!bitpattern then                      40670000
    begin symtab[startsym]:="    b("; putsym(")") end;                  40671000
    curmode:=mode;                                                      40672000
end of simpleexpression;                                                40673000
                                                                        40674000
                                                                        40675000
procedure expression;                 %*** expression ***               40676000
begin                                 %******************               40677000
    integer startsym,firstsym,type1,reloptr,f;                          40678000
    boolean callgen;                                                    40679000
                                                                        40680000
    exprlevel:=exprlevel+1;                                             40681000
    if exprlevel = 1 then                                               40682000
    begin                                                               40683000
      putdummy;                                                         40684000
      firstsym := numsyms;                                              40685000
    end;                                                                40686000
    putdummy;  startsym:=numsyms;                                       40687000
    putdummy;                                                           40688000
    simpleexpression;                                                   40689000
    if cursy}lsssy and cursy{insy then   % "<","{","}",">","=","!","in" 40690000
    begin                                                               40691000
      type1:=curtype;  f:=typetab1[type1].form;                         40692000
      reloptr:=cursy;                                                   40693000
      if f{alfa then                                                    40694000
      begin                                                             40695000
        if curmode=bitpattern then                                      40696000
        begin symtab[startsym]:=" real("; putsym(")") end;              40697000
        if cursy=lsssy then putsym("<") else                            40698000
        if cursy=leqsy then putsym("{") else                            40699000
        if cursy=geqsy then putsym("}") else                            40600000
        if cursy=gtrsy then putsym(">") else                            40601000
        if cursy=eqlsy then putsym("=") else                            40602000
        if cursy=neqsy then putsym("!") else                            40703000
        begin                                                           40704000
          if f}floating then error(64);                                 40705000
          symtab[startsym]:="intst(";  putsym(",");  callgen:=true;     40706000
        end;                                                            40707000
      end else                                                          40708000
      if f=set then                                                     40709000
      begin                                                             40710000
        if curmode=bitpattern then                                      40711000
        begin symtab[startsym+1]:=" real("; putsym(")") end;            40712000
        if cursy=eqlsy or cursy=neqsy then                              40713000
        begin putsym(if cursy=eqlsy then "=" else "!");                 40714000
        end else                                                        40715000
        begin                                                           40716000
          if cursy=leqsy then symtab[startsym]:="incl1(" else           40717000
          if cursy=geqsy then symtab[startsym]:="incl2(" else error(64);40718000
          putsym(",");  callgen:=true;                                  40719000
      end end else                                                      40720000
      if f=pointers then                                                40721000
      begin                                                             40722000
        if cursy=eqlsy then putsym("=") else                            40723000
        if cursy=neqsy then putsym("!") else error(64);                 40724000
      end else error(64);                                               40725000
      insymbol;                                                         40726000
      putdummy;  startsym:=numsyms;                                     40727000
      simpleexpression;                                                 40728000
      if curtype>0 and type1>0 then                                     40729000
        if curtype!type1 then                                           40730000
          if reloptr!insy then                                          40731000
          begin                                                         40732000
            if typetab1[type1].form!numeric or curtype!realtype then    40733000
            checktypes(type1,curtype);                                  40734000
          end else                                                      40735000
          if typetab1[curtype].form!set then error(66)                  40736000
                    else checktypes(type1,typetab1[curtype].settype);   40737000
       if curmode=bitpattern then                                       40738000
       begin symtab[startsym]:=" real("; putsym(")") end;               40739000
       if callgen then putsym(")");                                     40740000
       curtype:=booltype;  curmode:=bitpattern;                         40741000
     end;                                                               40742000
     exprlevel:=exprlevel-1;                                            40743000
     if exprlevel=0 then                                                40744000
     begin                                                              40745000
       if curmode=bitpattern then                                       40746000
       begin                                                            40747000
         symtab[firstsym] := " real(";                                  40748000
         putsym(")");                                                   40749000
       end;                                                             40750000
       writeexpr;                                                       40751000
     end;                                                               40752000
end of expression;                                                      40753000
                                                                        40754000
                                                                        40755000
define boolexpr=                                                        40756000
begin                                                                   40757000
    putdummy;  exprlevel:=1;  expression;                               40758000
    if curtype>0 then if curtype!booltype then error(17);               40759000
    if curmode!bitpattern then                                          40760000
    begin symtab[1]:="    b(";  putsym(")") end;                        40761000
    exprlevel:=0;  writeexpr;                                           40762000
end of boolean#;                                                        40763000
$ page                                                                  40764000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%50001000
%                                                                      %50002000
%                                                                      %50003000
%                                                                      %50004000
%                  part 5:  intrinsic routines.                        %50005000
%                           -------------------                        %50006000
%                                                                      %50007000
%                                                                      %50008000
%                                                                      %50009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%50010000
                                                                        50011000
                                                                        50012000
procedure concat;                       %*** "concat" ***               50013000
begin                                   %****************               50014000
    define intexpr=                                                     50015000
    begin insymbol; expression;                                         50016000
          if curtype>0 then                                             50017000
          if typetab1[curtype].form!numeric then error(17);             50018000
    end #;                                                              50019000
                                                                        50020000
    puttext("concat");  putsym("(");                                    50021000
    insymbol;                                                           50022000
    if cursy=lpar then                                                  50023000
    begin                                                               50024000
      insymbol;  expression;                                            50025000
      if curtype>0 then                                                 50026000
      if typetab1[curtype].form>alfa then error(17);                    50027000
      if cursy=comma then                                               50028000
      begin                                                             50029000
        putsym(",");  insymbol;  expression;                            50030000
        if curtype>0 then                                               50031000
        if typetab1[curtype].form>alfa then error(17);                  50032000
        if cursy=comma then                                             50033000
        begin                                                           50034000
          putsym(",");  intexpr;                                        50035000
          if cursy=comma then                                           50036000
          begin                                                         50037000
            putsym(",");  intexpr;                                      50038000
            if cursy=comma then                                         50039000
            begin                                                       50040000
              putsym(",");  intexpr;                                    50041000
              putsym(",");  putconst(cardcnt);                          50042000
              putsym(")");                                              50043000
              if cursy!rpar then begin error(3); skip(rpar) end;        50044000
            end else begin error(3); skip(rpar) end;                    50045000
          end else begin error(3); skip(rpar) end;                      50046000
        end else begin error(3); skip(rpar) end;                        50047000
      end else begin error(3); skip(rpar) end;                          50048000
    end else begin error(3); skip(rpar) end;                            50049000
    curtype:=realtype;                                                  50050000
    if cursy=rpar then insymbol;                                        50051000
end of concat;                                                          50052000
                                                                        50053000
                                                                        50054000
procedure pread(changeline);                                            50055000
value changeline; boolean changeline;                                   50056000
begin                                                                   50057000
    integer fileid,f;                                                   50058000
    boolean check;                                                      50059000
    gen(" begin",7,2);                                                  50060000
    fileparam(inputfile);  fileid:=filename;                            50061000
    if typetab1[curtype].form=files then error(85);                     50062000
    if symkind[cursy]!terminal then                                     50063000
    begin                                                               50064000
      if cursy neq rpar then                                            50065000
      do begin                                                          50066000
        while cursy=comma do insymbol;                                  50067000
        if cursy=identifier then                                        50068000
        begin                                                           50069000
          search;                                                       50070000
          if found then                                                 50071000
          begin                                                         50072000
            if thisid.idclass=var or                                    50073000
               thisid.idclass=const and boolean(thisid.formal) then     50074000
            begin                                                       50075000
             variable;  f:=typetab1[curtype].form;                      50076000
             if f=numeric or f=floating or f=char then                  50077000
             begin                                                      50078000
               check:=checkoption and f!floating;                       50079000
               writeexpr;  gen(":=",2,6);                               50080000
               if check then gen("check(",6,2);                         50081000
               gen("pread(",6,2);  genid("f",fileid,5);  gen(",",1,7);  50082000
               genid("v",fileid,5); gen(",",1,7);                       50083000
               genid("i",fileid,5); gen(",",1,7);                       50084000
               if f=numeric  then genint(2) else                        50085000
               if f=floating then genint(3) else genint(1);             50086000
               gen(",",1,7);  genint(cardcnt);  gen(")",1,7);           50087000
               if check then                                            50088000
               begin                                                    50089000
                 gen(",",1,7);  genint(typetab2[curtype]); gen(",",1,7);50090000
                 genint(typetab3[curtype]);  gen(",",1,7);              50091000
                 genint(cardcnt);  gen(")",1,7);                        50092000
               end;                                                     50093000
             end else begin error(82); insymbol end;                    50094000
            end else begin error(8); insymbol end;                      50095000
           end else begin error(1); insymbol end;                       50096000
         end else error(9);                                             50097000
         gen(";",1,7);                                                  50098000
       end until cursy!comma;                                           50099000
       if cursy!rpar then begin error(46); skip(rpar) end;              50100000
       if cursy=rpar then insymbol;                                     50101000
     end;                                                               50102000
     if changeline then                                                 50103000
     begin                                                              50104000
       gen("rline(",6,2);  genid("f",fileid,5);  gen(",",1,7);          50105000
       genid("v",fileid,5);  gen(",",1,7);                              50106000
       genid("i",fileid,5);  gen(")",1,7);                              50107000
     end;                                                               50108000
     gen("end",4,5);                                                    50109000
 end of pread;                                                          50110000
                                                                        50111000
                                                                        50112000
procedure pwrite(linefeed);                                             50113000
value linefeed; boolean linefeed;                                       50114000
begin                                                                   50115000
    integer fileid,f,i,lastsy;                                          50116000
    pointer p;                                                          50117000
    gen(" begin",7,2);                                                  50118000
    fileparam(outputfile);  fileid:=filename;                           50119000
    if typetab1[curtype].form=files then error(85);                     50120000
    if symkind[cursy]!terminal then                                     50121000
    begin                                                               50122000
      if cursy neq rpar then                                            50123000
      do begin                                                          50124000
        while cursy=comma do insymbol;                                  50125000
        if cursy=alfaconst and curlength>7 then                         50126000
        begin                                                           50127000
          gen("walfa(",6,2);  genid("f",fileid,5);  gen(",",1,7);       50128000
          genid("v",fileid,6);  gen(",",1,7);                           50129000
          genid("i",fileid,5);  gen(",",1,7);                           50130000
          p:=stringpnt;                                                 50131000
          for i:=1 step 7 until 80 do                                   50132000
          if i{curlength then                                           50133000
          begin                                                         50134000
            if algolcnt<10 then writealgol;                             50135000
            replace algolpnt:algolpnt by """, p:p for 7, """, ",";      50136000
            algolcnt:=algolcnt-10;                                      50137000
          end else gen("0,",2,6);                                       50138000
          genint(curlength);  gen(",",1,7);                             50139000
          genint(cardcnt);  gen(")",1,7);                               50140000
          insymbol;                                                     50141000
        end of alfaconst else                                           50142000
        begin                                                           50143000
          gen("pwrite(",7,1);  genid("f",fileid,5);  gen(",",1,7);      50144000
          genid("v",fileid,5);  gen(",",1,7);                           50145000
          genid("i",fileid,5);  gen(",",1,7);                           50146000
          lastsy:=cursy;                                                50147000
          expression;  f:=typetab1[curtype].form;                       50148000
          gen(",",1,7);                                                 50149000
          if f=numeric or f=floating or f=char or f=alfa or             50150000
             curtype=booltype then                                      50151000
          begin                                                         50152000
            if f=numeric  then genint(1) else                           50153000
            if f=floating then genint(2) else                           50154000
            if f=alfa     then genint(5) else                           50155000
            if f=char     then genint(4) else genint(3);                50156000
            gen(",",1,7);                                               50157000
            if cursy=colon then                                         50158000
            begin                                                       50159000
              insymbol;  expression;                                    50160000
              if typetab1[curtype].form neq numeric then error(17);     50161000
              gen(",",1,7);                                             50162000
              if cursy=colon then                                       50163000
              begin                                                     50164000
                if f!floating then error(4);                            50165000
                insymbol;  expression;                                  50166000
                if typetab1[curtype].form neq numeric then error(17);   50167000
                gen(",",1,7);                                           50168000
              end else gen("-1,",3,5);                                  50169000
            end else                                                    50170000
            begin                                                       50171000
              if f=floating then genint(16) else                        50172000
              if f=alfa and lastsy=alfaconst then genint(curlength) else50173000
              if f=alfa     then genint(7)  else                        50174000
              if f=char     then genint(1) else  genint(10);            50175000
              gen(",-1",4,4);                                           50176000
            end;                                                        50177000
          end else error(17);                                           50178000
          genint(cardcnt);  gen(")",1,7);                               50179000
        end of expression;                                              50180000
        gen(";",1,7);                                                   50181000
      end until cursy!comma;                                            50182000
      if cursy!rpar then begin error(46); skip(rpar) end;               50183000
      if cursy=rpar then insymbol;                                      50184000
    end;                                                                50185000
    filename:=fileid;                                                   50186000
    if linefeed then                                                    50187000
    begin                                                               50188000
      integer dummy;                                                    50189000
      gen("wline(",6,2);  genid("f",filename,5);  gen(",",1,7);         50190000
      genid("v",filename,5);  gen(",",1,7);                             50191000
      genid("i",filename,5);  gen(")",1,7);                             50192000
    end;                                                                50193000
    gen("end",4,5);                                                     50194000
end of pwrite;                                                          50195000
                                                                        50196000
                                                                        50197000
procedure filehandling(procnum);        %*** file handling procedures:  50198000
value procnum; integer procnum;         %***                            50199000
begin                                   %***   1) put                   50200000
    integer f;                          %***   2) get                   50201000
    case procnum of                     %***   3) reset                 50202000
    begin ;                             %***  4) rewrite                50203000
      gen("put",3,5);                   %***  5) page                   50204000
      gen("get",3,5);                                                   50205000
      gen("reset",5,3);                                                 50206000
      gen("rewrite",7,1);                                               50207000
      gen("page",4,4);                                                  50208000
    end;                                                                50209000
    gen("(",1,7);   fileparam(0);                                       50210000
    if filename=0 then error(78);                                       50211000
    f:=typetab1[curtype].form;                                          50212000
    if f=files and procnum=5 then error(80);                            50213000
    genid("f",filename,5);  gen(",",1,7);                               50214000
    genid("v",filename,5);  gen(",",1,7);                               50215000
    genid("i",filename,5);  gen(",",1,7);                               50216000
    genint(cardcnt);  gen(")",1,7);                                     50217000
    if cursy!rpar then begin error(46); skip(rpar) end;                 50218000
    if cursy=rpar then insymbol;                                        50219000
end of filehandling;                                                    50220000
                                                                        50221000
                                                                        50222000
procedure pack;                                                         50223000
begin                                                                   50224000
    integer it,t;                                                       50225000
    gen("pack(",5,3);                                                   50226000
    insymbol;                                                           50227000
    if cursy=lpar then                                                  50228000
    begin                                                               50229000
      insymbol;                                                         50230000
      if cursy=identifier then                                          50231000
      begin                                                             50232000
        search;                                                         50233000
        if found then                                                   50234000
        begin                                                           50235000
          if thisid.idclass=var then                                    50236000
          begin                                                         50237000
            t:=typetab1[thisid.type];                                   50238000
            if t.form=arrays then                                       50239000
            begin                                                       50240000
              it:=t.inxtype;                                            50241000
              if typetab1[t.arrtype].form!char then error(88);          50242000
              genid("v",1000|thislevel+thisindex,5);                    50243000
              if thislevel>1 and thislevel!curlevel then error(5);      50244000
              gen(",",1,7);  genint(typetab2[thisid.type]);             50245000
              gen(",",1,7);  genint(typetab3[thisid.type]);             50246000
            end else error(88);                                         50247000
          end else error(88);                                           50248000
        end else error(1);                                              50249000
      end else error(9);                                                50250000
      insymbol;                                                         50251000
      if cursy=comma then                                               50252000
      begin                                                             50253000
        gen(",",1,7);                                                   50254000
        insymbol;  expression;  checktypes(it,curtype);                 50255000
        if cursy=comma then                                             50256000
        begin                                                           50257000
          gen(",",1,7);                                                 50258000
          insymbol;                                                     50259000
          if cursy=identifier then                                      50260000
          begin                                                         50261000
            search;                                                     50262000
            if found then                                               50263000
            begin                                                       50264000
              if thisid.idclass=var or                                  50265000
                 thisid.idclass=const and boolean(thisid.formal) then   50266000
              begin                                                     50267000
                variable;  writeexpr;                                   50268000
                if curtype>0 then                                       50269000
                if typetab1[curtype].form!alfa then error(12);          50270000
              end else error(8);                                        50271000
            end else error(1);                                          50272000
          end else error(9);                                            50273000
        end else begin error(89); skip(rpar) end;                       50274000
      end else begin error(89); skip(rpar) end;                         50275000
      if cursy!rpar then begin error(46); skip(rpar) end;               50276000
      if cursy=rpar then insymbol;                                      50277000
    end else begin error(3); insymbol end;                              50278000
    gen(",",1,7);  genint(cardcnt); gen(")",1,7);                       50279000
end of pack;                                                            50280000
                                                                        50281000
                                                                        50282000
procedure unpack;                                                       50283000
begin                                                                   50284000
    integer it,t;                                                       50285000
    gen("unpack(",7,1);  insymbol;                                      50286000
    if cursy=lpar then                                                  50287000
    begin                                                               50288000
      insymbol;  expression;                                            50289000
      if curtype>0 then if typetab1[curtype].form!alfa then error(17);  50290000
      if cursy=comma then                                               50291000
      begin                                                             50292000
        gen(",",1,7);  insymbol;                                        50293000
        if cursy=identifier then                                        50294000
        begin                                                           50295000
          search;                                                       50296000
          if found then                                                 50297000
          begin                                                         50298000
            if thisid.idclass=var then                                  50299000
            begin                                                       50300000
              t:=typetab1[thisid.type];                                 50301000
              if t.form=arrays then                                     50302000
              begin                                                     50303000
                it:=t.inxtype;                                          50304000
                if typetab1[t.arrtype].form!char then error(88);        50305000
                if thislevel>1 and thislevel!curlevel then error(5);    50306000
                genid("v",1000|thislevel+thisindex,5);                  50307000
                gen(",",1,7); genint(typetab2[thisid.type]);            50308000
                gen(",",1,7); genint(typetab3[thisid.type]);            50309000
              end else error(88);                                       50310000
            end else error(88);                                         50311000
          end else error(1);                                            50312000
        end else error(9);                                              50313000
        insymbol;                                                       50314000
        if cursy=comma then                                             50315000
        begin                                                           50316000
          gen(",",1,7);                                                 50317000
          insymbol;  expression;  checktypes(it,curtype);               50318000
        end else begin error(89); skip(rpar) end;                       50319000
      end else begin error(89); skip(rpar) end;                         50320000
      if cursy!rpar then begin error(89); skip(rpar) end;               50321000
      if cursy=rpar then insymbol;                                      50322000
    end else begin error(3); insymbol end;                              50323000
    gen(",",1,7);  genint(cardcnt);  gen(")",1,7);                      50324000
end of unpack;                                                          50325000
                                                                        50326000
                                                                        50327000
procedure newdisp;                 %*** "new","dispose"                 50328000
begin                                                                   50329000
    integer t1;                                                         50330000
    if curname1="3000new" then gen("new(",4,4) else                     50331000
    begin gen("dispose",7,1); gen("(",1,7) end;                         50332000
    insymbol;                                                           50333000
    if cursy=lpar then                                                  50334000
    begin                                                               50335000
      insymbol;                                                         50336000
      if cursy=identifier then                                          50337000
      begin                                                             50338000
        search;                                                         50339000
        if found then                                                   50340000
        begin                                                           50341000
          variable;                                                     50342000
          if curtype>0 then if typetab1[curtype].form=pointers then     50343000
          begin                                                         50344000
            writeexpr;  gen(",",1,7);                                   50345000
            t1:=typetab1[curtype].pointtype;                            50346000
            t1:=typetab1[t1].size;                                      50347000
            if t1>1023 then error(86);                                  50348000
            genint(t1);  gen(")",1,7);                                  50349000
          end else error(81);                                           50350000
        end else begin error(1); insymbol end;                          50351000
      end else error(9);                                                50352000
      while cursy=comma do                                              50353000
      begin insymbol;                                                   50354000
            if cursy neq identifier then error(9);                      50355000
            if cursy neq rpar then insymbol;                            50356000
      end;                                                              50357000
    end else begin error(58); skip(rpar) end;                           50358000
    if cursy!rpar then begin error(46); skip(rpar) end;                 50359000
    if cursy=rpar then insymbol;                                        50360000
end of newdisp;                                                         50361000
$ page                                                                  50362000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%60001000
%                                                                      %60002000
%                                                                      %60003000
%                                                                      %60004000
%                  part 6:  the statement parser.                      %60005000
%                           ---------------------                      %60006000
%                                                                      %60007000
%                                                                      %60008000
%                                                                      %60009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%60010000
                                                                        60011000
                                                                        60012000
                                                                        60013000
procedure statement;    forward;                                        60014000
                                                                        60015000
procedure assignment;                                                   60016000
begin                                                                   60017000
    integer lefttype;                                                   60018000
    label assign,exit;                                                  60019000
    if found then                                                       60050000
    begin                                                               60051000
      if thisid.idclass=var or                                          60052000
         thisid.idclass=const and boolean(thisid.formal) then           60053000
      begin                                                             60054000
        variable;  lefttype:=curtype;                                   60055000
assign: if cursy!assignsy then                                          60056000
        begin error(28);  skip(assignsy);                               60057000
              if symkind[cursy]=terminal then go to exit;               60058000
        end;                                                            60059000
        insymbol;                                                       60060000
        if typetab1[lefttype].struct>0 then                             60061000
        begin                                                           60062000
          error(95);                                                    60063000
        end else                                                        60080000
        begin                                                           60081000
          writeexpr;  gen(":=",2,6);                                    60082000
          if checkoption and typetab1[lefttype].form{char then          60083000
          checkexpr(typetab2[lefttype],typetab3[lefttype]) else         60084000
          expression;                                                   60085000
          writeexpr;                                                    60086000
          checktypes(lefttype,curtype);                                 60087000
        end;                                                            60088000
      end else                                                          60089000
      begin  % function assignment.                                     60090000
        if thislevel!curlevel-1 or thisindex!curfunc then error(5);     60091000
        genid("v",1000|thislevel+thisindex,5);  lefttype:=thisid.type;  60092000
        insymbol;  go to assign;                                        60093000
      end;                                                              60094000
    end else                                                            60095000
    begin                                                               60096000
      skip(assignsy);                                                   60097000
      if cursy=assignsy then go to assign;                              60098000
    end;                                                                60099000
exit:                                                                   60100000
end of assignment;                                                      60101000
                                                                        60102000
                                                                        60103000
procedure compstat;                                                     60104000
begin                                                                   60105000
    integer beginnum;                                                   60106000
    label statm;                                                        60107000
                                                                        60108000
    beginnum:=numbegins:=numbegins+1;  margin(" b",beginnum);           60109000
    gen("begin",6,3);                                                   60110000
    do begin                                                            60111000
        if cursy=semicolon or cursy=beginsy then insymbol;              60112000
statm:  statement;                                                      60113000
        gen(";",1,7);                                                   60114000
        if cursy=elsesy then begin error(20); insymbol; go statm end;   60115000
        if symkind[cursy]=initial then begin error(21); go statm end;   60116000
    end until cursy!semicolon;                                          60117000
    if cursy!endsy then                                                 60118000
    begin error(24);  skip(endsy);                                      60119000
          if cursy!endsy then begin insymbol; go to statm end;          60120000
    end;                                                                60121000
    gen(" end",5,4);  margin(" e",beginnum);                            60122000
    insymbol;                                                           60123000
end of compstat;                                                        60124000
                                                                        60125000
                                                                        60126000
procedure ifstat;                                                       60127000
begin                                                                   60128000
    label exit;                                                         60129000
    gen("if",3,6);                                                      60130000
    insymbol; boolexpr;                                                 60131000
    if cursy!thensy then                                                60132000
    begin if curtype>0 then error(27);                                  60133000
          skip(thensy);                                                 60134000
          if cursy!thensy then                                          60135000
          begin if curtype=0 then error(27);                            60136000
                if symkind[cursy]=terminal then go to exit;             60137000
          end;  end;                                                    60138000
          gen(" then",6,3);                                             60139000
          insymbol;  statement;                                         60140000
          if cursy=elsesy then                                          60141000
          begin gen(" else",6,3); insymbol; statement end;              60142000
exit:                                                                   60143000
end of ifstat;                                                          60144000
                                                                        60145000
                                                                        60146000
procedure casestat;                                                     60147000
begin                                                                   60148000
    define casehash(n)=(n).[38:39] mod maxcases#;                       60149000
    integer array casetab[0:maxcases];                                  60150000
    integer casenum,casetype,ncaselabs,tempvarnum,conval,contype,c,t;   60151000
    boolean zerolab,first;                                              60152000
                                                                        60153000
    casenum:=numcases:=numcases+1;  margin("cb",casenum);               60154000
    tempvarnum:=numtemps:=numtemps+1;                                   60155000
    if tempvarnum>maxtemps then error(16);                              60156000
    gen("begin",6,3);   genid("t",tempvarnum,2);  gen(":=",2,6);        60157000
    insymbol;  expression;                                              60158000
    gen(";",1,7);  casetype:=curtype;                                   60159000
    if typetab1[casetype].form}floating then                            60160000
    begin error(17); casetype:=0 end;                                   60161000
    if cursy!ofsy then                                                  60162000
    begin if casetype>0 then error(18);                                 60163000
          skip(ofsy);                                                   60164000
          if cursy=ofsy then insymbol else                              60165000
          if casetype=0 then error(18);                                 60166000
    end else insymbol;                                                  60167000
    do begin                                                            60168000
      while cursy=semicolon do insymbol;                                60169000
      first:=true;                                                      60170000
      if cursy!endsy then                                               60171000
      begin                                                             60172000
        gen("if",3,6);                                                  60173000
        do begin                                                        60174000
        if first then first:=false else insymbol;                       60175000
          constant(conval,contype);                                     60176000
          if contype>0 then                                             60177000
          begin                                                         60178000
            if casetype=0 then casetype:=contype else                   60179000
            checktypes(casetype,contype);                               60180000
            genid("t",tempvarnum,2); gen("=",1,7); genint(conval);      60181000
            ncaselabs:=ncaselabs+1;                                     60182000
            if ncaselabs<maxcases then                                  60183000
            begin                                                       60184000
              if conval=0 then                                          60185000
                if zerolab then error(31) else zerolab:=true  else      60186000
              begin                                                     60187000
                t:=casehash(conval);                                    60188000
                for c:=casetab[t] while c!conval and c!0 do             60189000
                t:=if t=0 then maxcases else t-1;                       60190000
                if c!0 then error(31) else casetab[t]:=conval;          60191000
              end;                                                      60192000
            end else if ncaselabs=maxcases then error(30);              60193000
            if cursy=comma then gen(" or",4,5);                         60194000
          end;                                                          60195000
        end until cursy!comma;                                          60196000
        gen(" then",6,3);                                               60197000
        if cursy!colon then begin error(26); skip(colon) end;           60198000
        if cursy=colon then insymbol;                                   60199000
        statement;                                                      60200000
        if cursy!semicolon and cursy!endsy then                         60201000
        begin error(21); skip(semicolon) end;                           60202000
      end;                                                              60203000
      if cursy=semicolon then gen(" else",6,3);                         60204000
    end until cursy!semicolon;                                          60205000
    if cursy!endsy then begin error(24); skip(endsy) end;               60206000
    gen(" end",5,4);  margin("ce",casenum);                             60207000
    numtemps:=numtemps-1;                                               60208000
    insymbol;                                                           60209000
end of casestat;                                                        60210000
                                                                        60211000
                                                                        60212000
procedure whilestat;                                                    60213000
begin                                                                   60214000
    label statm,exit;                                                   60215000
    gen("while",6,3);                                                   60216000
    insymbol;  boolexpr;                                                60217000
    if cursy!dosy then                                                  60218000
    begin if curtype>0 then error(19);                                  60219000
          skip(dosy);                                                   60220000
          if cursy!dosy then                                            60221000
          begin if curtype=0 then error(19);                            60222000
                go to if symkind[cursy]=initial then statm else exit;   60223000
    end;  end;                                                          60224000
    gen(" do",4,5);                                                     60225000
    insymbol;                                                           60226000
statm: statement;                                                       60227000
exit:                                                                   60228000
end of whilestat;                                                       60229000
                                                                        60230000
                                                                        60231000
procedure repeatstat;                                                   60232000
begin                                                                   60233000
    integer repnum;                                                     60234000
    label newtry;                                                       60235000
                                                                        60236000
    repnum:=numreps:=numreps+1;                                         60237000
    margin(" r",repnum);                                                60238000
    gen("do",3,6);  gen("begin",6,3);                                   60239000
    do begin                                                            60240000
        insymbol;                                                       60241000
newtry: statement;                                                      60242000
        gen(";",1,7);                                                   60243000
        if cursy=elsesy then begin error(20);insymbol; go newtry end;   60244000
        if symkind[cursy]=initial then begin error(21); go newtry end;  60245000
    end until cursy!semicolon;                                          60246000
    if cursy!untilsy then                                               60247000
    begin                                                               60248000
      error(22);                                                        60249000
      while cursy!untilsy and symkind[cursy]!initial do                 60250000
      begin insymbol; skip(untilsy) end;                                60251000
      if cursy!untilsy then go to newtry;                               60252000
    end;                                                                60253000
    gen(" end",5,4);  gen("until",6,3);  margin(" u",repnum);           60254000
    insymbol; boolexpr;                                                 60255000
end of repeatstat;                                                      60256000
                                                                        60257000
                                                                        60258000
procedure forstat;                                                      60259000
begin                                                                   60260000
    integer vartype,varnum,llim,ulim;                                   60261000
    boolean down;                                                       60262000
    label statm;                                                        60263000
                                                                        60264000
    gen("begin",6,3);                                                   60265000
    insymbol;                                                           60266000
    if cursy=identifier then                                            60267000
    begin                                                               60268000
      search;                                                           60269000
      if found then                                                     60270000
      begin                                                             60271000
        varnum:=1000|thislevel+thisindex;                               60272000
        if thisid.idclass=var or                                        60273000
           thisid.idclass=const and boolean(thisid.formal) then         60274000
        begin                                                           60275000
          if thislevel>1 and thislevel<curlevel then error(5);          60276000
          if thislevel>curlevel then error(83);                         60277000
          vartype:=thisid.type;                                         60278000
          if typetab1[vartype].form{char then                           60279000
          begin                                                         60280000
            llim:=typetab2[vartype];  ulim:=typetab3[vartype];          60281000
          end else begin error(12); vartype:=0 end;                     60282000
        end else error(8);                                              60283000
      end else error(1);                                                60284000
    end else error(9);                                                  60285000
    insymbol;                                                           60286000
    if cursy!assignsy then                                              60287000
    begin error(28);                                                    60288000
          skip(assignsy);                                               60289000
          if cursy=assignsy then insymbol else                          60290000
          if symkind[cursy]=initial then go to statm;                   60291000
    end else insymbol;                                                  60292000
    genid("v",varnum,5);  gen("~",1,7);                                 60293000
    if checkoption then checkexpr(llim,ulim) else expression;           60294000
    writeexpr;                                                          60295000
    gen(";",1,7);                                                       60296000
    if vartype=0 then vartype:=curtype else checktypes(vartype,curtype);60297000
    numtemps:=numtemps+1;  if numtemps>maxtemps then error(16);         60298000
    if cursy=tosy then insymbol else                                    60299000
    if cursy=downtosy then begin down:=true; insymbol end else          60300000
    begin if curtype>0 then error(23);                                  60301000
          skip(tosy);                                                   60302000
          if cursy=tosy then insymbol else                              60303000
          begin if curtype=0 then error(23);                            60304000
                if symkind[cursy]=initial then go to statm;             60305000
    end;  end;                                                          60306000
    genid("t",numtemps,2);  gen("~",1,7);                               60307000
    if checkoption then checkexpr(llim,ulim) else expression;           60308000
    writeexpr;                                                          60309000
    gen(";",1,7);                                                       60310000
    if vartype=0 then vartype:=curtype else checktypes(vartype,curtype);60311000
    if cursy!dosy then                                                  60312000
    begin if curtype>0 then error(19);                                  60313000
          skip(dosy);                                                   60314000
          if cursy=dosy then insymbol else                              60315000
          if curtype=0 then error(19);                                  60316000
    end else insymbol;                                                  60317000
    gen("for",4,5);  genid("v",varnum,5);  gen("~",1,7);                60318000
    genid("v",varnum,5);  gen(" ",1,7);                                 60319000
    if down then gen("downto",7,2) else gen("upto",5,4);                60320000
    genid("t",numtemps,2);  gen(" do",4,5);                             60321000
statm: statement;                                                       60322000
    gen(" end",5,4);                                                    60323000
    numtemps:=numtemps-1;                                               60324000
end of forstat;                                                         60325000
                                                                        60326000
                                                                        60327000
procedure gotostat;                                                     60328000
begin                                                                   60329000
    integer i;                                                          60330000
    insymbol;                                                           60331000
    if cursy=intconst then                                              60332000
    begin i:=numlabs;                                                   60333000
          while i}1 and labtab[i].labval!curval do i:=i-1;              60334000
          if i=0 then error(15);                                        60335000
          gen("go",3,6);  genid("l",curval,4);                          60336000
          insymbol;                                                     60337000
    end else error(10);                                                 60338000
end of gotostat;                                                        60339000
                                                                        60340000
                                                                        60341000
procedure withstat;                                                     60342000
begin                                                                   60343000
    integer startlevel,veryfirstwithsym,i;                              60344000
    real d;                                                             60345000
    startlevel:=toplevel;  veryfirstwithsym:=nwithsyms;                 60346000
    do begin                                                            60347000
      insymbol;                                                         60348000
      if cursy=identifier then                                          60349000
      begin                                                             60350000
        search;                                                         60351000
        if found then                                                   60352000
        begin                                                           60353000
          if thisid.idclass=var then                                    60354000
          begin                                                         60355000
            variable;                                                   60356000
            if curtype>0 then                                           60357000
            if typetab1[curtype].form!record then error(98);            60358000
            if simplevariable then                                      60359000
            begin putsym("["); insidebrackets:=true end;                60360000
            if toplevel<maxlevel then                                   60361000
            begin                                                       60362000
              toplevel:=toplevel+1;                                     60363000
              d.nametab:=typetab1[curtype].rectab;                      60364000
              d.rectype:=curtype;                                       60365000
              d.numpntrsinwith:=numpointers;                            60366000
              d.firstwithsym:=nwithsyms;                                60367000
              d.bracketsinwith:=real(insidebrackets);                   60368000
              if nwithsyms+numsyms>maxwithsyms then error(63) else      60369000
              for i:=1 step 1 until numsyms do                          60370000
              begin                                                     60371000
                withtab[nwithsyms]:=symtab[i];                          60372000
                nwithsyms:=nwithsyms+1;                                 60373000
              end;                                                      60374000
              d.lastwithsym:=nwithsyms-1;                               60375000
              display[toplevel]:=d;                                     60376000
            end else error(84);                                         60377000
          end else begin error(8); insymbol end;                        60378000
        end else begin error(1); insymbol end;                          60379000
      end else begin error(9); insymbol end;                            60380000
    numsyms:=0;                                                         60381000
    numpointers := 0;                                                   60382000
    end until cursy!comma;                                              60383000
    if cursy!dosy then                                                  60384000
    begin error(19);  skip(dosy);                                       60385000
          if cursy=dosy then insymbol;                                  60386000
    end else insymbol;                                                  60387000
    statement;                                                          60388000
    toplevel:=startlevel;  nwithsyms:=veryfirstwithsym;                 60389000
end of withstat;                                                        60390000
                                                                        60391000
                                                                        60392000
procedure statement;                                                    60393000
begin                                                                   60394000
    integer i;                                                          60395000
    label labfound;                                                     60396000
                                                                        60397000
    if cursy=intconst then            % *** labeled statement ***       60398000
    begin                                                               60399000
      for i:=firstlab step 1 until numlabs do                           60400000
      if labtab[i].labval=curval then                                   60401000
      begin if labtab[i].labdef=1 then error(31);                       60402000
            labtab[i].labdef:=1;                                        60403000
            go to labfound;                                             60404000
      end;                                                              60405000
      error(15);                                                        60406000
labfound: genid("l",curval,4);  gen(":",1,7);                           60407000
      insymbol;                                                         60408000
      if cursy!colon then                                               60409000
      begin error(26);                                                  60410000
            skip(colon);  if cursy=colon then insymbol;                 60411000
      end else insymbol;                                                60412000
    end;                                                                60413000
                                                                        60414000
    comment *** start of statement *** ;                                60415000
                                                                        60416000
    if cursy=identifier then                                            60417000
    begin                                                               60418000
      search;                                                           60419000
      if found then                                                     60420000
      begin                                                             60421000
        if thisid.idclass=var or                                        60422000
          thisid.idclass=const and boolean(thisid.formal) or            60423000
           thisid.idclass=func then assignment else                     60424000
        if thisid.idclass=proc then                                     60425000
        begin                                                           60426000
          if thislevel=0 then           % *** intrinsic procedure ***   60427000
          begin                                                         60428000
            if curname1="50write" then pwrite(false)    else            60429000
            if curname1="7writel" and                                   60430000
               curname2="000000n" then pwrite(true)     else            60431000
            if curname1="400read" then pread(false)     else            60432000
            if curname1="6readln" then pread(true)      else            60433000
            if curname1="400page" then filehandling(5)  else            60434000
            if curname1="3000get" then filehandling(2)  else            60435000
            if curname1="3000put" then filehandling(1)  else            60436000
            if curname1="50reset" then filehandling(3)  else            60437000
            if curname1="7rewrit" and                                   60438000
               curname2="000000e" then filehandling(4)  else            60439000
            if curname1="3000new" then newdisp          else            60440000
            if curname1="7dispos" and                                   60441000
               curname2="000000e" then newdisp          else            60442000
            if curname1="400pack" then pack             else            60443000
            if curname1="6unpack" then unpack           else error(0);  60444000
          end else passparams;                                          60445000
          writeexpr;                                                    60446000
        end else begin error(13); skip(99) end;                         60447000
      end else begin error(1); assignment end;                          60448000
    end of identifier  else                                             60449000
    if cursy=beginsy  then compstat   else                              60450000
    if cursy=ifsy     then ifstat     else                              60451000
    if cursy=casesy   then casestat   else                              60452000
    if cursy=whilesy  then whilestat  else                              60453000
    if cursy=repeatsy then repeatstat else                              60454000
    if cursy=forsy    then forstat    else                              60455000
    if cursy=withsy   then withstat   else                              60456000
    if cursy=gotosy   then gotostat   else                              60457000
    if symkind[cursy]!terminal then                                     60458000
    begin error(13); insymbol; skip(semicolon) end;                     60459000
end of statement;                                                       60460000
$ page                                                                  60461000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%70001000
%                                                                      %70002000
%                                                                      %70003000
%                                                                      %70004000
%                  part 7:  type declarations.                         %70005000
%                           ------------------                         %70006000
%                                                                      %70007000
%                                                                      %70008000
%                                                                      %70009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%70010000
                                                                        70011000
                                                                        70012000
real valx1,valx2;                                                       70013000
integer typex1,typex2;                                                  70014000
boolean packed;                                                         70015000
                                                                        70016000
procedure fieldlist(rectab,firstaddr,lastaddr);                         70017000
value rectab,firstaddr;                                                 70018000
integer rectab,firstaddr,lastaddr;                                      70019000
forward;                                                                70020000
                                                                        70021000
define subrange=                       %*** subrange declaration***     70022000
begin                                  %***************************     70023000
    constant(valx1,typex1);                                             70024000
    if typetab1[typex1].form>char then error(11);                       70025000
    if cursy!doubledot then error(53);                                  70026000
    insymbol;                                                           70027000
    constant(valx2,typex2);                                             70028000
    if typex1>0 and typex2>0 then                                       70029000
      if typex1!typex2 then error(11) else                              70030000
      if valx1>valx2 then error(54);                                    70031000
    t1:=typetab1[typex1].form;  if t1=symbolic then t1:=subtype;        70032000
    newtype;  ttype:=typeindex;                                         70033000
    t1.size:=tsize:=1;  t1.struct:=0;   t1.maintype:=typex1;            70034000
    typetab1[typeindex]:=t1;                                            70035000
    typetab2[typeindex]:=valx1;  typetab3[typeindex]:=valx2;            70036000
end of subrange#;                                                       70037000
                                                                        70038000
                                                                        70039000
procedure typedecl(ttype,tsize);                                        70040000
integer ttype,tsize;                                                    70041000
begin                                                                   70042000
    procedure typerr(errnum,ttype,tsize);                               70043000
    value errnum;                                                       70044000
    integer errnum,ttype,tsize;                                         70045000
    begin error(errnum);                                                70046000
          ttype:=tsize:=0;                                              70047000
    end;                                                                70048000
                                                                        70049000
    integer recinx,arrstruct,tx,sx,t1,t2,t3,t,n;                        70050000
    boolean first;                                                      70051000
                                                                        70052000
    packed:=false;                                                      70080000
    if cursy=identifier then          %*** simple type declaration ***  70081000
    begin                             %*******************************  70082000
      search;                                                           70083000
      if found then                                                     70084000
      begin                                                             70085000
        if thisid.idclass=types then                                    70086000
        begin                                                           70087000
          ttype:=thisid.type;  tsize:=typetab1[ttype].size;             70088000
          insymbol;                                                     70089000
        end else if thisid.idclass=const then subrange                  70090000
                                         else typerr(7,ttype,tsize);    70091000
      end else begin typerr(1,ttype,tsize); insymbol end;               70092000
    end else                                                            70093000
    if cursy{charconst or cursy=plus or cursy=minus then subrange else  70094000
    if cursy=lpar then                                                  70095000
    begin                                                               70096000
      n:=0;                                                             70097000
      newtype; t3.idclass:=const;  t3.type:=typeindex;                  70098000
      do begin                                                          70099000
        insymbol;                                                       70100000
        if cursy=identifier then                                        70101000
        begin                                                           70102000
          newname(curname1,curname2,curlevel);                          70103000
          t3.info:=n;  nametab3[curlevel,thisindex]:=t3;                70104000
          n:=n+1;  insymbol;                                            70105000
        end else error(9);                                              70106000
      end until cursy!comma;                                            70107000
      if cursy!rpar then begin error(46); skip(rpar) end;               70108000
      t1:=symbolic;  t1.struct:=0;                                      70109000
      t1.size:=tsize:=1;  ttype:=typeindex;                             70110000
      typetab1[typeindex]:=t1;                                          70111000
      typetab2[typeindex]:=0;  typetab3[typeindex]:=n-1;                70112000
      if cursy=rpar then insymbol;                                      70113000
    end else                                                            70114000
                                                                        70115000
    if cursy=arrow then                %*** pointer declaration ***     70116000
    begin                              %***************************     70117000
      insymbol;                                                         70118000
      if cursy=identifier then                                          70119000
      begin                                                             70120000
        newtype;  ttype:=typeindex;  t1:=pointers;                      70121000
        t1.size:=tsize:=1;  t1.struct:=0;                               70122000
        typetab1[typeindex]:=t1;                                        70123000
        search;                                                         70124000
        if found then                                                   70125000
        begin                                                           70126000
          if thisid.idclass=types then                                  70127000
          typetab1[typeindex].pointtype:=thisid.type else               70128000
          typerr(7,ttype,tsize);                                        70129000
        end else                                                        70130000
        begin                                                           70131000
          if numpntrs<maxpntrs then numpntrs:=numpntrs+1 else error(52);70132000
          pntrtab1[numpntrs]:=curname1;  pntrtab2[numpntrs]:=curname2;  70133000
          pntrtab3[numpntrs]:=typeindex;                                70134000
        end;                                                            70135000
        insymbol;                                                       70136000
      end else typerr(9,ttype,tsize);                                   70137000
    end of pointer declaration else                                     70138000
    begin                                                               70139000
      if cursy=packedsy then begin packed:=true; insymbol end;          70140000
                                                                        70141000
      if cursy=arraysy then           %*** array declaration ***        70142000
      begin                           %*************************        70143000
        insymbol;                                                       70144000
        if cursy!lbracket then error(47) else insymbol;                 70145000
        t1:=0;  first:=true;                                            70146000
        do begin                                                        70147000
          if first then first:=false else insymbol;                     70148000
          typedecl(tx,sx);                                              70149000
          if tx>0 then                                                  70150000
          begin                                                         70151000
            if typetab1[tx].form>char then error(48);                   70152000
            t1:=arrays;  t1.inxtype:=tx;  t1.arrtype:=t;                70153000
            t2:=typetab2[tx];  t3:=typetab3[tx];                        70154000
            if t3-t2>1022 then error(61);                               70155000
            t1.size:=min(1023,t3-t2+1);                                 70156000
            newtype;                                                    70157000
            typetab1[typeindex]:=t1;                                    70158000
            typetab2[typeindex]:=t2;   typetab3[typeindex]:=t3;         70159000
            t:=typeindex;                                               70160000
          end;                                                          70161000
        end until cursy!comma;                                          70162000
        if cursy!rbracket then error(59) else insymbol;                 70163000
        if cursy!ofsy then begin error(18); skip(ofsy) end;             70164000
        insymbol;                                                       70165000
        typedecl(tx,sx);                                                70166000
        if typetab1[tx].form}files then error(60);                      70167000
        arrstruct:=typetab1[tx].struct;                                 70168000
        while t>0 do                                                    70169000
        begin                                                           70170000
          t1:=typetab1[t];  t3:=t1.arrtype;                             70171000
          t1.arrtype:=tx;  t1.struct:=arrstruct:=arrstruct+1;           70172000
          t1.size:=sx:=min(1024,sx|t1.size);                            70173000
          typetab1[t]:=t1;  tx:=t;  t:=t3;                              70174000
        end;                                                            70175000
        ttype:=tx;  tsize:=sx;                                          70176000
      end of array declaration else                                     70177000
                                                                        70178000
      if cursy=filesy then              %*** file declaration ***       70179000
      begin                             %************************       70180000
        insymbol;                                                       70181000
        if cursy!ofsy then                                              70182000
        begin error(18);                                                70183000
              if cursy!identifier then insymbol;                        70184000
        end else insymbol;                                              70185000
        typedecl(tx,sx);                                                70186000
        if tx>0 then                                                    70187000
        begin t:=typetab1[tx];                                          70188000
              if t.form}files then error(50) else                       70189000
              if t.struct>1 then error(49)                              70190000
        end;                                                            70191000
        newtype;  ttype:=typeindex;                                     70192000
        t1:=if t.form=char then textfile else files;                    70193000
        t1.size:=tsize:=sx;  t1.filetype:=tx;                           70194000
        t1.struct:=1;                                                   70195000
        typetab1[typeindex]:=t1;                                        70196000
      end of file declaration else                                      70197000
                                                                        70198000
      if cursy=setsy then               %*** set declaration ***        70199000
      begin                             %***********************        70200000
        insymbol;                                                       70201000
        if cursy!ofsy then                                              70202000
        begin error(18);                                                70203000
              if cursy>charconst then insymbol;                         70204000
        end else insymbol;                                              70205000
        typedecl(tx,sx);                                                70206000
        if tx>0 then                                                    70207000
        begin                                                           70208000
          if typetab1[tx].form>char then error(48) else                 70209000
          if typetab2[tx]<0 or typetab3[tx]>38 then error(51);          70210000
        end;                                                            70211000
        newtype;  ttype:=typeindex;                                     70212000
        t1:=set;  t1.settype:=tx;  t1.struct:=0;                        70213000
        t1.size:=tsize:=1;  typetab1[typeindex]:=t1;                    70214000
        typetab2[typeindex]:=typetab2[tx];                              70215000
        typetab3[typeindex]:=typetab3[tx];                              70216000
      end of set declaration else                                       70217000
                                                                        70218000
      if cursy=recordsy then            %*** record declaration ***     70219000
      begin                             %**************************     70220000
        if lastrec-1>curlevel then lastrec:=lastrec-1 else error(55);   70221000
        recinx:=lastrec;                                                70222000
        blocktab[recinx]:=numblocks:=numblocks+1;                       70223000
        insymbol;                                                       70224000
        fieldlist(recinx,0,sx);                                         70225000
        if sx>1022 then begin error(56); sx:=1022 end;                  70226000
        newtype;  ttype:=typeindex;                                     70227000
        t1:=record;  t1.rectab:=recinx;  t1.struct:=1;                  70228000
        t1.size:=tsize:=sx;  typetab1[typeindex]:=t1;                   70229000
        typetab2[typeindex]:=0;  typetab3[typeindex]:=sx-1;             70230000
        if cursy!endsy then begin error(24); skip(endsy) end;           70231000
        if cursy=endsy then insymbol;                                   70232000
      end else begin error(4); skip(99) end;                            70233000
    end;                                                                70234000
end of typedecl;                                                        70235000
                                                                        70236000
                                                                        70237000
procedure fieldlist(rectab,firstaddr,lastaddr);                         70238000
value rectab,firstaddr;                                                 70239000
integer rectab,firstaddr,lastaddr;                                      70240000
begin                                                                   70241000
    integer array ilist[0:listlength];                                  70242000
     integer listinx;                                                   70243000
    integer casetype,addr,maxaddr,index,ctype,tx,sx,t1,t3,llim,ulim,i;  70244000
    boolean first;                                                      70245000
    real cval;                                                          70246000
    label casetypeid,casepart,exit;                                     70247000
                                                                        70248000
    addr:=firstaddr;                                                    70249000
    do begin                                                            70250000
      while cursy=semicolon do insymbol;                                70251000
      if cursy=casesy then go to casepart;                              70252000
      if cursy=identifier then                                          70253000
      begin                                                             70254000
        listinx:=0;   first:=true;                                      70255000
        do begin                                                        70256000
          if first then first:=false else insymbol;                     70257000
          if cursy=identifier then                                      70258000
          begin                                                         70259000
            if listinx}listlength then begin error(37); listinx:=0 end; 70260000
            listinx:=listinx+1;                                         70261000
            newname(curname1,curname2,rectab);                          70262000
            ilist[listinx]:=thisindex;                                  70263000
            insymbol;                                                   70264000
          end else                                                      70265000
          begin error(9);                                               70266000
                if cursy!comma then insymbol;                           70267000
          end;                                                          70268000
        end until cursy!comma;                                          70269000
        if cursy!colon then begin error(26); skip(colon) end;           70270000
        insymbol;                                                       70271000
        typedecl(tx,sx);                                                70272000
        if tx>0 then if typetab1[tx].form}files then error(57);         70273000
        t3.idclass:=var;  t3.type:=tx;                                  70274000
        for i:=1 step 1 until listinx do                                70275000
        begin                                                           70276000
          t3.info:=addr;  addr:=min(addr+sx|1024);                      70277000
          nametab3[rectab,ilist[i]]:=t3;                                70278000
        end;                                                            70279000
      end;                                                              70280000
    end until cursy!semicolon;                                          70281000
    lastaddr:=addr;                                                     70282000
    go to exit;                                                         70283000
                                                                        70284000
casepart:                                                               70285000
    listinx:=0;  lastaddr:=addr;  index:=-1;                            70286000
    insymbol;                                                           70287000
    if cursy=identifier then                                            70288000
    begin                                                               70289000
      search;                                                           70290000
      if found and thisid.idclass=types then go to casetypeid;          70291000
      newname(curname1,curname2,rectab);  index:=thisindex;             70292000
      insymbol;                                                         70293000
      if cursy!colon then error(26);                                    70294000
      insymbol;                                                         70295000
      if cursy=identifier then                                          70296000
      begin                                                             70297000
        search;                                                         70298000
        if found then                                                   70299000
        begin                                                           70300000
          if thisid.idclass=types then                                  70301000
          begin                                                         70302000
casetypeid: casetype:=thisid.type;  t1:=typetab1[casetype];             70303000
            llim:=typetab2[casetype];  ulim:=typetab3[casetype];        70304000
            if t1.form>char then error(48);                             70305000
            if index}0 then                                             70306000
            begin                                                       70307000
              t3.idclass:=var;  t3.type:=casetype;  t3.info:=addr;      70308000
              addr:=lastaddr:=addr+1;  nametab3[rectab,index]:=t3;      70309000
            end;                                                        70310000
            insymbol;                                                   70311000
          end else begin error(7); skip(ofsy) end;                      70312000
        end else begin error(1); skip(ofsy) end;                        70313000
      end else begin error(9); skip(ofsy) end;                          70314000
    end else begin error(9); skip(ofsy) end;                            70315000
    if cursy!ofsy then begin error(18); skip(rpar) end;                 70316000
    if cursy=ofsy then insymbol;                                        70317000
    if casetype=0 then begin llim:=-maxint; ulim:=maxint end;           70318000
    do begin                                                            70319000
      while cursy=semicolon do insymbol;                                70320000
      if cursy{charconst or cursy=plus or cursy=minus then              70321000
      begin                                                             70322000
        first:=true;                                                    70323000
        do begin                                                        70324000
          if first then first:=false else insymbol;                     70325000
          constant(cval,ctype);                                         70326000
          if ctype>0 then                                               70327000
          begin                                                         70328000
            if casetype=0 then casetype:=ctype else                     70329000
            if cval<llim or cval>ulim then error(14) else               70330000
            checktypes(casetype,ctype);                                 70331000
            if listinx}listlength then begin error(30); listinx:=0 end; 70332000
            listinx:=listinx+1;                                         70333000
            ilist[listinx]:=cval;  i:=1;                                70334000
            while ilist[i]!cval do i:=i+1;                              70335000
            if i<listinx then error(31);                                70336000
          end;                                                          70337000
        end until cursy!comma;                                          70338000
        if cursy!colon then begin error(26); skip(lpar) end;            70339000
        if cursy=colon then insymbol;                                   70340000
        if cursy=lpar then                                              70341000
        begin                                                           70342000
          insymbol;  fieldlist(rectab,addr,maxaddr);                    70343000
          if maxaddr>lastaddr then lastaddr:=maxaddr;                   70344000
          if cursy!rpar then begin error(46); skip(rpar) end;           70345000
          insymbol;                                                     70346000
        end else error(58);                                             70347000
      end;                                                              70348000
    end until cursy neq semicolon;                                      70349000
exit:                                                                   70350000
end of fieldlist;                                                       70351000
$ page                                                                  70352000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%80001000
%                                                                      %80002000
%                                                                      %80003000
%                                                                      %80004000
%                  part 8:  the procedure block.                       %80005000
%                           --------------------                       %80006000
%                                                                      %80007000
%                                                                      %80008000
%                                                                      %80009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%80010000
                                                                        80011000
                                                                        80012000
                                                                        80013000
procedure declarevars(param,tab,first,last,level);                      80014000
value param,first,last,level;                                           80015000
integer array tab[0];                                                   80016000
integer first,last,level;                                               80017000
boolean param;                                                          80018000
begin                                                                   80019000
    integer level1000,typ,nam,namtab,t1,i,j,recsize;                    80020000
    boolean realvar,arrayvar,firstdim,extfile;                          80021000
    alpha fname;                                                        80022000
    integer fnlength,fnstart;                                           80023000
                                                                        80024000
    level1000:=level|1000;                                              80025000
    for i:=first step 1 until last do                                   80026000
    begin                                                               80027000
      nam:=tab[i].[9:10]; namtab:=nametab3[level,nam];                  80028000
      typ:=namtab.type;     t1:=typetab1[typ];                          80029000
      if namtab.idclass geq func then                                   80030000
      begin                                                             80031000
        if realvar or arrayvar then                                     80032000
        begin                                                           80033000
          gen(";",1,7);                                                 80034000
          realvar:=arrayvar:=false;                                     80035000
        end;                                                            80036000
        if namtab.idclass=func then gen("real",5,4);                    80037000
        gen("procedu",8,1);                                             80038000
        genid("v",level1000+nam,5); gen(";",1,7);                       80039000
      end else                                                          80040000
      if t1.struct=0 then              %*** simple type ***             80041000
      begin                                                             80042000
        if arrayvar then begin gen(";",1,7); arrayvar:=false end;       80043000
        if realvar then gen(",",1,7) else                               80044000
            begin gen("real",5,4); realvar:=true end;                   80045000
        genid("v",level1000+nam,5);                                     80046000
      end else                                                          80047000
      begin                                                             80048000
        if realvar then begin gen(";",1,7); realvar:=false end;         80049000
        if t1.form<files then          %*** array/record ***            80050000
        begin                                                           80051000
          if arrayvar then gen(",",1,7) else                            80052000
              begin gen("array",6,3); arrayvar:=true end;               80053000
          genid("v",level1000+nam,5);  gen("[",1,7);                    80054000
          firstdim:=true;                                               80055000
          do begin                                                      80056000
            if firstdim then firstdim:=false else gen(",",1,7);         80057000
            genint(typetab2[typ]);                                      80058000
            if not param then                                           80059000
            begin gen(";",1,7); genint(typetab3[typ]) end;              80060000
            typ:=if t1.form=arrays then t1.arrtype else realtype;       80061000
            t1:=typetab1[typ];                                          80062000
          end until t1.struct=0;                                        80063000
          gen("]",1,7);                                                 80064000
        end else                                                        80065000
        begin                           %*** file ***                   80066000
          if realvar or arrayvar then                                   80067000
              begin gen(";",1,7); realvar:=arrayvar:=false end;         80068000
          if t1.form=textfile and not param then                        80069000
          begin                                                         80070000
            if numfiles}maxfiles then error(97)                         80071000
                                 else numfiles:=numfiles+1;             80072000
            filetab[numfiles]:=nam;                                     80073000
          end;                                                          80074000
          extfile:=false;                                               80075000
          fname:=nametab1[level,nam];                                   80076000
          fnlength := fname.namelength;  fnstart := 8-fnlength;         80077000
          if fnlength leq 6 then                                        80078000
          begin                                                         80079000
            for j:=1 step 1 until numextfiles do                        80080000
            if fname=extfiletab[j] then extfile:=true;                  80081000
          end;                                                          80082000
          if extfile and not param then                                 80083000
          begin                                                         80084000
             if numfiles geq maxfiles then error(97)                    80085000
             else                                                       80086000
             numfiles := numfiles + 1;                                  80087000
             filetab[numfiles] := -nam - 1;                             80088000
            gen("define",7,2);  genid("f",level1000+nam,5);             80089000
            gen("=",1,7);                                               80090000
            gen(fname,fnlength,fnstart);                                80091000
            gen("#;",2,6);  gen("save",5,4);  gen("file",5,4);          80092000
            gen(fname,fnlength,fnstart);                                80093000
          end else                                                      80094000
          begin                                                         80095000
            gen("file",5,4);  genid("f",level1000+nam,5);               80096000
          end;                                                          80097000
          if not param then                                             80098000
          begin                                                         80099000
            gen(" disk",6,3);   gen("serial",7,2);                      80100000
            if extfile then                                             80101000
            begin                                                       80102000
              if algolcnt lss 13 then writealgol;                       80103000
               gen("[0:0]",5,3);                                        80104000
              gen(""",1,7);                                             80105000
              gen(fname,fnlength,fnstart);                              80106000
              gen(""",1,7);     gen("/",1,7);                           80107000
              if algolcnt<9 then writealgol;                            80108000
              gen(""",1,7);     gen(user,7,1);     gen(""",1,7);        80109000
            end else                                                    80110000
            begin                                                       80111000
              gen("[20:",4,4);  gen("300]",4,4);                        80112000
            end;                                                        80113000
            gen("(1,",3,5);                                             80114000
            recsize:=if t1.form=textfile then 10 else                   80115000
                     if typetab1[t1.filetype].struct=0 then 1 else      80116000
                       typetab3[t1.filetype]-typetab2[t1.filetype]+1;   80117000
            genint(recsize);    gen(",",1,7);                           80118000
            if recsize=1 or recsize=10 then genint(150)                 80119000
                                       else genint(recsize);            80120000
            if algolcnt lss 10 then writealgol;                         80121000
            gen(",save",6,3);   gen("30",2,6);                          80122000
            gen(");",2,6);                                              80123000
          end else gen(";",1,7);                                        80124000
          gen("array",6,3);    genid("v",level1000+nam,5);              80125000
          gen("[",1,7);                                                 80126000
          if typetab1[t1.filetype].struct=0 then                        80127000
          begin                                                         80128000
            if param then gen("0",1,7) else gen("0:0",3,5);             80129000
          end else                                                      80130000
          begin                                                         80131000
            genint(typetab2[t1.filetype]);                              80132000
            if not param then                                           80133000
            begin gen(":",1,7); genint(typetab3[t1.filetype]) end;      80134000
          end;                                                          80135000
          gen("];",2,6);                                                80136000
          gen("integer",8,1);  genid("i",level1000+nam,5);              80137000
          gen(";",1,7);                                                 80138000
        end;                                                            80139000
      end;                                                              80140000
    end of loop;                                                        80141000
    if realvar or arrayvar then gen(";",1,7);                           80142000
end of declarevars;                                                     80143000
                                                                        80144000
                                                                        80145000
procedure parameterlist;                                                80146000
begin                                                                   80147000
    integer firstparam,curkind,p1,px,i,t;                               80148000
    boolean first;                                                      80149000
                                                                        80150000
    define newparam=                                                    80151000
    begin                                                               80152000
        if numparams}maxparams then                                     80153000
        begin error(70); numparams:=maxparams-10 end;                   80154000
        numparams:=numparams+1;                                         80155000
    end of newparam#;                                                   80156000
                                                                        80157000
    newparam;  firstparam:=numparams;                                   80158000
    if cursy=lpar then                                                  80159000
    begin                                                               80160000
      do begin                                                          80161000
        insymbol;                                                       80162000
        if cursy=varsy or cursy=funcsy or cursy=procsy then             80163000
        begin                                                           80164000
          curkind:=if cursy=varsy  then var  else                       80165000
                   if cursy=funcsy then func else proc;                 80166000
          insymbol;                                                     80167000
        end else curkind:=const;                                        80168000
        first:=true;  p1:=numparams+1;                                  80169000
        do begin                                                        80170000
          if first then first:=false else insymbol;                     80171000
          if cursy=identifier then                                      80172000
          begin                                                         80173000
            newname(curname1,curname2,curlevel+1);                      80174000
            px:=thisindex;  px.paramkind:=curkind;                      80175000
            px.paramlevel:=curlevel+1;                                  80176000
            newparam;  paramtab[numparams]:=px;                         80177000
          end else error(9);                                            80178000
          insymbol;                                                     80179000
        end until cursy!comma;                                          80180000
        if cursy=colon then                                             80181000
        begin                                                           80182000
          if curkind=proc then error(90);                               80183000
          insymbol;                                                     80184000
          if cursy=identifier then                                      80185000
          begin                                                         80186000
            search;                                                     80187000
            if found then                                               80188000
            begin                                                       80189000
              if thisid.idclass=types then                              80190000
              begin                                                     80191000
                t3:=thisid.type;                                        80192000
                for i:=p1 step 1 until numparams do                     80193000
                paramtab[i].paramtype:=t3;                              80194000
                if curkind=const or curkind=var then                    80195000
                begin                                                   80196000
                  t:=typetab1[t3];                                      80197000
                  if t.form}files then                                  80198000
                    for i:=p1 step 1 until numparams do                 80199000
                    paramtab[i].paramfile:=1;                           80200000
                  if t.struct>0 and curkind=const then error(94);       80201000
                end else if t.struct>0 then error(38);                  80202000
              end else begin error(7); t3:=0 end;                       80203000
            end else begin error(1); t3:=0 end;                         80204000
          end else begin error(9); t3:=0 end;                           80205000
          insymbol;                                                     80206000
        end else                                                        80207000
        begin                                                           80208000
          if curkind!proc then error(7);                                80209000
          t3:=0;                                                        80210000
        end;                                                            80211000
        t3.idclass:=curkind;  t3.formal:=1;                             80212000
        for i:=p1 step 1 until numparams do                             80213000
        nametab3[curlevel+1,paramtab[i].paramname]:=t3;                 80214000
      end until cursy!semicolon;                                        80215000
      if cursy!rpar then                                                80216000
      begin error(49);  skip(rpar);                                     80217000
            if cursy=rpar then insymbol;                                80218000
      end else insymbol                                                 80119000
    end;                                                                80220000
    paramtab[firstparam]:=numparams-firstparam;                         80221000
end of parameterlist;                                                   80222000
                                                                        80223000
                                                                        80400000
procedure block;                                                        80401000
begin                                                                   80402000
    integer index,ctype,numforwards,t,t3,tx,i;                          80403000
    real cval;                                                          80404000
    alpha c1,c2;                                                        80405000
    boolean valueparams,fun;                                            80406000
    label start;                                                        80407000
                                                                        80408000
    integer labtabtop,consttabtop,typetabtop,paramtabtop,toprec,        80409000
    formerfirstlab,firstfile;                                           80410000
                                                                        80411000
    formerfirstlab:=firstlab;                                           80412000
    labtabtop:=numlabs;   firstlab:=labtabtop+1;                        80413000
    consttabtop:=numconsts;                                             80414000
    typetabtop:=numtypes;                                               80415000
    paramtabtop:=numparams;                                             80416000
    toprec:=lastrec;                                                    80417000
    firstfile:=numfiles+1;                                              80418000
                                                                        80419000
    toplevel:=curlevel;                                                 80420000
    if curlevel>1 then gen("begin",6,3);                                80421000
start:                                                                  80422000
    if cursy=labelsy then               %*** label declaration ***      80423000
    begin                               %*************************      80424000
        gen("label",6,3);                                               80425000
        do begin                                                        80426000
          insymbol;                                                     80427000
          if cursy=intconst then                                        80428000
          begin                                                         80429000
            genid("l",curval,4);                                        80430000
            if curval>9999 then error(33);                              80431000
            for i:=firstlab step 1 until numlabs do                     80432000
            if labtab[i].labval=curval then error(31);                  80433000
            if numlabs}maxlabs then begin error(34); numlabs:=0 end;    80434000
            numlabs:=numlabs+1;                                         80435000
            labtab[numlabs]:=curval;                                    80436000
            insymbol;                                                   80437000
          end else begin error(10); skip(comma) end;                    80438000
          if cursy=comma then gen(",",1,7);                             80439000
        end until cursy!comma;                                          80440000
        if cursy!semicolon then begin error(25); skip(semicolon) end;   80441000
        gen(";",1,7);                                                   80442000
        if symkind[cursy]!initial then insymbol;                        80443000
    end of label declaration;                                           80444000
                                                                        80445000
    if cursy=constsy then               %*** constant declaration ***   80446000
    begin                               %****************************   80447000
        insymbol;                                                       80448000
        do begin                                                        80449000
          if cursy=identifier then                                      80450000
          begin                                                         80451000
            newname(curname1,curname2,curlevel);   index:=thisindex;    80452000
            insymbol;                                                   80453000
            if cursy=eqlsy then                                         80454000
            begin                                                       80455000
              insymbol;  constant(cval,ctype);                          80456000
              t3:=ctype;  t3.idclass:=const;                            80457000
              if cval.[46:8]!0 or cval>1023 then                        80458000
              begin                                                     80459000
                if numconsts}maxconsts then                             80460000
                begin error(35); numconsts:=0 end;                      80461000
                numconsts:=numconsts+1;                                 80462000
                consttab[numconsts]:=cval;                              80463000
                t3.info:=1023+numconsts;                                80464000
              end else t3.info:=cval;                                   80465000
              nametab3[curlevel,index]:=t3;                             80466000
            end else begin error(36); skip(semicolon) end;              80467000
          end else begin error(9); skip(semicolon) end;                 80468000
          if cursy!semicolon then begin error(25); skip(semicolon) end; 80469000
        if symkind[cursy]!initial then insymbol;                        80470000
        end until cursy!identifier;                                     80471000
    end of constant declaration;                                        80472000
                                                                        80473000
    if cursy=typesy then            %*** type declaration ****          80474000
    begin                           %*************************          80475000
        insymbol;                                                       80476000
        do begin                                                        80477000
          if cursy=identifier then                                      80478000
          begin                                                         80479000
            newname(curname1,curname2,curlevel);  index:=thisindex;     80480000
            insymbol;                                                   80481000
            if cursy=eqlsy then                                         80482000
            begin                                                       80483000
              insymbol;                                                 80484000
              typedecl(ctype,tx);                                       80485000
              t3:=ctype; t3.idclass:=types;                             80486000
              nametab3[curlevel,index]:=t3;                             80487000
            end else begin error(36); skip(semicolon) end;              80488000
          end else begin error(9); skip(semicolon) end;                 80489000
       if cursy!semicolon then begin error(25); skip(semicolon) end;    80490000
        if symkind[cursy]!initial then insymbol;                        80491000
        end until cursy!identifier;                                     80492000
    end of type declaration;                                            80493000
                                                                        80494000
    if cursy=varsy then                %*** variable declaration ***    80495000
    begin                              %****************************    80496000
        varindex:=0;                                                    80497000
        do begin                                                        80498000
          firstvar:=varindex+1;                                         80499000
          do begin                                                      80500000
            if cursy=varsy or cursy=comma then insymbol;                80501000
            if cursy=identifier then                                    80502000
            begin                                                       80503000
              if varindex}listlength then                               80504000
              begin error(37); varindex:=0 end;                         80505000
              varindex:=varindex+1;                                     80506000
              newname(curname1,curname2,curlevel);                      80507000
              varlist[varindex]:=thisindex;                             80508000
              insymbol;                                                 80509000
            end else begin error(9); skip(colon) end;                   80510000
          end until cursy!comma;                                        80511000
          if cursy!colon then begin error(26); skip(colon) end;         80512000
          if cursy=colon then                                           80513000
          begin                                                         80514000
            insymbol;                                                   80515000
            typedecl(ctype,tx);                                         80516000
            t3:=ctype;  t3.idclass:=var;                                80517000
            for i:=firstvar step 1 until varindex do                    80518000
               nametab3[curlevel,varlist[i]]:=t3;                       80519000
          end else begin error(26); skip(semicolon) end;                80520000
       if cursy!semicolon then begin error(25); skip(semicolon) end;    80521000
        if symkind[cursy]!initial then insymbol;                        80522000
        end until cursy!identifier;                                     80523000
        declarevars(false,varlist,1,varindex,curlevel);                 80524000
    end of variable declarations;                                       80525000
                                                                        80526000
    if numpntrs>0 then                                                  80527000
    begin                                                               80528000
      c1:=curname1;  c2:=curname2;                                      80529000
      for i:=1 step 1 until numpntrs do                                 80530000
      begin                                                             80531000
        curname1:=pntrtab1[i];  curname2:=pntrtab2[i];                  80532000
        searchtab(curlevel);                                            80533000
        thisid:=nametab3[curlevel,thisindex];                           80534000
        if found and thisid.idclass=types then                          80535000
        typetab1[pntrtab3[i]].pointtype:=thisid.type else error(62);    80536000
      end;                                                              80537000
      curname1:=c1;  curname2:=c2;  numpntrs:=0;                        80538000
    end;                                                                80539000
                                                                        80540000
    while cursy=funcsy or cursy=procsy do %*** proc/func declaration ***80541000
    begin                                 %*****************************80542000
        fun:=cursy=funcsy;  insymbol;                                   80543000
        if cursy=identifier then                                        80544000
        begin                                                           80545000
          searchtab(curlevel);                                          80546000
          thisid:=nametab3[curlevel,thisindex];                         80547000
          if found and thisid.idclass}proc then                         80548000
          begin                                                         80549000
            index:=thisindex;                                           80550000
            if thisid.forwarddef=1 then                                 80551000
            begin                                                       80552000
              nametab3[thislevel,thisindex].forwarddef:=0;              80553000
              numforwards:=numforwards-1;                               80554000
              if(thisid.idclass=proc and fun)or                         80555000
                (thisid.idclass=func and not fun) then error(43);       80556000
              insymbol;                                                 80567000
            end else begin error(2); skip(semicolon) end;               80568000
          end else                                                      80569000
          begin                                                         80570000
            newname(curname1,curname2,curlevel);  index:=thisindex;     80571000
            t3:=0;  t3.info:=numparams+1;                               80572000
            t3.idclass:=if fun then func else proc;                     80573000
            nametab3[curlevel,index]:=t3;                               80574000
            insymbol;  parameterlist;                                   80575000
            if cursy=colon then                                         80576000
            begin                                                       80577000
              if not fun then error(48);                                80578000
              insymbol;                                                 80579000
              if cursy=identifier then                                  80580000
              begin                                                     80581000
                search;                                                 80582000
                if found then                                           80583000
                begin                                                   80584000
                  if thisid.idclass=types then                          80585000
                  begin                                                 80586000
                    t:=typetab1[thisid.type];                           80587000
                    if t.form{alfa or t.form=pointers then              80588000
                    begin                                               80589000
                      nametab3[curlevel,index].type:=thisid.type;       80590000
                    end else error(38);                                 80591000
                  end else error(7);                                    80592000
                end else error(1);                                      80593000
              end else error(9);                                        80594000
              insymbol;                                                 80595000
            end else if fun then                                        80596000
            begin error(26);  skip(semicolon) end;                      80597000
          end;                                                          80598000
        end else begin error(9); skip(semicolon) end;                   80599000
        if cursy!semicolon then begin error(25); skip(semicolon) end;   80600000
        if fun then gen("functn",7,2) else                              80601000
        gen("procedu",8,1);  genid("v",1000|curlevel+index,5);          80602000
        t:=nametab3[curlevel,index].info;  tx:=t+paramtab[t];           80603000
        if tx>t then                                                    80604000
        begin                                                           80605000
          gen("(",1,7);                                                 80606000
          for i:=t+1 step 1 until tx do                                 80607000
          begin genid("v",1000|(curlevel+1)+paramtab[i].paramname,5);   80608000
            if boolean(paramtab[i].paramfile) then                      80609000
            begin                                                       80610000
              gen(",",1,7);                                             80611000
              genid("f",1000|(curlevel+1)+paramtab[i].paramname,5);     80612000
              gen(",",1,7);                                             80613000
              genid("i",1000|(curlevel+1)+paramtab[i].paramname,5);     80614000
            end;                                                        80615000
            if i lss tx then gen(",",1,7);                              80616000
          end;                                                          80617000
          gen(");",2,6);                                                80618000
          valueparams:=false;                                           80619000
          for i:=t+1 step 1 until tx do                                 80620000
          if paramtab[i].paramkind=const then                           80621000
          begin                                                         80622000
            if not valueparams then                                     80623000
            begin gen("value",6,3);                                     80624000
                  valueparams:=true;                                    80625000
            end else gen(",",1,7);                                      80626000
            genid("v",1000|(curlevel+1)+paramtab[i].paramname,5);       80627000
          end;                                                          80628000
          if valueparams then gen(";",1,7);                             80629000
          declarevars(true,paramtab,t+1,tx,curlevel+1);                 80630000
        end else gen(";",1,7);                                          80631000
                                                                        80632000
        insymbol;                                                       80633000
        if curname1="7forwar" and curname2="d" then                     80634000
        begin                                                           80635000
          nametab3[curlevel,index].forwarddef:=1;                       80636000
          numforwards:=numforwards+1;                                   80637000
          gen("forward",8,1);                                           80638000
          insymbol;                                                     80639000
        end else                                                        80640000
        begin                                                           80641000
          curlevel:=curlevel+1;                                         80642000
          if curlevel}lastrec then error(55);                           80643000
          blocktab[curlevel]:=numblocks:=numblocks+1;                   80644000
          t:=curfunc;  curfunc:=if fun then index else -1;              80645000
          block;   %*** compile procedure body ***                      80646000
          replace pointer(nametab1[curlevel,*]) by 0                    80647000
                                        for maxnames+1 words;           80648000
          curlevel:=curlevel-1;   curfunc:=t;                           80649000
          toplevel:=curlevel;                                           80650000
        end;                                                            80651000
        if cursy!semicolon then begin error(25); skip(semicolon) end;   80652000
        gen(";",1,7);                                                   80653000
        if symkind[cursy]!initial then insymbol;                        80654000
    end of procedure declaration;                                       80655000
                                                                        80656000
                                                                        80657000
    if numforwards>0 then error(44);                                    80658000
    gen("integer",8,1);                                                 80659000
    for i:=1 step 1 until maxtemps do                                   80660000
    begin genid("t",i,2);                                               80661000
          if i<maxtemps then gen(",",1,7) else gen(";",1,7);            80662000
    end;                                                                80663000
    if cursy!beginsy then                                               80664000
    begin error(39);                                                    80665000
          while symkind[cursy]!initial do                               80666000
          begin insymbol; skip(semicolon) end;                          80667000
          if(cursy=typesy)or(constsy{cursy and cursy{procsy)then        80668000
          go to start;                                                  80669000
    end;                                                                80670000
    if curlevel=1 then                                                  80671000
    begin                                                               80672000
      gen("init(",5,3);                                                 80673000
      if inputdecl then gen("true",4,4) else gen("false",5,3);          80674000
      gen(");",2,6);                                                    80675000
    end;                                                                80676000
    for i:=firstfile step 1 until numfiles do                           80677000
     if filetab[i] lss 0 then                                           80678000
     begin                                                              80679000
         gen("chfil(",6,2);                                             80680000
         genid("f",1000|curlevel-filetab[i]-1,5);                       80681000
         gen(");",2,6);                                                 80682000
     end                                                                80683000
     else                                                               80684000
    begin                                                               80685000
      genid("i",1000|curlevel+filetab[i],5);                            80686000
      gen(",",1,7);  gen("bufsize",7,1);  gen(":=80;",5,3);             80687000
    end;                                                                80688000
    numfiles:=firstfile-1;                                              80689000
                                                                        80690000
    compstat;     %*** compile statement part ***                       80691000
                                                                        80692000
    for i:=lastrec step 1 until toprec-1 do                             80693000
    replace pointer(nametab1[i,*]) by 0 for maxnames+1 words;           80694000
    for i:=firstlab step 1 until numlabs do                             80695000
    if labtab[i].labdef=0 then error(93);                               80696000
    lastrec:=toprec;                                                    80697000
    numlabs:=labtabtop;                                                 80698000
    firstlab:=formerfirstlab;                                           80699000
    numconsts:=consttabtop;                                             80700000
    numtypes:=typetabtop;                                               80701000
    numparams:=paramtabtop;                                             80702000
    if curlevel>1 then gen("end",4,5);                                  80703000
end of block;                                                           80704000
$page                                                                   80705000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%90001000
%                                                                      %90002000
%                                                                      %90003000
%                                                                      %90004000
%                  part 9:  the main program.                          %90005000
%                           -----------------                          %90006000
%                                                                      %90007000
%                                                                      %90008000
%                                                                      %90009000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%90010000
                                                                        90011000
                                                                        90012000
integer prognamelength;                                                 90013000
alpha progname,algolname;                                               90014000
                                                                        90015000
algolname:="pasc000"&entier(time(4) mod 10)[17:5:6];                    90016000
algolname:=algolname&entier(time(4) div 7)[11:5:6];                     90017000
algolname:=algolname&entier(time(4) mod 9)[5:5:6];                      90018000
user:=time(-1);                                                         90019000
fill pascalgol with algolname,user;                                     90020000
begin                                                                   90021000
   file pascrun disk serial "pascrun"/"disk" (2,10,150);                90022000
   array buf[0:9];                                                      90023000
   label eof;                                                           90024000
                                                                        90025000
   while true do                                                        90026000
   begin                                                                90027000
     read(pascrun,9,buf[*]) [eof];                                      90028000
     write(pascalgol,10,buf[*]);                                        90029000
   end;                                                                 90030000
eof:                                                                    90031000
end of transfer of run time system;                                     90032000
cardlength:=72;                                                         90033000
initialize;  newcard;                                                   90034000
listoption:=checkoption:=true;                                          90035000
c:=" ";  insymbol;                                                      90036000
if cursy=programsy then                                                 90037000
begin                                                                   90038000
  insymbol;                                                             90039000
  if cursy=identifier then                                              90040000
  begin                                                                 90041000
    progname:=curname1.[35:36];  prognamelength:=min(6,curlength);      90042000
    insymbol;                                                           90043000
    if cursy=lpar then                                                  90044000
    begin                                                               90045000
      do begin                                                          90046000
        insymbol;                                                       90047000
        if cursy=identifier then                                        90048000
          begin                                                         90049000
          if curname1="50input" then inputdecl:=true else               90050000
          if curname1="6output" then outputdecl:=true else              90051000
          begin                                                         90052000
            if curlength>6 then error(77);                              90053000
            numextfiles:=numextfiles+1;                                 90054000
            if numextfiles{maxextfiles then                             90055000
            extfiletab[numextfiles]:=curname1 else                      90056000
            if numextfiles=maxextfiles+1 then error(73);                90057000
          end;                                                          90058000
        end else error(9);                                              90059000
        insymbol;                                                       90060000
      end until cursy!comma;                                            90061000
      if cursy!rpar then begin error(46); skip(semicolon) end;          90062000
      if cursy=rpar then insymbol;                                      90063000
      if cursy!semicolon then begin error(25); skip(semicolon) end;     90064000
    end else begin error(58); skip(semicolon) end;                      90065000
  end else begin error(9); skip(semicolon) end;                         90066000
end else begin error(75); skip(semicolon) end;                          90067000
insymbol;                                                               90068000
curlevel:=1;                                                            90069000
lastrec:=maxtables+1;                                                   90070000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%90071000
%                                                                      %90072000
%          block;                compile user program.                 %90073000
%                                                                      %90074000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%90075000
if cursy!dot then                                                       90076000
begin                                                                   90077000
    error(76);                                                          90078000
    do block until cursy=dot;                                           90079000
end;                                                                    90080000
if false then                                                           90081000
begin                                                                   90082000
endofinput: error(87);  charcnt:=-1;                                    90083000
            write(lines,termmess);                                      90084000
end;                                                                    90085000
if listoption and charcnt}0 then printline;                             90086000
if errinx>0 then printerrors;                                           90087000
write(lines[dbl]);                                                      90088000
write(lines[dbl]);                                                      90089000
if numerrs=0 then                                                       90090000
begin                                                                   90091000
    array ziparray[0:19], z[0:0];                                       90092000
    pointer zippnt;                                                     90093000
                                                                        90094000
    define ziptext(text,l)=                                             90095000
    begin                                                               90096000
        z[0]:=text;                                                     90097000
        replace zippnt:zippnt by pointer(z[*])+(8-l) for l;             90098000
    end#;                                                               90099000
                                                                        90100000
    procedure zipnum(n);    % transfers a number to the zip buffer.     90101000
    value n;  integer n;                                                90102000
    if n{9 then ziptext(n,1) else                                       90103000
    begin zipnum(n div 10); ziptext(entier(n mod 10),1) end;            90104000
                                                                        90105000
    writealgol;                                                         90106000
    write(pascalgol,lastline);                                          90107000
    lock(pascalgol,save);                                               90108000
    zippnt:=pointer(ziparray[*]);                                       90109000
    replace zippnt by " " for 20 words;                                 90110000
    write(lines,noerrors);                                              90111000
    ziptext("cc ",3);         ziptext("compile",7);                     90112000
    ziptext(" ",1);           ziptext(progname,prognamelength);         90113000
    ziptext("/",1);           ziptext(user,7);                          90114000
    ziptext(" xalgol",7);     ziptext(" ",1);                           90115000
    if savefactor>0 then ziptext("library",7);                          90116000
    if savefactor<0 then ziptext("syntax",6);                           90117000
    ziptext(";",1);                                                     90118000
    ziptext("xalgol",6);      ziptext(" file",5);                       90119000
    ziptext(" card=",6);      ziptext(algolname,7);                     90120000
    ziptext("/",1);           ziptext(user,7);                          90121000
    ziptext(" serial",7);     ziptext(";",1);                           90122000
    if savefactor>0 then                                                90123000
    begin                                                               90124000
      ziptext("save=",5);     zipnum(savefactor);                       90125000
      ziptext(";",1);                                                   90126000
    end;                                                                90127000
    ziptext("end.",4);                                                  90128000
    zip with ziparray[*];                                               90129000
end of compiler zip else                                                90130000
begin                                                                   91001000
    integer i;                                                          91002000
    switch format errormess1 :=                                         91003000
    ("  0  *** compiler error *** contact the computer centre."),       91004000
    ("  1  identifier not defined."),                                   91005000
    ("  2  identifier already defined."),                               91006000
    ("  3  wrong number of parameters."),                               91007000
    ("  4  syntax error."),                                             91008000
    ("  5  variable not accessible (hardware restriction)."),           91009000
    ("  6  strings may not be continued from one card to another."),    91010000
    ("  7  a type expected."),                                          91011000
    ("  8  variable expected."),                                        91012000
    ("  9  identifier expected."),                                      91013000
    (" 10  integer constant expected."),                                91014000
    (" 11  constant of other type than expected."),                     91015000
    (" 12  variable of illegal type."),                                 91016000
    (" 13  unrecognizable statement."),                                 91017000
    (" 14  constant too big or to small."),                             91018000
    (" 15  undefined label."),                                          91019000
    (" 16  for- and case-statements nested too deep."),                 91020000
    (" 17  expression is of wrong type."),                              91021000
    (" 18  """of""" expected."),                                        91022000
    (" 19  """do""" expected."),                                        91023000
    (" 20  """else""" without corresponding """then"""."),              91024000
    (" 21  illegal termination of statement."),                         91025000
    (" 22  """until""" expected."),                                     91026000
    (" 23  """to""" expected."),                                        91027000
    (" 24  """end""" expected."),                                       91028000
    (" 25  """;""" expected."),                                         91029000
    (" 26  """:""" expected."),                                         91030000
    (" 27  """then""" expected."),                                      91031000
    (" 28  """:=""" expected."),                                        91032000
    (" 29  only numbers may be signed."),                               91033000
    (" 30  too many cases."),                                           91034000
    (" 31  label used more than once."),                                91035000
    (" 32  constant expected."),                                        91036000
    (" 33  label not in range 0..9999."),                               91037000
    (" 34  too many labels declared."),                                 91038000
    (" 35  too many constants declared."),                              91039000
    (" 36  """=""" expected."),                                         91040000
    (" 37  the list is too long."),                                     91041000
    (" 38  invalid type for a function."),                              91042000
    (" 39  """begin""" expected."),                                     91043000
    (" 40  too many identifiers declared."),                            91044000
    (" 41  alfa constants may not be longer than 7 characters."),       91045000
    (" 42  expression is not of type boolean."),                        91046000
    (" 43  not proper forward declaration."),                           91047000
    (" 44  unsatisfied forward declaration."),                          91048000
    (" 45  too many different types declared."),                        91049000
    (" 46  """)""" expected."),                                         91050000
    (" 47  """[""" expected."),                                         91051000
    (" 48  a simple type expected."),                                   91052000
    (" 49  """array of array""" and """array of record""" illegal",     91053000
           " as file type."),                                           91054000
    (" 50  """file of file""" is illegal."),                            91055000
    (" 51  set boundry is too big or too small."),                      91056000
    (" 52  too many undeclared pointers."),                             91057000
    (" 53  """..""" expected."),                                        91058000
    (" 54  first value is greater than second value."),                 91059000
    (" 55  too many records declared at one time."),                    91060000
    (" 56  the record contains more then 1023 words."),                 91061000
    (" 57  files not allowed in records."),                             91062000
    (" 58  """(""" expected."),                                         91063000
    (" 59  """]""" expected.");                                         91064000
                                                                        91065000
    switch format errormess2 :=                                         91066000
    (" 60  """array of file""" not allowed."),                          91067000
    (" 61  range of index is greater than 1023."),                      91068000
    (" 62  unsatisfied pointer declaration."),                          91069000
    (" 63  expression is too long."),                                   91070000
    (" 64  illegal operator for this type of expression."),             91071000
    (" 65  integer expression expected."),                              91072000
    (" 66  a set expected."),                                           91073000
    (" 67  parameter of illegal type."),                                91074000
    (" 68  procedures not allowed in this context."),                   91075000
    (" 69  illegal use of this type of identifier."),                   91076000
    (" 70  too many parameters declared in the program."),              91077000
    (" 71  """array of char""" expected."),                             91078000
    (" 72  wrong type of set expression."),                             91079000
    (" 73  too many external files."),                                  91080000
    (" 74  illegal identifier for external file."),                     91081000
    (" 75  """program""" expected."),                                   91082000
    (" 76  """.""" expected."),                                         91083000
    (" 77  external file identifier may not exceed 6 characters."),     91084000
    (" 78  illegal file parameter."),                                   91085000
    (" 79  illegal use of file handling procedure."),                   91086000
    (" 80  text-file expected."),                                       91087000
    (" 81  pointer variable expected."),                                91088000
    (" 82  only values of type real, integer or char may be read."),    91089000
    (" 83  variables in records illegal in this context."),             91090000
    (" 84  display overflow."),                                         91091000
    (" 85  read and write may only be used on text-files."),            91092000
    (" 86  referenced object is too big."),                             91093000
    (" 87  end-of-input discovered."),                                  91094000
    (" 88  character array expected."),                                 91095000
    (" 89  """,""" expected."),                                         91096000
    (" 91  procedures may not have any type."),                         91097000
    (" 91  parameters of wrong kind."),                                 91098000
    (" 92  only complete arrays and records may be transmitted."),      91099000
    (" 93  declared label not used."),                                  91100000
    (" 94  parameters of this type should not be value parameters."),   91101000
    (" 95  assignment of structured variables not implimented."),       91102000
    (" 96  input/ouput not declared."),                                 91103000
    (" 97 too many files in use."),                                     91104000
    (" 98  record identifier expected."),                               91105000
    (" 99  unrecognized item."),                                        91106000
    ();                                                                 91107000
                                                                        91108000
                                                                        91109000
    write(lines,errors,numerrs);                                        91110000
    for i:=0 step 1 until 59 do if err[i] then                          91111000
    write(lines,errormess1[i]);                                         91112000
    for i:=60 step 1 until 119 do if err[i] then                        91113000
    write(lines,errormess2[i-60]);                                      91114000
end of error messages;                                                  91115000
if xrefoption then                                                      92001000
begin                                                                   92002000
    replace pointer(xrefline[*]) by " " for 17 words;                   92003000
    heading;                                                            92004000
    sort(printxref,xreffile,0,xrefmax,xrefcompare,3,1000,6000);         92005000
end;                                                                    92006000
end of b5700 pascal compiler compiler.. ................................99001000
END;END.        last card image on source tape file                     99999999
?end

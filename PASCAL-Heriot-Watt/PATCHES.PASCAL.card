?execute object/reader
?common=3
?file newtape = patch/pascal serial 
?data card
$# patch   1 for pascal.xvi.o contains 10 cards.  correct spelling & tabulation
$: patch to correct spelling in some error messages, currect tabulation of code
$: or comments, and to correct the call on the procedure to give a new page.
$: *** note that error(71) is now no longer used - see patch  513.
$:     is was used once, but incorrectly. error(63) is called in its place.
$: *** note that the algol code file "pascrun"/"disk" has been renamed
$:     "pascal"/"prelude".  it is no longer referenced directly in this compiler
$:  nils a otte,   univeristy of natal, durban.   aug - nov 1977.
$:
    begin     ; % null                  %***   4) rewrite               50203000
      gen("put",3,5);                   %***   5) page                  50204000
      gen("ppage",5,3);    %                                            50208000
          block;                       %*** compile procedure body ***  80646000
    compstat;                          %*** compile statement part ***  80691000
      (" 41  alfa constants may not be longer than 7 characters."),     91045000
      (" 55  procedure nesting depth + no of records is too great."),   91060000
      (" 87  end-of-input encountered unexpectedly."),                  91094000
      (" 97  too many files in use."),                                  91104000
end of b5700 pascal compiler.. .........................................99001000
$# patch 2 for pascal contains 171 cards.                              
$:    patch to merge dag langmyhrs ppp10 to ppp11 cosy patches         
$:    with nils ottes modified ppp10 source.                           
$:    david a cooper , heriot-watt university,  january 1978.          
$:                                                                     
file card "source" (1,10,30);                  % source code file       10035000
file lines 1 (1,17);                           % print file             10036000
file pascalgol disk serial [20:600] (1,10,30,save 0); % code            10037000
array paramtab, forwparam1, forwparam2[0:maxparams];                    10109000
file xreffile disk serial [20:3000] (1,3,30);                           10137000
alpha array xbuff[0:2];                                                 10138500
boolean xinb;                                                           10138550
integer array symkind[0:62];            %used in error recovery.        10149000
       error100mess (//"100  illegal save constant in """""s""""" option10188500
  the value 07 is substituted"/"     so this error does not increment th10188600
e compilation errors count."//),%                                       10188700
          packedsy=61#,   assertsy=62#;                                 10211000
%                                                                       20181500
%                                                                       20181550
    if errnum=100                                                       20181600
    then numerrs:=numerrs-1;%    * error number 100 alone should not    20181650
%                                * prevent the xalgol compilation being 20181700
%                                * zipped as the value 7 is substituted 20181750
%                                * for a bad save constant in an "s"    20181800
%                                * option.                              20181850
%                                                                       20181900
%                                                                       20181950
      7(initial),middle,initial;                                        20308000
           "400read", "6readln", "50reset", "6unpack", "50write",       20373000
           "6qqjzxl" do                                                 20373500
    if decl then ax := -ax;                                             20520000
    abs(a[2]) leq abs(b[2]);                                            20539000
%                                                                       20541100
%                                                                       20541150
%                                                                       20541200
boolean procedure xrefinput(a);                                         20541250
array a[0];                                                             20541300
begin                                                                   20541350
    label eof;                                                          20541400
    integer i;                                                          20541450
%                                                                       20541500
    read(xreffile,3,xbuff[*])[eof];                                     20541550
    for i:=0,1,2 do                                                     20541600
     a[i] := xbuff[i];                                                  20541650
    if false then eof: begin                                            20541700
                           close(xreffile,release);                     20541750
                           xinb := true;                                20541800
                       end;                                             20541850
    xrefinput := xinb;                                                  20541900
%                                                                       20541950
end of xrefinput;                                                       20541960
        a2 := -a2;                                                      20570000
boolean lparfound,savexrefopt;                                          20842000
    savexrefopt := xrefoption;   xrefoption := false;                   20847500
              if savexrefopt then newxref(curname1,curname2,thislevel,  20861500
                                         false);                        20861550
    xrefoption := savexrefopt;                                          20868500
%        assert            62       assertsy            initial         30075500
                 if curname1="6assert" then assertsy else               30165500
              end%                                                      30280000
%                                                                       30280025
%                                                                       30280050
% the following    lines decode any occurrence of the "s" option and    30280075
% sets the global integer variable "savefactor" which controls the      30280100
% type of compilation initiated by the zip. there are three legal forms 30280125
% of the "s" option as follows.-                                        30280150
%                                                                       30280175
%         "s-"  will give no zip ie. pascal syntax check only           30280200
%         "s+"  will give a zip for compile and go                      30280225
%         "s??" will give a zip for compile to library                  30280250
%               where ?? is the two digit decimal save                  30280275
%               constant given the object code file                     30280300
%               nb. if the save constant is to be                       30280325
%                   less than 10 the first digit                        30280350
%                   must be included ie. a "0".                         30280375
%                                                                       30280400
%                                                                       30280425
             else                                                       30280450
             if cx="s" then                                             30280475
             begin                                                      30280500
                 if c="-" then savefactor:=-1 else                      30280525
                 if c="+" then savefactor:= 0 else                      30280550
                 if c leq 9 then                                        30280575
                 begin                                                  30280600
                     savefactor := 10 | c;   nextchar;                  30280625
                     savefactor := savefactor + c;                      30280650
                     if c gtr 9 then error(100);                        30280675
                 end                                                    30280700
                 else                                                   30280720
                 begin                                                  30280735
                     error(100);                                        30280750
                     savefactor := 7;                                   30280765
                 end;                                                   30280780
             end;                                                       30280800
%                                                                       30280825
%                                                                       30280850
%                                                                       30280875
integer exprlevel,tx,expinvarcnt;%                                      40018000
    boolean inbracket,inrecord,simplevar;                               40087000
      simplevar := false;                                               40099000
    curtype := thisid.type;   simplevar := true;                        40104000
      simplevar := false;                                               40109000
            expinvarcnt:=expinvarcnt+1;%                                40120500
            expinvarcnt:=expinvarcnt-1;%                                40121500
    simplevariable := simplevar;                                        40199500
      if expinvarcnt=0 then writeexpr; %                                40751000
    label efh;                                                          50201500
                                     %*** 6) open & close (input) for   50204500
                                           % cumulative frequency count 50204550
      begin                                                             50208100
          gen("qqjzxl",6,2);                                            50208200
          insymbol;                                                     50208300
          go to efh; %                                                  50208400
      end;                                                              50208500
 efh:                                                                   50219500
     exprlevel := 1;                                                    60346500
           if thisid.idclass=var or                                     60354000
              thisid.idclass=const and boolean(thisid.formal) then %    60354500
     exprlevel := 0;                                                    60383500
procedure assertstat;                                                   60391100
begin                                                                   60391200
    gen("if not(",7,1);                                                 60391400
    insymbol;   boolexpr;                                               60391500
    gen(") then",7,2);   gen("runerr(",7,1);   gen("7,",2,6);           60391600
    genint(cardcnt);     gen(";",1,7);                                  60391700
end of assertstat;                                                      60391800
            if curname1="6qqjzxl" then filehandling(6)   else           60443500
    if cursy=assertsy then assertstat else                              60457500
            if param then gen("0",1,7) else begin                       80129000
                                                gen("0:",2,6);          80129100
                                                genint(recsize-1);      80129200
                                            end                         80129300
            forwparam1[numparams] := curname1;                          80177500
            forwparam2[numparams] := curname2;                          80177600
    integer index, ctype, numforwards, t, tx, i;                        80403000
    alpha t3;                                                           80403500
        label ll1; %                                                    80447010
        label ll2; %                                                    80496010
        label ll3; %                                                    80542010
        if curlevel geq maxtables then error(101) else                  80543500
            blocktab[curlevel+1] := numblocks := numblocks + 1;         80543600
              nametab3[curlevel,thisindex].forwarddef := 0;             80553000
              t := nametab3[curlevel,thisindex].info;                   80554500
              tx := t + paramtab[t];                                    80554600
              for i:=t+1 step 1 until tx do                             80554700
              newname(forwparam1[i],forwparam2[i],curlevel+1);          80554800
          replace pointer(nametab1[curlevel+1,*]) by 0                  80637500
                  for maxnames+1 words;                                 80637600
          if curlevel geq lastrec then error(101); %                    80643000
%                                                                       90014100
%                                                                       90014200
savefactor:=0;%   * default zip is compile and go unless                90014300
%                 * changed by the use of the "s" option                90014400
%                                                                       90014500
%                                                                       90014600
%                                                                       90042100
% the following    lines add a "0" onto the front of the program name or90042200
% the first six characters thereof if it is longer than six characters  90042300
% thus giving the name of the xalgol object code file produced.         90042400
%                                                                       90042500
    progname := curname1.[35:36];  prognamelength := min(6,curlength)+1;90042600
%                                                                       90042700
%                                                                       90042800
begin%                                                                  90090400
     write(line ,noerrors);%                                            90090500
     if err[100]%                                                       90090600
     then write(line ,error100mess);%                                   90090700
     if savefactor}0 then%   *a zip is required                         90090800
%voidt                                                                  90111000
end%                                                                    90129500
     ("100  illegal save constant in """""s""""" option. the value 07 is91106500
substituted"/"     so this error does not increment the compilation erro91106600
rs count."),%                                                           91106700
  ("101  procedures/functions nested too deep."),                       91106800
    rewind(xreffile);                                                   92003500
    sort(printxref,xrefinput,0,xrefmax,xrefcompare,3,1000,6000);        92005000
$# patch 500 for pascal.xvi.o contains  5 cards.  prt cells 25 to 30
$: this patch corrects the documentation for the compilers prt cells 25 to 27
$: (not 21 to 23). furthermore. it uses prt cell 30 for the card count (in place
$: of 27) to be consistant with the other system compilers. prt cells 27 is used
$: for the page count formerly at sequence 10134000.
$:  nils otte,     univeristy of natal, durban.   aug - nov 1977.
$:  
integer numerrs,        % @r+25: number of errors in program.           10029000
        savefactor,     % @r+26: savefactor for code file.              10030000
        pagecnt,        % @r+27: number of pages printed.               10033800
        cardcnt;        % @r+30: number of cards read.                  10034000
  integer  linecnt, errinx;  % pagecnt @ prt+27                         10134000
$# patch 501 for pascal.xvi.o contains 3 cards.  "prt25" for user-s pascal prog.
$: this patch incorporates the pre-defined identifier "prt25" located
$: at prt cell 25 as per documentation. (the documentation must be
$: amended to delete prt26 and prt27 from the pre-defined identifier list.)
$: ** note that file  pascal/prelude  must be updated for "prt25".
$: the variable "prt25" may be set by the  q common = n control card.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
    newname("50prt25",0,0);                       %*** "prt25" ***      20369100
    t3:=inttype;  t3.idclass:=var;     % global integer variable        20369200
    nametab3[0,thisindex] := t3;                                        20369300
$# patch 502 for pascal.xvi.o contains 3 cards.   line count when debugging
$: to correct the line count when the debugging option to list the algol
$: code generated is set (*$d+ *), otherwise lines per page goes wrong.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$: 
define linesperpage = 60 #,                                             10038000
  if dumpoption then begin  if (linecnt:=linecnt+1)}linesperpage        20149000
       then heading;  write(line,10,algolcard[*])   end;                20149100
$# patch 503 for pascal.xvi.o contains  9 cards.  integer to real for typetab1
$: when more than 63 entries were entered in the "typetab*" arrays, the
$: pascal compiler was discontinued due to integer overflow, which could occur
$: in a number of procedures as a result of assigning to an integer an array
$: element whose exponent field was not zero.  the field "arrtype" is
$: [43:10] and has the 4 high order bits in the exponent field.  this patch
$: alters the declarations of all identifier to which "typetab1" may be
$: assigned from integer to real to correct this error.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
    integer  it;   real  t;                                             50225000
    integer  it;   real  t;                                             50285000
    integer casetype,addr,maxaddr,index,ctype,tx,sx, t3,llim,ulim,i;    70244000
    real t1, cval;                                                      70246000
    integer level1000, typ, nam, namtab, i, j, recsize;                 80020000
    alpha  t1, fname;                                                   80022000
    integer firstparam, curkind, p1, px, i, t3;  real t;                80148000
    integer  index, ctype, numforwards, t3, tx, i;                      80403000
    real  t, cval;                                                      80404000
$# patch 504 for pascal.xvi.o contains 23 cards.  implement forward declarations
$: forward declarations of procedures ended in chaos due to the parameters and
$: their types not being kept, resulting in globals being referenced where
$: possible, and forward declarations of functions did not work at all.
$: the problem was that the information on the parameters was being stored
$: in the "nametab*" rows for the current level, which were being set to zero
$: on exit from procedure blocks at that level thereafter.
$: this patch corrects the error by marking the entries for parameters of
$: forward procedures and functions, setting to zero only those elements which
$: are not so marked on exit from a block, and unmarking the relevant parameters
$: when the procedure or function is defined.  the marking of the parameters
$: is done in such a way that the same identifier name may be used at the same
$: level without syntax error x to report that the identifier is already defined
$: the unmarking replaces the identifier name in "nametab*" to allow for the
$: same name or one that hashes to the same place to have been used previously
$: and now deleted.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
          if found and thisid.idclass}func then                         80548000
              nametab3[curlevel,thisindex].forwarddef:=0;               80553000
                (thisid.idclass=func and not fun)  then error(43);      80555100
              tx:=(t:=thisid.info)+paramtab[t];  % unmark forward parms 80556000
              for i:=t+1 step 1 until tx do      %  to allow reference  80557000
              begin  t3:=paramtab[i].paramname;                         80558000
                curname1:=abs(nametab1[curlevel+1,t3]);                 80559000
                curname2:=    nametab1[curlevel+1,t3];                  80560000
                nametab1[curlevel+1,t3]:=0;                             80561000
                newname(curname1,curname2,curlevel+1);                  80562000
                if t3!thisindex then begin                              80563000
                   paramtab[i].paramname:=thisindex;                    80564000
                   nametab3[curlevel+1,thisindex] :=                    80565000
                   nametab3[curlevel+1,t3];                             80565010
             end   end; % of unmarking forward parameters.              80566000
         tx:=(t:=nametab3[curlevel,index].info)+paramtab[t];            80636100
         for i:=t+1 step 1 until tx do     % mark forward parameters    80636200
             nametab1[curlevel+1,paramtab[i].paramname].[46:1] := 1;    80636210
         tx:=curfunc;   curfunc:=if fun then index else -1;             80645000
         for i:=0 step 1 until maxnames do % leave forward parameters   80647000
             if nametab1[curlevel,i]>0 then nametab1[curlevel,i]:=0;    80648000
         curlevel:=curlevel-1;  curfunc:=tx;                            80649000
   for i:=lastrec step 1 until toprec-1 do % clear record decs          80693000
$# patch 505 for pascal.xvi.o contains  9 cards.  check for hash table full
$: when ther are "maxnames" identifiers at one level, the "nametab*" rows
$: become full and this used to put the compiler into an infinite loop,
$: either in "newname" or "searchtab".  this patch inserts test for wrap around
$: leading back to the hashed starting point, for which it gives syntax error
$: 40, too many identifiers declared.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
define  hash(hash1) = entier((hash1) mod maxnames) #;                   20202000
begin  alpha tname;  integer wraparound;                                20209000
      wraparound:=thisindex:=hash(curname1);                            20210000
        if thisindex=wraparound then tname:=0;  % table is full         20216100
    alpha tname;  integer wraparound;                                   20237100
      wraparound:=thisindex:=hash(name1);                               20238000
        if thisindex=wraparound then   % table at this level is full    20244100
           begin error(40); name1:=tname; name2:=nametab2[tab,thisindex]20244200
           end;                                                         20244300
$# patch 506 for pascal.xvi.o contains  2 cards.  reserved word ending at cc 80
$: if a reserved word ended at card column 79 or 80 and if the "boldface" for
$: reserved words option is set (*$r+ *), an invalid index occurred in the
$: scanner "insymbol".  the problem is cured by correctly computing the starting
$: and ending point of the reserved words.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
        begin t1 := cardlength-charcnt-curlength-1;                     30178000
                      for curlength+real(charcnt=0);                    30181000
$# patch 507 for pascal.xvi.o contains  5 cards.  "variable", "simplevariable"
$: in procedure "variable", "simplevariable" is set true if a subscript is
$: simple, resulting in algol code being written prematurely during recursive
$: calls on procedure "expression", which in some cases lead to algol syntax
$: errors.  since writing the algol code is dependant on "exprlevel" being zero,
$: this patch bumps its value prior to analysing the subscript, and sets
$: "simplevariable" false afterwards.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$: 
            exprlevel := exprlevel+1;  % do not "writeexpr" yet         40120900
            exprlevel := exprlevel-1;                                   40121100
            simplevariable := false;   % recursion on "variable"        40121200
              exprlevel := exprlevel+1;                                 60063900
              exprlevel := exprlevel-1;                                 60065100
$# patch 509 for pascal.xvi.o contains  1 card.  "concat" a function of any type
$: the intrinsic function "concat" could only be assigned to a variable declared
$: "real" to avoid type conflict syntax errors.  this patch makes "concat"
$: typeless.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
    curtype := 0;  % alfatype or realtype                               50050000
$# patch 511 for pascal.xvi.o contains  7 cards.  allow up-level addressing
$: to allow up-level identifier references.  formerly, references to global
$: identifiers which were not in the outer block were flagged by syntax error
$: 5, up-level addressing not implemented due to hardware restriction.
$: although the restriction exists in extended algol, it is not true that the
$: restriction is due to hardware, for up-level addressing is allowed in
$: compatible algol with the caution that it is inefficient (the implementation
$: is similar to an array element reference).
$: this patch permits such gobal references, except
$: (1) that if the control variable of a for statement is not local or in the
$:     outer block (ptr) a warning is issued (in the form of a syntax error,
$:     but the error count is not incremented), and
$: (2) the restriction is still applied to function names.  the message for
$:     syntax error is amended accordingly.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
    if errnum<0 then errnum:=abs(errnum) else                           20180900
$  %if thislevel>1 and thislevel<curlevel then error5;                  40103000
$            %if thislevel>1 nd thislevel!curlevel then error5;         50244000
$              %if thislevel.1 and thislevel!curlevel then error5;      50306000
        if thislevel!curlevel-1 or thisindex!curfunc then error(5);     60091000
          if thislevel>1 and thislevel<curlevel then error(-5);         60276000
      ("  5  function name not accessible at this level."),             91009000
$# patch 512 for pascal.xvi.o contains 24 cards. implement structured assignment
$: to allow structured assignment.  formerly, an assignment of a structure
$: was not implemented, eg  a, b: record ... end;  a := b;
$: this patch attempts to implement assignment of structures of any kind,
$: but it would fail if the structure were translated into a multi-dimensional
$: algol array.    this implementation does work for arrays, records,
$: substructures, and for structures allocated in the heap.
$: this patch needs path 507 in order to succeed.
$: for this implementation, the following define is required in the file
$: pascal/prelude:  define assign(dest, source, length) = replace pointer(dest)
$: by pointer(source) for length words #;
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
                                                                        60020000
    procedure writesexpr;    %*** fix structure for assignment          60021000
    begin                    %    used only in assignment of structures 60022000
      if insidebrackets then  if symtab[numsyms] = "100000,"            60023000
         then symtab[numsyms] := ", 0 ] " else putsym("]");             60024000
      while numpointers>0 do                                            60025000
         begin  numpointers := numpointers-1;                           60026000
         if numsyms+4 } maxsyms then  writeexpr;                        60027000
         replace pointer(symtab[numsyms+1]) by                          60028000
              "00-1)div00 1022,00 t mod00 1022]";                       60029000
         numsyms := numsyms+4;                                          60030000
         end; % of while                                                60031000
      writeexpr;  gen( ",", 1,7 );                                      60032000
    end  writesexpr;                                                    60033000
                                                                        60034000
          %error(95);  % structured assignement not implemented.        60063000
          gen("assign(",7,1);  writesexpr;                              60064000
          expression;          writesexpr;                              60065000
          genint(typetab1[lefttype].size);          gen(")",1,7);       60066000
          if typetab1[lefttype].size!typetab1[curtype].size             60067000
              then error(95);                                           60068000
        end;                                                            60087000
        checktypes( lefttype, curtype );                                60088000
      (" 95  size of structures in assignment are not the same."),      91102000
$# patch 513 for pascal.xvi.o contains 16 cards.  fix pointers via pointers
$: to correct the code generated for chained references through the heap,
$: ie for pointers to pointers.  the offset for components within records
$: was incorrectly being added to the record in the leftmost reference, ie the
$: innermost, instead of at the expected level.
$: for example, the following two references would both be translated to
$: the same algol code equivalent to  heap[heap[id+ipart+icomp]];
$:  id@.part@.comp,    id@.part.comp@,
$: when the first should have been:   heap[heap[id+ipart]+icomp].
$: in addition, this patch improves the compilers code for generating the
$: "mem" array subscript.
$:  nils a otte,  university of natal, durban.   1977-11-14
$:
            if numsyms+6 { maxsyms then                                 40175000
              numsyms := numsyms+2;                                     40180400
              if numpointers > 0      % pointer via pointer             40180500
              then begin  replace pointer(symtab[numsyms+1]) by         40180600
                   "00-1)div00 1022,00 t mod00 1022]";                  40180700
                   numsyms := numsyms+4;                                40180800
                   end                                                  40180900
              else  numpointers := 1;                                   40181000
      % inbracket := false;                                             40191100
        begin numpointers := numpointers-1;                             40193000
              if numsyms+4 { maxsyms                                    40194000
              then begin  replace pointer(symtab[numsyms+1]) by         40194100
                   "00-1)div00 1022,00 t mod00 1022]";                  40194200
                   numsyms := numsyms+4;                                40194308
                   end                                                  40194400
              else error(63);  % expression is too long for symtab[*]   40195000
$# patch 514 for pascal.xvi.o contains  2 cards.  process time function for run
$: patch to change the name of the function on the b5700 version which supplies
$: the process time used by the pascal program on the current run from "elapsed"
$: which means platform time, to "cputime" which is the widely accepted term
$: for this quantity.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
   newname("7cputim","e",0);  nametab3[0,thisindex]:=t3;                20390000
           if curname1="7cputim" and curname2="e" then    % "cputime"   40452000
$# patch 516 for pascal.xvi.o contains  2 cards.  correct "no listing" error
$: this patch corrects an error whereby if listing was turned off
$: and page throw was invoked, a heading was  printed regardless.
$: david a cooper, heriot-watt university.....june, 1978
$:
              if cx="l" then if c=1 then                                30264000
                 if listoption then heading else                        30264500
$# patch 517 for pascal.xvi.o contains  2 cards.
$: this patch corrects an error that caused a file declaration
$: to have its name string split over two lines in the generated xalgol.
$:   also changes symtab from type real to type alpha.
$: david a cooper, heriot-watt university.....june, 1978
$:
alpha array symtab[0:maxsyms];     % used by "expression".              10144000
             if algolcnt lss 14 then writealgol;                        80103000
$# patch 518 for pascal.xvi.o. contains 224 cards.
$: this patch changes the way that multi-dimension arrays
$: representing records are declared. previosly they wre declared
$: the wrong way round for xalgol. this patch sorts the dimensions
$: into ascending order form left to right and generates appropriate 
$: defines and code for handling the arrays.
$: stuart anderson, computer science, heriot-watt university, june.....1978.
$:
     define                                                             10156200
          permsub = 0 #, maxtotalsubscrs = 100#,                        10156300
          arrnam  = 1 #;                                                10156400
     array   arrsubpermtab[0:1,0:maxtotalsubscrs];                      10156500
     integer    passpermtab, maxpermtab, rememberposn;                  10156600
$                                                                       40080000
     boolean simplevariable,insidebrackets,insideparens;                40080100
$                                                                       40105000
     if insideparens and typetab1[curtype].struct > 0  and              40105100
                         typetab1[curtype].form < files then            40105200
        putid("h",1000|thislevel+thisindex,5)                           40105300
     else                                                               40105400
        putid("v",1000|thislevel+thisindex,5);                          40105500
     insideparens := true;                                              40258100
     insideparens := false;                                             40259100
$                                                                       50243000
              genid("h",1000|thislevel+thisindex,5);                    50243100
$                                                                       50307000
              genid("h",1000|thislevel+thisindex,5);                    50307100
$set voidt                                                              80052000
$pop voidt                                                              80064000
     define                                                             80064005
           lowsubs = 0 #,                                               80064010
           hisubs  = 1 #,                                               80064015
           nextsubs= 2 #,                                               80064020
           maxnoofsubscripts = 20 #,                                    80064025
           stoppersubtab = 21 #;                                        80064030
     array  arrsubscriptrange[0:2,0:maxnoofsubscripts];                 80064035
     integer  firstrange, nextfreeentry, passsubrange, prevpass,        80064040
              mp, posno, subdiff;                                       80064045
     if  arrayvar  then  gen(";",1,7) else  arrayvar := true;           80064050
     if  not param then                                                 80064055
     begin                                                              80064060
         gen("define",7,2);                                             80064065
         genid("v",level1000+nam,5);                                    80064070
         gen("[",1,7);                                                  80064075
     end;                                                               80064080
     firstrange := stoppersubtab; nextfreeentry := 0;                   80064085
     posno := 1;                                                        80064090
     mp := 10; firstdim := true;                                        80064095
     do                                                                 80064100
     begin                                                              80064105
         if firstdim then firstdim := false else                        80064110
         begin                                                          80064111
         if not param then gen(",",1,7);                                80064112
         end;                                                           80064113
         if not param then  genid("v",(level1000+nam)|mp+posno,if mp=10 80064115
         then 6 else 7);  posno := posno + 1;                           80064120
         if  posno = mp then  mp := mp|10;                              80064125
         if  nextfreeentry = stoppersubtab then                         80064130
         begin                                                          80064135
             error(0);                                                  80064140
         end                                                            80064145
         else                                                           80064150
         begin                                                          80064155
              arrsubscriptrange[lowsubs,nextfreeentry]:=typetab2[typ];  80064160
             arrsubscriptrange[hisubs,nextfreeentry] := typetab3[typ];  80064165
         end;                                                           80064170
         subdiff := typetab3[typ] - typetab2[typ];                      80064175
         if firstrange = stoppersubtab then                             80064180
         begin                                                          80064185
             firstrange := nextfreeentry;                               80064190
             nextfreeentry := nextfreeentry + 1;                        80064195
             arrsubscriptrange[nextsubs,firstrange] := stoppersubtab;   80064200
         end                                                            80064205
         else                                                           80064210
         begin                                                          80064215
             passsubrange := firstrange;                                80064220
             prevpass :=  stoppersubtab; nextfreeentry:=nextfreeentry+1;80064225
          while(subdiff }  arrsubscriptrange[hisubs,passsubrange]       80064230
                          -arrsubscriptrange[lowsubs,passsubrange]) and 80064235
                  (arrsubscriptrange[nextsubs,passsubrange] !           80064240
                                           stoppersubtab) do            80064245
                 begin                                                  80064250
                     prevpass := passsubrange;                          80064255
                     passsubrange := arrsubscriptrange[nextsubs,        8006426
                                                      passsubrange];    80064265
                 end;                                                   80064270
             if  prevpass = stoppersubtab  then                         80064275
             begin                                                      80064280
                 if  subdiff } arrsubscriptrange[hisubs,                80064285
                                                 passsubrange] -        80064290
                               arrsubscriptrange[lowsubs,               80064295
                                                 passsubrange] then     80064300
                 begin                                                  80064305
                     arrsubscriptrange[nextsubs,passsubrange] :=        80064310
                                    nextfreeentry - 1;                  80064315
                     arrsubscriptrange[nextsubs,nextfreeentry-1] :=     80064320
                                    stoppersubtab;                      80064325
                 end                                                    80064330
                 else                                                   80064335
                 begin                                                  80064340
                     arrsubscriptrange[nextsubs,nextfreeentry-1] :=     80064345
                                    firstrange;                         80064350
                     firstrange := nextfreeentry-1;                     80064355
                 end                                                    80064360
             end                                                        80064365
             else                                                       80064370
             begin                                                      80064375
                 if   subdiff } arrsubscriptrange[hisubs,passsubrange] -80064380
                                arrsubscriptrange[lowsubs,passsubrange] 80064385
                                then                                    80064390
                 begin                                                  80064395
                    arrsubscriptrange[nextsubs,passsubrange] :=         80064400
                                  nextfreeentry - 1;                    80064405
                    arrsubscriptrange[nextsubs,nextfreeentry-1] :=      80064410
                                  stoppersubtab;                        80064415
                 end                                                    80064420
                 else                                                   80064425
                 begin                                                  80064430
                    arrsubscriptrange[nextsubs,prevpass] :=             80064435
                                  nextfreeentry -1;                     80064440
                    arrsubscriptrange[nextsubs,nextfreeentry-1] :=      80064445
                                  passsubrange;                         80064450
                 end                                                    80064455
             end                                                        80064460
         end;typ:=if t1.form = arrays then t1.arrtype else realtype;    80064465
         t1 := typetab1[typ];                                           80064470
     end  until t1.struct = 0 ;                                         80064475
     if  not param  then                                                80064480
     begin                                                              80064485
         gen("]=",2,6);                                                 80064490
         genid("h",level1000+nam,5);                                    80064495
         gen("[",1,7);                                                  80064500
         passsubrange:= firstrange; firstdim := true;                   80064505
         while  passsubrange ! stoppersubtab do                         80064510
         begin                                                          80064515
             if firstdim  then  firstdim := false else gen(",",1,7);    80064520
             genid("v",(level1000+nam)|(if passsubrange>9 then 100 else 8006453
                   10)+passsubrange+1,if passsubrange>9 then 7 else 6); 80064535
             passsubrange := arrsubscriptrange[nextsubs,passsubrange];  80064540
         end;                                                           80064545
         gen("]#;",3,5);                                                80064550
     end;                                                               80064555
     passsubrange := firstrange;                                        80064560
     firstdim := true; gen("array",6,3);  genid("h",level1000+nam,5);   80064565
         gen("[",1,7);                                                  80064570
     while passsubrange ! stoppersubtab do                              80064575
     begin                                                              80064580
         if  maxpermtab  leq  maxtotalsubscrs and param  then           80064585
         begin                                                          80064590
             arrsubpermtab[arrnam,maxpermtab] :=                        80064595
                    if   firstdim  then nam else -1;                    80064600
             arrsubpermtab[permsub,maxpermtab] := passsubrange;         80064605
             maxpermtab := maxpermtab + 1;                              80064610
         end                                                            80064615
         else                                                           80064620
         begin                                                          80064625
             if maxpermtab > maxtotalsubscrs then error(0);             80064630
         end;                                                           80064640
         if firstdim  then firstdim := false  else  gen(",",1,7);       80064645
         genint(arrsubscriptrange[lowsubs,passsubrange]);               80064650
         if not param then                                              80064655
         begin                                                          80064660
             gen(":",1,7);                                              80064665
             genint(arrsubscriptrange[hisubs,passsubrange]);            80064670
         end;                                                           80064675
         passsubrange := arrsubscriptrange[nextsubs,passsubrange];      80064680
     end;                                                               80064685
     gen("]",1,7);                                                      80064950
$                                                                       80421000
     if curlevel > 1 then                                               80421010
     begin                                                              80421020
         integer  namofthing,diff;                                      80421030
         boolean  firsttime;                                            80421040
         gen("begin",6,3);                                              80421050
         if  maxpermtab > 0 then                                        80421060
         begin                                                          80421070
             passpermtab := 0;                                          80421080
             do                                                         80421090
             begin                                                      80421100
                 rememberposn := passpermtab;                           80421110
                 gen("define",7,2);                                     80421120
                 namofthing := arrsubpermtab[arrnam,passpermtab];       80421130
         genid("v",1000|curlevel+namofthing,5);                         80421140
                 gen("[",1,7);                                          80421150
                 firsttime := true;                                     80421160
                 do                                                     80421170
                 begin                                                  80421180
                     if firsttime then firsttime := false else gen(",",180421190
                                                                    ,7);80421200
                     diff := passpermtab-rememberposn+1;                80421210
         genid("v",(1000+curlevel+namofthing)|(if diff>9 then 100 else  80421220
                    10)+diff,(if diff > 9 then 7 else 6));              80421230
                     passpermtab := passpermtab + 1; end                80421270
                 until passpermtab = maxpermtab or                      80421280
                       arrsubpermtab[arrnam,passpermtab] ! -1;          80421290
                gen("]",1,7);                                           80421300
                gen("=",1,7);                                           80421310
                genid("h",1000|curlevel+namofthing,5);                  80421320
                gen("[",1,7);                                           80421340
                passpermtab := rememberposn; firsttime := true;         80421350
                do                                                      80421360
                begin                                                   80421370
                    if firsttime then firsttime := false  else gen(",", 80421380
                                                                   1,7);80421390
                    diff := arrsubpermtab[permsub,passpermtab]+1;       80421400
                    genid("v",(1000|curlevel+namofthing)|(if diff>9 then80421410
                          100 else 10)+diff,(if diff>9 then 7 else 6)); 80421420
                    passpermtab := passpermtab +1;                      80421430
                end                                                     80421440
                until   passpermtab = maxpermtab  or                    80421450
                        arrsubpermtab[arrnam,passpermtab] ! -1;         80421460
                gen("]#;",3,5);                                         80421470
             end                                                        80421480
             until  passpermtab = maxpermtab;                           80421490
             maxpermtab := 0;                                           80421500
         end                                                            80421510
     end;                                                               80421520
$                                                                       80608000
     begin                                                              80608010
         begin                                                          80608020
             integer nam,t1,scratch;                                    80608030
             nam := paramtab[i].[9:10];                                 80608040
             scratch := nametab3[curlevel+1,nam];                       80608050
             scratch := scratch.type;                                   80608060
             t1 := typetab1[scratch];                                   80608070
             if t1.struct ! 0 and t1.form  < files  then                80608080
                genid("h",1000|(curlevel+1)+nam,5)                      80608090
             else                                                       80608100
                genid("v",1000|(curlevel+1)+nam,5);                     80608110
         end;                                                           80608120
     maxpermtab := 0;                                                   90070100
     insideparens := false;                                             90070200
$# patch 519 for pascal.xvi.o. contains 1 cards. increase runtime stack.
$:
       " xalgol stack = 2048; stack = 1024; end."; %                    90120500
$# patch 600 for pascal.xvi.o. contains 22  cards. dags dec77 patches.
$: patches received from d.langmyhr and transposed from cosy format by
$: david a cooper. february 1978.
$: 
      if(f1 neq set or rt neq emptyset) %                               20813000
        and %                                                           20813050
        (f2 neq set or lt neq emptyset) then %                          20813100
        if(f1 neq pointers or rt neq niltype) %                         20814000
         and %                                                          20814050
          (f2 neq pointers or lt neq niltype) then %                    20814100
    begin error(63); %                                                  40023000
$                                                                       50059000
              gen("pread(",6,2);  writeexpr;  gen(",",1,7); %           50079000
$                                                                       50080000
$                                                                       50081000
              genid("f",fileid,5); gen(",",1,7); %                      50082000
              if f=numeric then %                                       50086010
              begin %                                                   50086050
                  gen(",",1,7);  genint(typetab2[curtype]); %           50086100
                  gen(",",1,7);  genint(typetab3[curtype]); %           50086150
              end else gen(",0,0,",4,4); %                              50086200
$                  set voidt                                            50088000
$                  pop voidt                                            50093000
 if namtab.idclass=func then gen("functn",7,2) %                        80037000
                        else gen("procedu",8,1); %                      80038000
 if found and (thisid.idclass=proc or thisid.idclass=func) then         80548000
$#patch 601 for pascal.xvi.o.contains 147 cards. extende set mods.
$: patches received from d.langmyhr and transposed from cosy format by
$: david a cooper. february 1978.
$: this patch modifies the set handling routines to allow sets of 0..93
$: elements
$: nb. the run time system must be changed accordingly.....
$:     --- --- ---- ------ ---- -- ------- ----------------
%                                                                       40052050
%                                                                       40052055
procedure split(splitinx,width); %                                      40052100
value splitinx, width; %                                                40052150
integer splitinx, width; %                                              40052200
begin %                                                                 40052250
    integer i; %                                                        40052300
%                                                                       40052350
    if numsyms+width leq maxsyms then %                                 40052400
    begin %                                                             40052450
        for i:=numsyms step -1 until splitinx do %                      40052500
        symtab[i+width] := symtab[i]; %                                 40052550
        for i:=1 step 1 until width do %                                40052600
        symtab[splitinx+i-1] := "3000000"; %                            40052650
        numsyms := numsyms + width; %                                   40052700
    end %                                                               40052750
    else                                                                40052800
    begin %                                                             40052830
        error(63); %                                                    40052860
        numsyms := 1; %                                                 40052890
    end; %                                                              40052900
end of split; %                                                         40052950
%                                                                       40052960
%                                                                       40052965
    end; %                                                              40188005
if typetab1[curtype].form=set then %       *** set variables            40188010
begin %                                    --- --- ---------            40188025
    integer thissyml, i; %                                              40188050
%                                                                       40188075
    split(startsym,1);   symtab[startsym] := "sload("; %                40188100
    if simplevar then %                                                 40188125
    begin %                                                             40188150
        putsym(","); %                                                  40188175
        putid("w",1000|thislevel+thisindex,5); %                        40188200
    end %                                                               40188225
    else %                                                              40188250
    if inbracket and not inrecord then %                                40188275
    begin %                                                             40188300
        putsym(",");   thissyml := numsyms; %                           40188325
        putconst(0);   putsym(" ");  putsym(","); %                     40188350
        for I:=startsym+1 step 1 until thissyml do %                    40188375
        puttext(symtab[i]);                                             40188400
        puttext("  1]  "); %                                            40188425
    end  %                                                              40188450
    else %                                                              40188475
    begin %                                                             40188500
        thissyml := numsyms; %                                          40188525
        if inbracket then putsym("]"); %                                40188550
        for i:=1 step 1 until numpointers do %                          40188575
        begin %                                                         40188600
            puttext("-1)div");   puttext(" 1022,"); %                   40188625
            puttext(" t mod");   puttext(" 1022]"); %                   40188650
        end; %                                                          40188675
        putsym(","); %                                                  40188700
        for i:=startsym+1 step 1 until thissyml do %                    40188725
        puttext(symtab[i]); %                                           40188775
        puttext("  +1  "); %                                            40188800
        if inbracket then putsym("]"); %                                40188825
        for i:=1 step 1 until numpointers do %                          40188850
        begin %                                                         40188875
            puttext("-1)div");   puttext(" 1022,"); %                   40188900
            puttext(" t mod");   puttext(" 1022]"); %                   40188915
        end; %                                                          40188930
        numpointers := 0; %                                             40188945
    end;                                                                40188960
    putsym(",");  putconst(cardcnt);    putsym(")"); %                  40188975
end of set variables; %                                                 40188990
$                                                                       40198000
              if typetab1[thisid.type].form=set then                    40274200
              begin %                                                   40274220
                  gen(",",1,7); %                                       40274240
                  genid("w",1000|thislevel+thisindex,5); %              40274260
              end; %                                                    40274280
    boolean first, splitted; %                                          40296000
        puttext("setbs(");   puttext("   3,2,");  putconst(cardcnt); %  40529000
        putsym(")"); %                                                  40529300
        curtype := emptyset;   curmode := number; %                     40529600
         startsym := numsyms + 1; %                                     40533500
          puttext(" setb("); %                                          40536000
            putsym(",");   symtab[startsym] := "setbs("; %              40544000
        if splitted then putsym(")"); %                                 40551500
        if cursy=comma then %                                           40552000
        begin %                                                         40552200
            split(startsym,1);   symtab[startsym] := "sunio("; %        40552400
            putsym(","); %                                              40552600
            splitted := true; %                                         40552800
        end; %                                                          40552850
       newtype;  t1 := set;   t1.size := 2;   t1.struct := 0; %         40558000
       curmode := number; %                                             40561000
       if curtype=booltype then %                                       40587000
       if cursy neq andsy then error(64);                               40593000
   end else %                                                           40593100
   if f=set then %                                                      40593200
   begin %                                                              40593300
       if cursy=asterisk then %                                         40593400
       begin %                                                          40593500
           split(startsym,1);   symtab[startsym] := "sints("; %         40593600
           putsym(","); %                                               40593700
       end else error(64); %                                            40593800
       mode := number; %                                                40593900
     if f=set then putsym(")"); %                                       40608500
       split(startsym,1); %                                             40650000
       if cursy=plus then symtab[startsym] := "sunio(" else %           40651000
       if cursy=minus then symtab[startsym] := "sdiff(" else %          40652000
          error(64); %                                                  40653000
       putsym(",");   mode := number; %                                 40654000
$                                                                       40655000
     if f=set then putsym(")"); %                                       40668500
$                                                                       40688000
       if cursy=eqlsy then symtab[startsym] := "sequa(" %               40713000
       else                                                             40713150
       if cursy=neqsy then %                                            40713300
       begin %                                                          40714000
           split(startsym,1);   symtab[startsym]:= " not  "; %          40714150
           symtab[startsym+1] := "sequa("; %                            40714300
       if typetab1[lefttype].form=set then %                            60080100
       begin %                                                          60080200
          symtab[1] := "sstor(";    numsyms := numsyms - 3; %           60080300
          expression; %                                                 60080400
          putsym(")");   checktypes(lefttype,curtype); %                60080500
          writeexpr; %                                                  60080600
       end else %                                                       60080700
         if typetab2[tx] lss 0 or typetab3[tx] gtr 93 then error(51);   70210000
       t1.size := tsize := 2;   typetab1[typeindex] := t1; %            70214000
       if t1.form=set then %                                            80046200
       begin %                                                          80046400
           gen(",",1,7);   genid("w",level1000+nam,5); %                80046600
       end; %                                                           80046800
         if t1.form=set then %                                          80064700
         begin %                                                        80064750
             gen(",0",2,6); %                                           80064800
             if not param then gen(":1",2,6); %                         80064850
         end; %                                                         80064900
               begin %                                                  80608105
              if t1.form=set then %                                     80608111
               begin %                                                  80608113
                   gen(",",1,7); %                                      80608115
                   genid("w",1000|(curlevel+1)+nam,5); %                80608117
               end;                                                     80608118
             end; %                                                     80608119
             if typetab1[nametab3[curlevel+1,paramtab[i].paramname].type80627200
                         ].form=set                                     80627205
             then begin %                                               80627400
                      gen(",",1,7); %                                   80627600
                      genid("w",1000|(curlevel+1)+paramtab[i].paramname 80627800
                            ,5); %                                      80627801
                 end;                                                   80627850
$#patch 602 for pascal.xvi./ contains 5 cards. correct representation of "nil".
$: received from dag langhymr on 6/07/78.
$: david a cooper , heriot-watt university... july 1978.
niltype := 6;             %*** type of "nil" ***                        20363000
t1.form := pointers;    typetab1[6] := t1;                              20364000
emptyset := 7; %                                                        20364500
t1.form := set;   typetab1[7] := t1;                                    20365000
numtypes := 7; %                                                        20365500
$# patch 603 for pascal xvi.o contains 6 cards. correct to patch 601
$:   david a cooper & s o anderson, heriot-watt university.   ust august 1978
$:
    integer  startsym,firstsym,mode,type1,f;                            40618000
    putdummy; startsym := firstsym := numsyms;                          40621000
        split(firstsym,1);                                              40650000
        if cursy = plus then symtab[firstsym] := "sunio(" else          40651000
        if cursy = minus then symtab[firstsym] := "sdiff(" else         40652000
         error(64);                                                     40653000
$# patch 614 for pascal.xvi.o. contains 7 cards. 
$                                                                       40105100
$                                                                       40105200
$                                                                       40105300
$                                                                       40105400
    if insideparens and simplevar and typetab1[curtype].struct > 0 and  40198500
       typetab1[curtype].form < files  then symtab[startsym].[35:6] :=  40198600
                                                              "h";      40198700
$# patch 700 for pascal.xvi.o  has  179 cards.   reduce thrashing by code change
$: to improve run time efficiency by reaarranging the the compilers code.
$: the compiler had a high overlay i/o time and high elapsed time in relation
$: to the process time, and observation of the b5700 confirmed that it was
$: thrashing in 32k.  this patch attempts to reduce the core requirements by
$: rearranging the segmentation of the code.  large segments are eliminated
$: so as to avoid pulling code that will not be executed into core and to
$: release code segments as so as execution has passed. for example, the
$: cross reference routines were all contained in the large outer block code
$: segment which included various utility routines.
$: a feature which contributed significantly to large segments was the high
$: number of "defines" which resulted in sizeable sections of code being
$: generated in-line, sometimes many times in one segment.  these "defines"
$: were readily changed into procedures. (a side effect of virtually eliminating
$: defines for code is that the "bend" option no longer results in numerous
$: blank lines repeating the same sequence number for every "end" in the nested
$: defines.)
$:  nils a otte,   university of natal, durban     aug - nov 1977.
$:
$                                                                       10167000
$                                                                       10168000
$                                                                       10169000
  value       name1,name2,table,decl;                                   20016000
  real        name1,name2;                                              20017000
  integer                 table;  boolean decl;                         20018000
  forward;                                                              20019000
procedure  printerrors;  forward;                                       20020000
procedure  heading;          %*** prints a heading at start of new page.20026000
begin                        define newsegment = here #;                20027000
end of heading;                                                         20033000
procedure  printline;        %*** prints a pascal source code line      20036000
begin                        define newsegment = here #;                20037000
end of printline;                                                       20047000
procedure  newcard;          %*** reads a new pascsal source code card  20050000
begin                        define result = icard[*], etc #;           20051000
    replace xlinepnt by " " for 16 words;                               20056000
    replace linepnt  by cardpnt for 10 words, xlinepnt for 6 words;     20057000
end of newcard;                                                         20061000
define gen(gen1,gen2,gen3) = geni(true,gen1,gen3,gen2) #,               20063100
genid(genid1,genid2,genid3)= geni(false,genid1,genid2,genid3) #;        20063200
                                                                        20063300
procedure  geni(gent, txt, num, n);                                     20063400
value gent, txt, num, n;                                                20063500
boolean gent;  alpha txt;  integer num, n;                              20063600
begin                        define start = num #, ndig = n #;          20063700
                                                                        20063800
    if gent then              %*** generate a text "txt", consisting of 20064000
    text[0] := txt;                                                     20067000
end                                                                     20070000
else                        %*** generate an algol identifier.          20073000
    ch[0] := txt;                                                       20076000
end end  geni;                                                          20079000
procedure  genint( n );                                                 20082000
value n;  integer n;                                                    20083000
begin                       define result = algol code #;               20084000
    integer nabs, nsize;                                                20085000
end of genint;                                                          20097000
procedure writealgol;       %*** writes a completed algol card to       20145000
    define newsegment = here #;                                         20146100
    define newsegment = here #;                                         20168100
    define newsegment = here #;                                         20180100
    define newsegment = here #;                                         20193100
alpha thisid, curname1, curname2, tname;  % used in scanner             20205000
procedure  searchtab( tab ); %*** search name table "tab" for the       20208000
value tab;  integer tab;     %***  identifier just read.                20208100
end of searchtab;                                                       20221000
procedure  search;           %*** search all tables currently in use.   20223000
begin                        define result = thisid #;                  20224000
end of search;                                                          20233000
procedure  newname( name1, name2, tab );                                20236000
value name1, name2, tab;                                                20236100
alpha name1, name2;  integer tab;                                       20236200
end of newname;                                                         20250000
    define newsegment = here #;                                         20515100
    define newsegment = here #;                                         20533100
    define newsegment = here #;                                         20546100
procedure  checktypes(lefttype, righttype );                            20802000
value lefttype, righttype;  integer lefttype, righttype;                20803000
begin                                                                   20804000
    real tt1, tt2;  integer f1, f2, lt, rt;                             20805000
end of checktypes;                                                      20838000
procedure  fileparam( defaultfile );   %*** checks the first parameter  20844000
value defaultfile; integer defaultfile;%*** to see if it is a file.     20844100
begin              define results = filename & lparfound #;             20845000
end of fileparam;                                                       20869000
real curval;  integer curlength;                                        20872000
                                                                        20873000
procedure constant( cval, ctype );                                      20874000
real cval;  integer ctype;                                              20875000
begin                                                                   20876000
    integer tform;  boolean signed, negative;                           20876100
end of constant;                                                        20921000
$                                                                       30082000
alpha  c, cx;       %( curname1 & curname2 moved to 20205000 )          30083000
integer lastcharpos;  %( curval, curlength moved to 20872000 )          30084000
procedure  insymbol;         %*** identifies the next symbol ******     30087000
begin                                                                   30087100
                                                                        30087200
    procedure   nextchar;    %*** gets the next character.              30088000
    end of nextchar;                                                    30093000
$                                                           set voidt   30095000
$                                                           pop voidt   30098000
    define  t1 = exp #;      % used at 30178000                         30099100
            begin                 define newsegment = here #;           30261100
            end newsegement;                                            30282200
$                                                                       40016000
$                                                                       40017000
integer  exprlevel;                                                     40018000
define putsym(s) = puttext( (s)&1[41:5:6] ) #;                          40029000
$                                                           set voidt   40029900
$                                                           pop voidt   40033000
define putdummy = puttext("3000000") #;                                 40041000
$                                                           set voidt   40042000
$                                                           pop voidt   40044000
procedure  writeexpr;       %*** write generated algol expression       40053000
    real sx;  integer t1, tx;                                           40054100
end of writeexpr;                                                       40066000
procedure  checkexpr( llim, ulim );   %*** write code to check value    40069000
    value llim, ulim;  integer llim, ulim;                              40069100
begin                                 define check = value #;           40070000
end of checkexpr;                                                       40077000
    integer t1, t5;          % used once each                           40086100
      t1:=t.firstwithsym;  t5:=t.lastwithsym;                           40094000
      for t1:=t1 step 1 until t5 do puttext(withtab[t1]);               40095000
    define  t1 = t #;      % used at 405558000                          40298000
$                                                           set voidt   40299000
$                                                           pop voidt   40309000
                                                                        40331000
         procedure parameter;  %*** check that the function has 1 param.40332000
            begin                                                       40333000
            insymbol;                                                   40334000
            if cursy=lpar                                               40335000
            then begin                                                  40336000
              putsym("(");  insymbol;  expression;                      40337000
              if typetab1[curtype].form=numeric then curtype:=inttype;  40338000
              if cursy!rpar then begin error(3); skip(rpar) end;        40339000
              putsym(")");  if cursy=rpar then insymbol;                40340000
            end else error(3); % or error(58)                           40341000
         end of parameter;                                              40342000
                                                                        40350000
$                                                                       60396000
    begin     label labfound;                                           60399000
           thisid.idclass=const and boolean(thisid.formal) or           60423000
           thisid.idclass=func                                          60423200
        then  assignment  else                                          60424000
$                                                           set voidt   70013000
$                                                           pop voidt   70016000
   value            rectab,firstaddr;                                   70018000
   integer          rectab,firstaddr,lastaddr;                          70019000
$                                                           set voidt   70022000
$                                                           pop voidt   70034000
                                                                        70035000
procedure   typedecl(  ttype, tsize );  %***** type declaration *****   70036000
  integer              ttype, tsize;    %****************************   70037000
begin                                                                   70038000
    integer recinx, arrstruct, tx, sx, t, n;  real t1, t2, t3;          70039000
    boolean  first, packed;                                             70040000
                                                                        70041000
$                                                                       70042000
    end typerr;                                                         70048000
  procedure  subrange;                  %*** subrange declaration ***   70050000
  begin                                 %****************************   70051000
    real     valx1,  valx2, t1;                                         70052000
    integer typex1, typex2;                                             70053000
                                                                        70054000
    constant(valx1,typex1);                                             70055000
    if typetab1[typex1].form>char then error(11);                       70056000
    if cursy!doubledot then error(53);                                  70057000
    insymbol;                                                           70058000
    constant(valx2,typex2);                                             70059000
    if typex1>0 and typex2>0 then                                       70060000
      if typex1!typex2 then error(11) else                              70061000
      if valx1>valx2   then error(54);                                  70062000
    if (t1:=typetab1[typex1].form) = symbolic then  t1:=subtype;        70063000
    newtype;  ttype:=typeindex;                                         70064000
    t1.size:=tsize:=1;  t1.struct:=0;  t1.maintype:=typex1;             70065000
    typetab1[typeindex]:=t1;                                            70066000
    typetab2[typeindex]:=valx1;  typetab3[typeindex]:=valx2;            70067000
  end of subrange;                                                      70068000
                                                                        70069000
                                        define dec = pointer #;         70117100
                                        define dec = array #;           70143100
                                        define dec = file #;            70180100
                                        define dec = set #;             70200100
                                        define dec = record #;          70220100
    label casepart, exit;                                               70247000
    begin                               define dec = variant #;         70285100
    label casetypeid;                                                   70285200
    end;                                                                70349100
                                        define dec = file #;            80066100
              gen(""/",2,6);                                            80107000
                                        define dec = label #;           80424100
                                        define dec = const #;           80447100
                                        define dec = type #;            80475100
                                        define dec = var #;             80496100
    if    cursy=funcsy or cursy=procsy    %                             80540900
    then begin                            define dec = code #;          80540910
    end of segment for procedure declarations;                          80648100
$# patch 701 for pascal.xvi.o contains 14 cards.  reduce thrashing by array cuts
$: to improve run time efficiency by reducing array sizes.  the most significant
$: contribution to the compilers thrashing behaviour was the excessively large
$: data arrays. this patch succeeds in drastically reducing the core requirement
$: of the compiler by making most of the large arrays much smaller without
$: imposing unreasonable restrictions.  in particular, the three arrays,
$: nametab1, nametab2, nametab3 wre ehach [0:50, 0:1022], and have been reduced
$: to [0:30, 0:307].  these reductions have not prevented the compilation of
$: a large pascal program of about 4000 lines, namely the p4 pascal compiler
$: from zurich.  in fact, priot to the changes introduced by patches 700 & 701,
$: the p4 pascal compiler took 60 minutes elapsed time to compile, which was
$: reduced to 9 minutes by these patches, while the process time has remained
$: constant at 9 minutes.
$:**** note that if "maxnames" is changed then there are 7 defines in the file
$:     pascal/prelude that must also be changed.
$: "maxnames" was chosen as a prime number as it is used as a modulus for a hash
$: function.  the pascal identifiers are translated to algol names using level
$: and hash index.  hence changing "maxnames" changes the algol names for
$: "input", "output", & "prt25".
$:  nils a otte,   university of natal, durban     aug - nov 1977.
$:
define maxtables  = 30 #,    %max number of levels  in identifier table.10042000
       maxnames   =307 #,    %max names in each roe of identifier table.10043000
                             % only used in with statement to test      10044001
       maxcases   =64 #,     %max labels in a case-statement.           10045000
       maxlabs    =50 #,     %max number of labels.                     10046000
       maxparams  =200 #,    %max number of parameters in whole program.10047000
       maxtypes   =250 #,    %max number of different types.            10048000
       maxconsts  =100 #,    %size of constant table.                   10049000
       maxwithsyms= 70 #,    %max number of symbols used by with-statms.10051000
       maxsyms    =200 #,    %max number of symbols in one expression.  10052000
       listlength =100 #,    %max length of var and param lists.        10053000
       maxextfiles=10 #,     %max number of external files.             10054000
       maxfiles   =10 #,     %max number of files declared at one time. 10055000
       maxpntrs   =10 #;     %max number of undeclared pointers.        10056000
$# patch 702 for pascal.xvi.o contains  4 cards.  boolean array "err" 120 to 4
$: to extend the reductions of patch 701 to the boolean array "err" for noting
$: the syntax errors that have occurred.  this patch compresses the array from
$: 120 words to 4 words by using 32 bits in each word.
$: in addition, this patch inserts the error count on the left of the line
$: which reports the syntax errors.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
array errp[0:3];   % holds 128 bits     % records error messages used.  10156000
define err[err1] = boolean(0&errp[err1.[6:2]][0:err1.[4:5]:1]) #;       10156108
    errp[errnum.[6:2]]:=errp[errnum.[6:2]] & 1[errnum.[4:5]:0:1];       20182000
    replace pointer(errline[0])+4 by numerrs for 4 digits;              20194900
$# patch 703 for pascal.xvi.o contains  6 cards.  reduce thrashing by save core
$: to improve run-time efficiency by reducing non-overlayable areas.
$: this patch reduces the save core requirements by decreasing the file block
$: sizes and also the number of buffers without unduly retarding the compilation
$: speed.  the size of the disk areas is kept a multiple of the original block
$: size where relevant to avoid incompatibility problemes. comparable reductions
$: in block sizes of the object program are also made.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
file card "source" (1,10,38);      % pascal source code input file      10035000
file pascalgol disk serial [20:300] (1,10,30,save 0);  % algol code file10037000
file xreffile disk serial [20:3000] (1,3,30);    % for cross reference  10137000
            if recsize=1 or recsize=10 then genint(30)                  80119000
            gen(",save",6,3);                                           80122000
            gen("30);", 4,4);                                           80123000
$# patch 704 for pascal.xvi.o has  8 cards.     reduce overheads in copying file
$: to reduce the compiler-s overheads.  firstly, the algol code file
$: pascrun/disk  is renamed  pascal/prelude.  originally, the compiler copied
$: the pascal/prelude file into the generated code file before starting to
$: translate the pascal program.  this patch saves the 3 seconds or so required
$: for this by setting the "tape" option for the algol compiler and label
$: equating the tape file to pascal/prelude.  the overhead to the algol compiler
$: is negligible.  the advantage is even greater if the program fails to
$: compile syntax free.  the file pascal/prelude is no longer referenced
$: directly in the pascal compiler.
$: see patch 711.  this needs patch 705.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
       errors   (i5," errors detected ",20("#") /),                     10188000
       alist    ("$ set list "),                                        10189000
       merge    ("$ set tape reset $" /                                 10190100
                 "$ reset tape", t73,"99000000" ),                      10190200
       termmess ("****    compilation terminated.");                    10192000
write(pascalgol,merge);  % algol must compile prelude first             90022000
$                                                           set voidt   90023000
$                                                           pop voidt   90032000
$:       "; algol file tape= pascal/prelude serial; algol file card=",  90119000
$# patch 705 for pascal.xvi.o contains 21 cards.  generate a better zip
$: this patch tidies up the code that generates the zip to pass control to the
$: compatable algol compiler.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
$                                                                       90013000
    progname := if curlength < 7                                        90042000
                then "      "&curname1[41:6|curlength-1:6|curlength]    90042010
                else curname2.[5:6]&curname1[41:35:36];                 90042020
$:  array ziparray[0:16];                                               90092000
    define pprogname = 13 #,   palgolname = 14 #,                       90095000
           plibrary  = 15 #,   puser      = 16 #,                       90096000
           p(p1)     = pointer(ziparray[p1])+1 for 7 #;                 90097000
$                                                           set voidt   90098000
$                                                           pop voidt   90104000
$                                                                       90109000
    ziparray[pprogname]:=progname;   ziparray[palgolname]:=algolname;   90112000
    ziparray[plibrary]:= if savefactor>0 then "library" else            90113000
                         if savefactor<0 then " syntax" else " & run "; 90114000
    ziparray[puser]:=user;                                              90115000
    replace pointer(ziparray[*]) by "cc compile ",                      90116000
         p(pprogname), "/", p(puser),                                   90117000
         " xalgol ", p(plibrary),                                       90118000
         "; algol file tape= pascal/prelude serial; algol file card=",  90119000
         p(palgolname), "/", p(puser), " serial; end.";                 90120000
$                                                           set voidt   90121000
$                                                           pop voidt   90128000
$# patch 708 for pascal.xvi.o contains 25 cards. line print file may be disk
$: to enable the compiler-s print file to be label equated to disk as for other
$: b5700 compilers.  in particular, this patch changes the name to line to be
$: consistent with all the system compilers.  the ability to label equated file
$: "line" to disk is necessary if the compiler is to be used from a terminal.
$: note that a blocked file should not have variable length records if it is
$: to be label equated to a printer.  if less than a the max number of words per
$: record is written, the balance of the record remains unchanged from what was
$: last in the file buffer, so that on being printed "garbage" appears at the
$: end of such lines.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
save file out line disk serial [20:1200] (1,17,90,save 1); % print file 10036000
                        % avoid blocking records of variable length     10036001
array icard, algolcard[0:9], lines, xline[0:16];                        10130000
                             % avoid blocking variable length records   10130001
array headtext, errline[0:16];                                          10133000
      write( line[no], 17,xline[*]);                                    20042000
      write( line[no], 17,errline[*]);                                  20043000
    write( line[no], 17,xline[*]);                                      20045000
    write( line[no], 17,errline[*]);                                    20195000
    linepnt :=pointer(lines[1]);                                        20315000
    replace linepnt-8 by " " for 17 words;                              20317000
    replace xlinepnt-8 by linepnt-8 for 17 words;                       20318000
    replace pointer(errline[*]) by "****   ", linepnt for 16 words;     20319000
    replace algolpnt by linepnt for 9 words;                            20321000
    replace pointer(headtext[*]) by linepnt for 10 words, "page 1  ",   20326000
                                    linepnt for  6 words;               20326100
      write(line, 17,xrefline[*]);                                      20549000
      lock( line, * ); % & crunch                                       20550000
          write(line, 17,xrefline[*]);  linecnt:=linecnt+1;             20560000
        write(line, 17,xrefline[*]);  linecnt:=linecnt+1;               20571000
            write(line, termmess);                                      90084000
     write(line, noerrors);                                             90111000
    write(line, errors,numerrs);                                        91110000
    write(line, errormess1[i]);                                         91112000
    write(line, errormess2[i-60]);                                      91114000
$# PATCH 709 for pascal.xvi.o contains 17 cards. no print if no list & no errors
$: to open the print file only if the list option is set or if syntax errors
$: are detected.  if the first card in the pascal source resets the list option
$: (*$l- *) and no syntax errors are detected, then the print file will not be
$: created (even for the heading) as for other compilers.  in particular, this
$: implementation does not require a test prior to printing each line to
$: determine whether a heading has been printed.  it only does this test when
$: the list option is set after the first card or explicitly thereafter, or
$: in the "printerrors" routine.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
    if pagecnt=1 then write(line[no],17,headtext[*]) else               20029000
    write( line[page]);                                                 20030000
    write( line[dbl],17,headtext[*]);                                   20031000
    if not listoption then                                              20194000
         begin if pagecnt=0 then heading;  printline  end;              20194100
    replace pointer(headtext[*])+45 by textpnt+3 for 2,"/",             20329000
            textpnt+1 for 2, "/", textpnt+3 for 2;                      20330000
    newcard; listoption:=checkoption:=true;  % default                  20402100
    insymbol;     % analysing first card may change default list optn   20402200
    if listoption and pagecnt=0 then heading;  % on first page.         20402300
           if listoption then if pagecnt=0 then heading; % on first page30282100
c := " ";     % to initialize "insymbol"                                90034000
initialize;   % compiler tables, newcard, insymbol                      90035000
$                                                                       90036000
if pagecnt > 0     % there has been some listing                        90088000
then begin  write( line[dbl] );  write( line[dbl] )  end;               90089000
    if pagecnt>0 then   % there has been listing                        90110000
$# patch 711 for pascal.xvi.o contains 10 cards. pasc001/usercode unique name
$: to generate a unique file name in the disk directory.  this patch changes the
$: method for generating a unique file name for the algol source code output of
$: the compiler.  formerly, this was done using the time function to obtain
$: some random digits.  the method used in patch/merge is adopted here, namely
$: starting with the prefix (mfid) "pasc001", a search is preformed to determine
$: whether such a file name is already catalogued.  if so, 1 is added and the
$: search repeated. in addition, the file is created with a save factor
$: (retention period) of zero days so that a halt-load will remove the file
$: automatically.
$: see patch 704.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
procedure  searchdiskdirectory( f, a );  file f;  array a[0];           20222100
           search( f, a[*] );   % end of searchdiskdirectory;           20222200
                                                                        20222300
    charpnt := pointer(ch[0])+7;  ch[0] := " ";                         20322000
ch[0] := "pasc000";  charpnt := pointer(ch[0])+5;                       90016000
pascalgol.fid := user := time(-1);                                      90017000
do begin   c:=c+1;  replace charpnt by c for 3 digits;                  90018000
   pascalgol.mfid := algolname := ch[0];                                90019000
   searchdiskdirectory( pascalgol, lines[*] );                          90020000
end until lines[0]=-1; % file not on disk                               90021000
$# patch 712 for pascal.xvi.o contains 2 cards.  mark procedure levels in margin
$: patch to mark the start and end of procedures and functions by annotating the
$: margin with the symbols "+p" & "-p" followed by the level number.
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
    margin("+p",curlevel);    % mark procedure level                    80420100
    margin("-p",curlevel);    % mark end of procedure                   80702100
$# patch 713 for pascal.xvi.o contains 14 cards.corrects error message etc.
$:   corrects the double "no erros" message and the output of headings
$:   when l1 is set after l-.
$:   also corrects the scanning problem when compiler options are incorrect.
$:   david a cooper, heriot-watt univeristy ...... august 1978
$:
       error102mess(//"102  *** warning only, illegal compiler option.")10188750
       , %                                                              10188751
    if errnum=100 or errnum=102                                         20181600
    then numerrs := numerrs - 1; %*error number 102 is only an illegal  20181610
%                               * dollar option warning &               20181620
%                               *error number 100 alone should not      20181650
                               else listoption := c="+" else            30265000
             end                                                        30280800
             else error(102);                                           30280810
     if err(102) then                                                   90090710
          write(line,error102mess);                                     90090720
$                                                                       90110000
$                                                                       90111000
    ("102   ***warning only, illegal dollar option."),                  91106900
$# patch 800 for pascal.xvi.o.contains 10 cards.
$: to remove conflicts between heriot-watt & natal existing patches.
$:
       maxsyms    = 800#,    %max number of symbols in one expression.  10052000
       maxpntrs   = 25#;     %max number of undeclared pointers(forwd). 10056000
define err(err1) = boolean(0&errp[(err1).[6:2]][0:((err1).[4:5]):1])#;  10156108
integer exprlevel, expinvarcnt; %                                       40018000
 integer index, ctype, numforwards, tx, i; %                            80403000
integer prognamelength; %                                               90013900
     if err(100) %                                                      90090600
       "; algol file tape=pascrun/disk serial; algol file card=",       90119000
       p(palgolname),"/",p(puser)," serial;", %                         90120000
       " xalgol stack = 2048; end."; %                                  90120500
$# patch 998 for pascal.xvi.o contains 10 cards.  insert page throws at desired
$: patch to insert page throws at desired pointes in the source to produce a
$: nicely laid out listing.
$:
$                                                           page        19000000
$                                                           page        20290000
$                                                           page        29000000
$                                                           page        39000000
$                                                           page        49000000
$                                                           page        59000000
$                                                           page        69000000
$                                                           page        79000000
$                                                           page        89000000
$                                                           page        90070999
$:  nils a otte,   university of natal, durban.    aug - nov 1977.
$:
$# patch 999 for pascal.xvi.o contains 1 cards.  verison number.
$:
define edition = "4.4"#;%august   1978...david a cooper...              10028000

?END

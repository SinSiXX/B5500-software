?execute object/reader
?common = 3
?file newtape = symbol/snobol disk serial
?data card
% $reset list                                                              10000
% b5500 snobol3 system.                                                    20000
%                                                                          30000
% written by:                                                              40000
% john m. chambers                                                         50000
% dept. of computer sciences                                               60000
% univerity of wisconsin                                                   70000
% 1210 w. dayton st.                                                       80000
% madison, wisconsin  53706                                                90000
%                                                                         100000
% users manual available from above address.                              110000
%                                                                         120000
%                                                                         130000
%  data representation:                                                   140000
%                                                                         150000
%  to take advantage of the character mode string compare and move        160000
%  instructions, strings are stored as consecutive chars, preceeded by a  170000
%  3-char back-pointer to the symbol table.  this pointer consists of an  180000
%  "illegal character" followed by 2 chars (12bit) giving a symbol        190000
%  table location (see description of symbtabl).  strings are stored in   200000
%  rows of the array data[*,*].                                           210000
%                                                                         220000
%                                                                         230000
%     due to the size limitation on algol arrays, and the fact that it    240000
%  was felt undesirable to break up a string, there is a limitation to    250000
%  the size of a string--8181 chars, to be exact.  if this limit is       260000
%  exceeded, the procedure string will print a diagnostic and set the     270000
%  flag death to true, terminating the program.                           280000
%     a string is identified by a 31-bit "descriptor"; if d is such a     290000
%  descriptor, the following fields locate the string (see define         300000
%  declarations):                                                         310000
%     d.s: size of string                                                 320000
%     d.r: string is in data[d.r,*]                                       330000
%     d.ch: first char of string, relative to data[d.r,0]                 340000
%  in other words, the string consists of d.s characters, starting d.c    350000
%  charsafter data[d.r,d.w].                                              360000
%     note that, since all strings are preceded by a 3-char pointer       370000
%  to symbtabl, the value of the ch field must be } 3, this fact          380000
%  is used to distinguish cells which have "missing" values (such         390000
%  as the value parts for strings which have not been assigned a          400000
%  value).  thus, if the ch field is < 3, there is no string attached,    410000
%  and the value is considered to be null.  the s field should be 0       420000
%  in such cases.                                                         430000
%     several "bugs" have been found to be caused by not recognizing      440000
%  that a string descriptor may not pointto a string--this can be         450000
%  avoided by testing to see if the ch field is } 3. if so, the           460000
%  string exists; if not, there is no string, and the value is null.      470000
%                                                                         480000
%                                                                         490000
%                                                                         500000
%                                                                         510000
%***********************************************************************  520000
begin                                                                     530000
integer common;     % these bits are currently relevant:                  540000
   % [47:1] = 1 turns of tracing for all variables.                       550000
   % [46:1] = 1 causes a complete dump at the end of run.                 560000
   % [45:1] = 1 says that mode("inform") op -inform is to turn on         570000
   %     system debugging aids.                                           580000
define                                                                    590000
   c=[45:3]#,      % char with in word of string descriptor               600000
   c1=[6:6]#,                                                             610000
   c2=[12:6]#,                                                            620000
   c3=[18:6]#,                                                            630000
   c4=[24:6]#,                                                            640000
   c5=[30:6]#,                                                            650000
   c6=[36:6]#,                                                            660000
   c7=[42:6]#,                                                            670000
   ch=[35:13]#,    % char of data[*,*] row of string descriptor           680000
   cquote4="""[24:42:6]#,    % move quote to char 4                       690000
   cquote5="""[30:42:6]#,    % move quote to char 5                       700000
   concr=[30:43:5]#,    % move to r field                                 710000
   concs=[17:35:13]#,   % move to s field                                 720000
   concw=[35:38:10]#,   % move to w field                                 730000
   controlpoint=inst[instruct],nearpoint#,                                740000
   datasize=31#,        % upper bound on first subscript of data[*,*]     750000
   diskrecord=record#,                                                    760000
   f= false #,                                                            770000
   firstchar(firstchar1)=data[(firstchar1).r,(firstchar1).w],             780000
     (firstchar1).c#,                                                     790000
   intrinsmax=17#,      % max # intrinsic fcts of same size               800000
   maxlabellimit=15#,   % max number of label limits for debugging        810000
   maxlevel=100#,  % maximum allowed depth of function calls              820000
   maxsuspendreason=3#, % number different reasons for suspending.        830000
   mnemmax=20#,                                                           840000
   numcontrolcards=21#, % number of control cards implemented;            850000
   %                      must be changed if new control cards are        860000
   %                      to be implemented                               870000
   r=[30:5]#,      % data[*,*] row of string descriptor                   880000
   rch=[30:18]#,   % r, w, and c fields                                   890000
   s=[17:13]#,     % size of string                                       900000
   segment = label dummy;#,  % for forcing new segment.                   910000
   stacksize=50#,  % size of interpreter stack arrays                     920000
   stringloc(stringloc1)=(stringloc1).s,firstchar(stringloc1)#,           930000
   t= true #,                                                             940000
   temp=aa#,       %                                                      950000
   temp1=ab#,      %                                                      960000
   temp2=ac#,      %                                                      970000
   tempcel(tempcel1) = tempcell#, % parameterno longer use                980000
   version = 3.0#, % version number:                                      990000
   %  2.0  is the rewrittencompiler.                                     1000000
   %  2.1  includes fatal error suspensions when debugging.              1010000
   %  2.2  has most system debugging aids changed to comments.           1020000
   %  3.0 has the array usedcell[*] deleted (changes library files).     1030000
   w=[35:10]#;     % word within data[*,*] row of string descriptor      1040000
define                                                                   1050000
   abort = go to abortion;#,  % fatal system error.                      1060000
   setlimitflag = alimitexists ~                                         1070000
      cpulimitexists or                                                  1080000
      iolimitexists or                                                   1090000
      rulelimitexists or                                                 1100000
      (debugging and                                                     1110000
         (debugrulelimitexists or                                        1120000
         nlabellimit } 0                                                 1130000
         )                                                               1140000
      )                                                                  1150000
      #;                                                                 1160000
boolean                                                                  1170000
   alimitexists,   % there is a limit to check at start of insts.        1180000
   b1,             % temorary boolean "register"                         1190000
   convertf,       % deck is 026 char set                                1200000
   convertstrings, % convert 3600 i/o strings                            1210000
   cpulimitexists, %                                                     1220000
   datacomf,       % data com unit in use                                1230000
   death,          % fatal error has occurred                            1240000
   debugging,      % debug mode in use                                   1250000
   debugrulelimitexists,                                                 1260000
   dmpdata,        % execute writedata at end of run                     1270000
   dmpst,          % execute writest (dump symbol table) at end of run   1280000
   dmpstr,         % execute stringdump at end of run                    1290000
   dumpall,        % true if complete dump to be done at eoj             1300000
   errdump,        % dump if fatal program error                         1310000
   execute,        % set false if fatal error during compilation         1320000
   inform,         % print system debugging messages                     1330000
   iolimitexists,  %                                                     1340000
   loadf,          % loader is being executed                            1350000
   printmessages,  % print diagnostic (warning) messages.                1360000
   result,         % success/fail flag for interpreter                   1370000
   rulelimitexists,%                                                     1380000
   systemdebugging,% true if common.[45:1] = 1                           1390000
   systemerror,    % fatal error by snobol system, not program           1400000
   traceall;       % trace every variable without i/o use                1410000
boolean array                                                            1420000
   suspendreason[0:maxsuspendreason], % reasons for suspending program:  1430000
   %                      0: suspend() was executed                      1440000
   %                      1: rule limit was hit                          1450000
   %                      2: label limit was hit                         1460000
   %                      3: fatal error in program                      1470000
   usedrow[0:datasize]; % data[i,*] is in use                            1480000
integer                                                                  1490000
   anchormode,     % 2: unanchored, 3: anchored                          1500000
   anchorsize,     % for anchored mode, size of inital segment           1510000
   dcsize,         % size of last input from dcread                      1520000
   debugrulelimit,                                                       1530000
   dividemode,     % 0: round; 1: truncation; 2: integer                 1540000
   gcs,            % number of garbage collector calls                   1550000
   i,                                                                    1560000
   i1, i2,         % temporary integer "registers".                      1570000
   j,                                                                    1580000
   level,          % level (or depth) of recursion of the interpreter    1590000
   listspaces,     % number of blank lines between lines of listing      1600000
   loaderlevel,    % level of recursion in loader                        1610000
   maxinstsize,    % size of largest program segment (in chars)          1620000
   nlabellimit,    % number of label limits set at last suspension       1630000
   parencount,     % depth of parenthesis nesting (compile and scan)     1640000
   rw,             % new strings come from data[rw,*] (see string)       1650000
   temprow,        % row of symb table giving temp cells                 1660000
   unit;           % used by i/o routines--file number                   1670000
integer array                                                            1680000
   convertval,     % for char set conversions                            1690000
      dottype,     % partitions chars in internal rep. of arith,         1700000
      oplevel[0:63],    % precedence level of arith ops                  1710000
   dpntr,          % pointer to next available char in data[i,*]         1720000
      notmoved[0:datasize],  % points to first char moved by last call   1730000
      %                        of garbage collector.                     1740000
   months[1:12],   % number of days in each month                        1750000
   rules[0:maxlevel];  % # rules executed at various levels              1760000
real                                                                     1770000
   cpulimit,       % limit to cpu time in seconds.                       1780000
   gctimecp,       % cpu time spend collecting garbage                   1790000
   gctimeio,       % i/o time spend collecting garbage                   1800000
   iolimit,        % limit to i/o time in seconds.                       1810000
   randno,         % number for .randf function                          1820000
   rulelimit,      % limit to number of rules executed,                  1830000
   teenyneg;       % = oct3777777777777777                               1840000
alpha                                                                    1850000
   aa,ab,ac,       % temporary alpha "registers"                         1860000
   arrow,          % = "~"                                               1870000
   blank,          % = " "                                               1880000
   blanks,         % = "       " (8 blanks)                              1890000
   colon,          % = ":"                                               1900000
   comma,          % = ","                                               1910000
   crlf,           % = "{!~"                                             1920000
   eqsign,         % = "="                                               1930000
   qmark,          % illegal char                                        1940000
   quote,          % = """                                               1950000
   printloc,       % symbol table location of print (see code            1960000
                   % for syspot in snblout.)                             1970000
   slash,          % = "/"                                               1980000
   star,           % = "*"                                               1990000
   stopper;        % = blank & quote & qmark (for ending scans.)         2000000
alpha array                                                              2010000
   buffer[0:14],   % used by compiler to hold next input card            2020000
   bufout[0:16],   % for building printer output messages.               2030000
   code[0:1022],                                                         2040000
   controlcard[0:numcontrolcards],  % names of control cards             2050000
   data[0:datasize,0:1022], % string and program storage area            2060000
   intrinsfct[3:7,0:intrinsmax],  % names of intrinsic function.         2070000
   intrinsndx[3:7,1:intrinsmax],  % indices of intrinsic functions.      2080000
   labellimit[0:maxlabellimit],   % symbol table locations of            2090000
   %                    label limits during debugging                    2100000
   mnemonic[0:1,0:mnemmax],  % various mnemonic commands and words       2110000
   nextrecord[0:15,0:17], % holds records for look-type strings          2120000
   scratch[0:1022],    % temporary string array                          2130000
   words[0:30];        % variousalphanumeric strings                     2140000
monitor intovr, expovr, index, flag;                                     2150000
%********symbol table*************************************************** 2160000
%                                                                        2170000
% the symbol table:                                                      2180000
%                                                                        2190000
%                                                                        2200000
% every data object (strings, literal, function, label) requires         2210000
% an entry in the symbol table.  this table consists of the following    2220000
% three array and associated macros:                                     2230000
%                                                                        2240000
define                                                                   2250000
   name[name1] = namtabl[(name1).str,(name1).stw] #,                     2260000
   valu[valu1] = valtabl[(valu1).str,(valu1).stw] #,                     2270000
   io[io1] = iotabl[(io1).str,(io1).stw] #,                              2280000
   strmax = 15 #,      % max first subscript to symb table.              2290000
   stwmax = 255 #;     % max second subscript to symb table.             2300000
alpha array                                                              2310000
   namtabl,                                                              2320000
   valtabl,                                                              2330000
   iotabl[0:strmax,0:stwmax];                                            2340000
%                                                                        2350000
% some more variables associated with the symbol table are:              2360000
%                                                                        2370000
define                                                                   2380000
   ccycle=[9:44:4]#,    % move to cycle field                            2390000
   cfilno=[5:44:4]#,    % move to filno field                            2400000
   cinuse=[3:47:1]#,    %                                                2410000
   ciotype=[14:45:3]#,  % move to iotype field                           2420000
   ciouse=[3:46:2]#,                                                     2430000
   clink=[5:36:12]#,    % move to link field                             2440000
   concstr = [36:44:4] #,                                                2450000
   coutus=[4:47:1]#,    %                                                2460000
   cycle=[9:4]#,        % number times file location used                2470000
   filno=[5:4]#,        % index of associated file                       2480000
   inuse=[3:1]#,        % = 1 if input string                            2490000
   iotype=[14:3]#,      % type of i/o usage:                             2500000
   %                         value      input       output               2510000
   %                           0        illegal     illegal              2520000
   %                           1        i/o         i/o                  2530000
   %                           2        look        trace                2540000
   %                           3        teletype   teletype              2550000
   %                           4        illegal    illegal               2560000
   %                           5        illegal    syspot                2570000
   %                                                                     2580000
   iouse=[3:2]#,   % inuse and outuse fields combined.                   2590000
   link=[5:12]#,   % list links in symbol table.                         2600000
   loc=[17:31]#,   % s, r, w, and c fields (string loc in data[*,*])     2610000
   outuse=[4:1]#,  % = 1 if output string                                2620000
   ovfl=[13:1]#,   % = 1 if overlfow allowed on output                   2630000
   scattersize=75#,% size of scatter areas in symb table.                2640000
   str = [36:4] #,                                                       2650000
   stw = [40:8] #,                                                       2660000
   tcycle=[9:9:4]#,% transfer to cycle field                             2670000
   tfilno=[5:5:4]#,% transfer to filno field                             2680000
   type=[1:2]#;    % type of entry:                                      2690000
   %                 0 = string     2 = function                         2700000
   %                 1 = literal    3 = label                            2710000
boolean                                                                  2720000
   symbtablsetup;      % avsls set up in scatter rows.                   2730000
boolean array                                                            2740000
   usedst[0:strmax];   % true if symb table row in use.                  2750000
integer                                                                  2760000
   scatterno;          % max row index of scatter areas.                 2770000
alpha array                                                              2780000
   templist[0:strmax]; % temp s.t. locs for interpreter.                 2790000
integer array                                                            2800000
   nextcell[0:strmax]; % heads of available space lists.                 2810000
%                                                                        2820000
%                                                                        2830000
% a symbol table entry consists of three words--one word                 2840000
% from each of the tree arrays. a "symbol table address" is a            2850000
% 12-bit integer consisting of two fields called str and stw.            2860000
% the three words associated with an address p can be referred           2870000
% to in the following ways:                                              2880000
%                                                                        2890000
%     name[p] = namtabl[p.str,p.stw] is the name of the object           2900000
%     valu[p] = valtabl[p.str,p.stw] is the value of the object.         2910000
%     io[p] = iotabl[p.str,p.stw] is the i/o use of the object           2920000
%                                                                        2930000
% normally, the first form giving (singly subscripted) is used; the      2940000
% doubly-subscripted forms are used only when the two subscripts         2950000
% have been calculated separately.                                       2960000
%                                                                        2970000
% the symbol table is a scattered-entry, linked-list type of table.      2980000
% entries are scattered into the "scatter areas", which are words 0 to   2990000
% scattersize+15 of rows 0 to scatterno.  that is, the i,j words         3000000
% of the symbol table (namtabl[i,j], valtabl[i,j], iotable[i,j])         3010000
% are in the scatter area if:                                            3020000
%     0 { i { scatterno                                                  3030000
%     0 { j { scattersize+15                                             3040000
% word 0,0 is not included; it is a "non-cell" which should always       3050000
% be filled with zeroes.  the reason for the "+15" is that there         3060000
% are really two scatter areas--one for literals and one for all         3070000
% other types of data objects.  this is to keep the length of            3080000
% lists that must be scanned at run time (for indirection, creating      3090000
% new functions, etc,) as small as possible.  literals are scattered     3100000
% into the [scattersize,scattersize+15] part of each row, and the        3110000
% [0,scattersize) part is for other types of objects.  the part          3120000
% of the symbol table outside of the scatter areas is initialized        3130000
% as available space lists (one per row. the top address given by        3140000
% nextcell[row]).  when several entries scatter into the same            3150000
% location, a linked list is formed into the part of the row that        3160000
% is outside the scatter area.  links through these lists are in         3170000
% the link field of the name part (name[p]).                             3180000
%                                                                        3190000
%  the following fields are used in a symbol table entry:                3200000
%  name[p].type is the type of the entry:                                3210000
%     0 = named string or temporary cell.                                3220000
%     1 = literal                                                        3230000
%     2 = function                                                       3240000
%     3 = label (code segment)                                           3250000
%  name[p] and garbage collector.[3:1] is used by checksymbtabl.         3260000
%  name[p].[4:1] is unused.                                              3270000
%  name[p].link is the link to the next entry that had the same          3280000
%     location in the scatter area.  a zero link is end-of-list.         3290000
%     for temporary cells, the link should be zero.                      3300000
%  name[p].loc points to the name of the object (in data[*,*]),          3310000
%      for literals, this field is zero.                                 3320000
%  valu[p].[1:1] = 1 for progrma-defioned functions, otherwise           3330000
%      it should be zero.                                                3340000
%  valu[p].[2:1] is unused.                                              3350000
%  valu[p].iouse indicates the i/o use, and has two subfields:           3360000
%     valu[p].inuse = 1 for input strings and functions with             3370000
%        the calles being traced.                                        3380000
%     valu[p].outuse = 1 for output strings, labels being traced,        3390000
%        and functions with returns being traced.                        3400000
%  valu[p].link has several uses, depending on the type of the object:   3410000
%     strings: the link field gives the next cell on the push-down       3420000
%     stack.  if zero, there is no push-down stack.                      3430000
%     intrinsic functions:  the index for the case statement in          3440000
%        the interpreter that branches to the function code.             3450000
%     program-defined functions:  the symbol table location of           3460000
%        the entry point.                                                3470000
%     labels: the reference count.  it is bumped by one each time        3480000
%        the label is encountered.                                       3490000
%  valu[p].loc is the location of:                                       3500000
%     strings: the value.                                                3510000
%     literals: ditto.                                                   3520000
%     functions: (program-defined) a string of 2-char pointers to        3530000
%        the symb table location of the formal parameters and            3540000
%        local variables.  for intrinsic functions, this field           3550000
%        is ignored.                                                     3560000
%  io[p].[1:2] is unused.                                                3570000
%  io[p].iouse = valu[p].iouse (redundant).                              3580000
%  io[p].filno is the index to the file arrays for file i/o strings.     3590000
%  io[p].cycle is currently not in use.                                  3600000
%  io[p].ovfl = 1 for output strings when the tails of output strings    3610000
%     too long for a record are to be written on the next record.        3620000
%     normally = 0, which causes truncation of long output strings.      3630000
%  io[p].iotype is the type of i/o operation, as follows:                3640000
%               value     input     output                               3650000
%                 0       illegal   illega                               3660000
%                 1       i/o       i/o                                  3670000
%                 2       look      trace                                3680000
%                 3       teletype  teletype                             3690000
%                 4       illegal   illegal                              3700000
%                 5       illegal   syspot                               3710000
%  io[p].[17:31] is unused.                                              3720000
%********local variables for compiler*********************************** 3730000
boolean                                                                  3740000
   bufferfull, % buffer[*] contains a card.                              3750000
   dclist,     % list prog on teletype.                                  3760000
   gt,         % false at start of compile; true when go-to part reached 3770000
   gtlast,     % last inst had a go-to part                              3780000
   gtf,        % failure exit has been found                             3790000
   gts,        % success exit has been found                             3800000
   lstf,       % list program on line printer file print                 3810000
   pcc,        % list control cards, enve if not lstf                    3820000
   programfromremote,   % program from teletype, not file program        3830000
   punchf;     % punch new program deck                                  3840000
integer                                                                  3850000
   errors,     % number of syntax errors found                           3860000
   fieldsize,  % number of chars per card that are instruction           3870000
   instnum,    % number of inst being compiled                           3880000
   instsize,   % size of inst being compiled                             3890000
   marker,     % first char (qmark) of inst in code[*]                   3900000
   messages,   % number of informative messages printed                  3910000
   p,          % point in inst[*] being compiled                         3920000
   ptr;        % next char in code[*]                                    3930000
integer array                                                            3940000
   backtrack[0:50,0:5],                                                  3950000
   chartype[0:63];                                                       3960000
alpha                                                                    3970000
   nextsegment,% symtabl loc of next labeled instruction                 3980000
   slastlabel; % symtabl loc of last labeled instruction                 3990000
%********local variables for compiler*********************************** 4000000
%********stack arrays*************************************************** 4010000
%  the following arrays constitute the "stack" used by the               4020000
%  compiler and interpreter.  the index of the next word available       4030000
%  is the global integer sp.                                             4040000
boolean array                                                            4050000
   pname[0:stacksize];  % true for named quantities                      4060000
integer array                                                            4070000
   pback,               % link for back reference                        4080000
   pminleft,            % min size of rest of pattern                    4090000
   ppoint,              % pointer to matched substrings                  4100000
   psize,               % size of pattern element                        4110000
   ptype[0:stacksize];  % type of element, as follows;                   4120000
   %                      0: undefined                                   4130000
   %                      1: constant pattern element                    4140000
   %                      2: arbitrary string variable                   4150000
   %                      3: fixed-length variable                       4160000
   %                      4: balanced variable                           4170000
   %                      5: back refernce                               4180000
   %                      6: undefined                                   4190000
   %                      7: numeric value--in pst[i]                    4200000
alpha array                                                              4210000
   ploc,                % scanner only: loc of value of element          4220000
   pst[0:stacksize];    % symbol table address of element                4230000
%********stack arrays*************************************************** 4240000
%********local variables for interpreter******************************** 4250000
% warning: the number of variables in this section must be the same      4260000
% as the number of variables copied in the defined section of function.  4270000
boolean            %                                                     4280000
   backreflag,     %                                                     4290000
   noreplacement,  %                                                     4300000
   nobackorbal,                                                          4310000
   selfreflag,     %                                                     4320000
   success,        %                                                     4330000
   varflag;        %                                                     4340000
integer                                                                  4350000
   count,                                                                4360000
   entry,          % entry point & last label transfered to              4370000
   floc,           % pointer to failure exit./                           4380000
   frontend,                                                             4390000
   increase,                                                             4400000
   instno,                                                               4410000
   instruct,                                                             4420000
   mks,            % "mark stack" pointer                                4430000
   nearpoint,                                                            4440000
   nextsourcerecord,    % disk addr of next available record of source.  4450000
   nopatterns,                                                           4460000
   noreplaces,                                                           4470000
   rearend,                                                              4480000
   refi,                                                                 4490000
   refj,                                                                 4500000
   refloc,                                                               4510000
   refpt,                                                                4520000
   refstep,                                                              4530000
   relativepointer,                                                      4540000
   rpr,                                                                  4550000
   rsize,                                                                4560000
   size,                                                                 4570000
   sloc,            % point to success exit.                             4580000
   sp;                                                                   4590000
alpha                                                                    4600000
   tempref;                                                              4610000
%********local variables for interpreter******************************** 4620000
%********file-handling declarations************************************* 4630000
define filmax = 5 #;    % max number of files                            4640000
boolean array                                                            4650000
   ioeof,          % eof on last i/o operation.                          4660000
   iofileopen,     % true for open files.                                4670000
   lookf[1:filmax];% next record is in nextrecord[i,*].                  4680000
   %                 used with look-type input strings.                  4690000
integer array                                                            4700000
   iosize,                                                               4710000
   iospace,                                                              4720000
   record[1:filmax];                                                     4730000
alpha array                                                              4740000
   iousage[1:filmax];                                                    4750000
file                                                                     4760000
   card(1,10,30);                                                        4770000
file in                                                                  4780000
   program (1,10,30);                                                    4790000
file out                                                                 4800000
   print (1,17),                                                         4810000
   punch (1,10);                                                         4820000
save file out                                                            4830000
   newdisk disk serial [20:600]  (1,10,30,save 15);                      4840000
switch file iofile ~                                                     4850000
   card,       % 0--dummy entry                                          4860000
   card,       % card-image input and output file                        4870000
   program,    % program file for batch jobs; read file                  4880000
   print,      % line printer file                                       4890000
   punch,      % card punch file                                         4900000
   newdisk;    % file for creating new disk files                        4910000
%********file-handling declarations************************************* 4920000
%********switch format messages***************************************** 4930000
switch format  message   ~ ("**missing qoute."),                     %00 4940000
(//"*ignore any output after this--it may be incorrect."//),         %01 4950000
("**unrecognized construct in string reference."),                   %02 4960000
("**unidentifiable punched object."),                                %03 4970000
("**doubly defined exit."),                                          %04 4980000
("**character after s or f in go-to not (."),                        %05 4990000
("**string refernce missing."),                                      %06 5000000
("**unrecognized go-to construct."),                                 %07 5010000
("**illegal label in go-to part."),                                  %08 5020000
("**illegal comma."),                                                %09 5030000
("**parenthesis count non-zero at start of go-to part."),            %10 5040000
("**the only unary operator is ",""","-",""","."),                   %11 5050000
("**extra right parenthesis."),                                      %12 5060000
("**extra arrow or equal sign."),                                    %13 5070000
("**strange use of ",""","/",""","."),                               %14 5080000
("**attempted replacement in value expression."),                    %15 5090000
("**improper arithmetic operand."),                                  %16 5100000
("**error in use of arithmetic operator."),                          %17 5110000
("**parenthesis count at end of instruction non-zero."),             %18 5120000
("**control parameter non-numeric or outside allowed range."),       %19 5130000
(/"**dummy fmt--message[20]"),                                       %20 5140000
("**too many elements in instruction"),                              %21 5150000
("**unrecongnized instruction type."),                               %22 5160000
(/"**dummy fmt--message[23]"),                                       %23 5170000
("**this label has aleady been used; former value lost."),           %24 5180000
(/"**no end card."/),                                                %25 5190000
("**entry point undefined."),                                        %26 5200000
("**missing right parenthesis."),                                    %27 5210000
("**illegal use of literal."),                                       %28 5220000
("**missing operand to arithmetic"),                                 %29 5230000
(/"**dummy fmt--message[30]"),                                       %30 5240000
(/"**dummy fmt--message[31]"),                                       %31 5250000
("**define failure--unknown error in first argument."),              %32 5260000
("**define failure--unknown error in local variable list."),         %33 5270000
("**invalid argument for indirection."),                             %34 5280000
("usedrow[",i2,"] is ",l5,"; dpntr[",i2,"] = ",i5),                  %35 5290000
(x16,"*",10(x4,"*",x4,"*")),                                         %36 5300000
("data[",i2,"] =              "),                                    %37 5310000
("**missing string variable asterisk."),                             %38 5320000
("**missing parameter."),                                            %39 5330000
(///"**compiler screwed up."///),                                    %40 5340000
(/"**data communications file in use**"/),                           %41 5350000
("**program segment too long--insert extra label on preceding"           5360000
   " instruction."),                                                 %42 5370000
("**end of file."),                                                  %43 5380000
("**parity error in "),                                              %44 5390000
(/"**out of space in string storage area."),                         %45 5400000
(/"**out of space in symbol table."),                                %46 5410000
("**illegal use of arrow or equal sign."),                           %47 5420000
("**non-numeric literal in arithmetic."),                            %48 5430000
("**this statement can not be reached."),                            %49 5440000
("**undefined label: "),                                             %50 5450000
(//"**return from function not preceded by call; statement ",            5460000
   "number ",i6),                                                    %51 5470000
("**illegal name for string variable."),                             %52 5480000
("**end format--message.");                                              5490000
%********switch format message****************************************** 5500000
%********switch format ftime******************************************** 5510000
switch format ftime ~                                                    5520000
(/"cpu time = ",f10.1," sec."/"i/o time = ",f10.1," sec."),          %00 5530000
(x25,"b 5 5 0 0     s n o b o l 3     s y s t e m"//                     5540000
   "version ",f3.1/                                                      5550000
   "the date is ",i*," ",a3," 19",a2,/                                   5560000
   "compilation started at ",2(i2,":"),i2),                          %01 5570000
(/"compilation completed at ",2(i2,":"),i2),                         %02 5580000
(/"execution started at ",2(i2,":"),i2),                             %03 5590000
(/"normal exit at ",2(i2,":"),i2,", at level ",i*," in statment ",       5600000
   i*),                                                              %04 5610000
(/"abnormal exit at ",2(i2,":"),i2,", at level ",i*," in statement ",    5620000
   i*),                                                              %05 5630000
(//"**end format--ftime."//);                                            5640000
%********switch format ftime******************************************** 5650000
%*********************************************************************** 5660000
%********various formats************************************************ 5670000
format % not generally used by most programs:                            5680000
   f80a1 (80a1),                                                         5690000
   fclosedr ("**attempt to read from closed file:"),                     5700000
   fclosedw ("**attempt to write to closed file:"),                      5710000
   fcrlf ("{!~"),                                                        5720000
   fendprog ("**end of program file "),                                  5730000
   ffixvarsize ("**illegal size ",""",x*,"""," for fixed-length ",       5740000
      "variable in statement ",i6),                                      5750000
   fgc (//"**garbage collector ",10("*******")),                         5760000
   fgcres (/"*garbage collector results:"/                               5770000
      i5," rows collected"/                                              5780000
      i5," chars in longest row"/                                        5790000
      i5," chars total"/),                                               5800000
   fgcs (/"garbage collector called ",i*," times; used ",f*.1,           5810000
     " sec cpu time, ",f*.1," sec i/o time."),                           5820000
   fnofile ("**file not available."),                                    5830000
   fo (o),                                                               5840000
   fparity ("**irrecoverable parity error on"),                          5850000
   frules ("**number of rules executed = ",i8),                          5860000
   fsendcopy ("**send copy of program to system authors."),              5870000
   ftrace ("*s",i5,x1,x*," = ","""),                                     5880000
   ftracefctcall ("*c",i5,x1,x*,"("),                                    5890000
   ftracefctret ("*r",i5,x1,x*,"() = ","""),                             5900000
   ftracel ("*l  ",x*,i*,*(" from ",i*)),                                5910000
   fundeffct ("**undefined function called:"),                           5920000
   fundeflabel ("**attempted transfer to undefined label ");             5930000
format   % for use with createlibrary and loadlibrary.                   5940000
   flib0("snobol library file ",i1),                                     5950000
   flib1 (i1,i4,3(l1,o)),                                                5960000
   flib2 (a2,16l1,i6),                                                   5970000
   flib3 (165a2),                                                        5980000
   flib4 (6o),                                                           5990000
   flib5 (32l1),                                                         6000000
   flib6 (12i4),                                                         6010000
   fliboldlp("**library file incompatible with this version of snobol"), 6020000
   fliboldtt("{!library file incompatable with this version of snobol",  6030000
      "{!~");                                                            6040000
format  % used during most runs:                                         6050000
   fasterisks (/1023("**********")),                                     6060000
   fbl ((x8)),                                                           6070000
   fdbl (*(/)),                                                          6080000
   ferrs (i*," syntax errors detected"),                                 6090000
   fi7 (i7),                                                             6100000
   fi16 (i16),                                                           6110000
   fint (*d,x*,i*),                                                      6120000
   fnum (x*,i*);                                                         6130000
format % used with teletypes                                             6140000
   fagain ("{!try again{!~"),                                            6150000
   fdksearch (x*,"/",x*,":",3i1,4(":",i*)),                              6160000
   feh ("{!eh",a1,"{!~"),                                                6170000
   ffromremote ("{!do you want to type a program",a1,"{!~"),             6180000
   fnoinput ("{!!waiting time up--do you wish to continue",a1,"{!~"),    6190000
   fstat (*(":(",2(i*,"/",i*,":"),8i1,")")),                             6200000
   fttaddr (i*,"/",i*),                                                  6210000
   ftthello ("{!snobol version ",f3.1",{!~"),                            6220000
   fyesorno ("{!type yes or no.{!~"),                                    6230000
   fvcrlf (x*,"{!~");                                                    6240000
format   % used with dump procedures                                     6250000
   fstackhead (/"**the stack is:"/                                       6260000
      "  word type st name ....loc.... size point minleft back"),        6270000
   fstackentry (i6,i4,x2,a2,x3,l1,x1,i4,x1,i2,x1,i4,i5,i6,i8,i5);        6280000
%*********************************************************************** 6290000
%*********************************************************************** 6300000
%========== begin data com global declarations ========================= 6310000
define                                                                   6320000
   dcinchar =28#,                                                        6330000
   nbufin =4#,                                                           6340000
   bufinsize =5#,                                                        6350000
   dcoutchar =28#,                                                       6360000
   nbufout =5#,                                                          6370000
   bufoutsize =5#,                                                       6380000
   msgsize = 250 #,                                                      6390000
   anssize = 250 #,        % max # of chars in output string             6400000
   ttmax = 15 #;           % max # of teltypes allowed.                  6410000
alpha array                                                              6420000
   dcread[0:(msgsize-1).w],                                              6430000
   dcwrite[0:(anssize-1).w],                                             6440000
   id,                  % i. d. of user of teletype                      6450000
      stat[0:ttmax];    % status of teletype                             6460000
alpha file in  dcin  14 ( nbufin, bufinsize);                            6470000
alpha file out dcout 14 (nbufout,bufoutsize);                            6480000
integer                                                                  6490000
   mainuser,   % teletype currently in charge                            6500000
   numusers,   % number of teletypes attached.                           6510000
   user;       % teletype currently being talkedto                       6520000
real                                                                     6530000
   waittime;                                                             6540000
boolean break;                                                           6550000
%========== end data com global declarations =========================== 6560000
begin    % global stream procedures                                      6570000
%********absaddr******************************************************** 6580000
integer stream procedure absaddr(a);                                     6590000
begin si ~ a; absaddr ~ si; end;                                         6600000
%********absaddr******************************************************** 6610000
%*********************************************************************** 6620000
comment char returns the pth character of name, right justified;         6630000
integer stream procedure char(name,p);                                   6640000
value p;                                                                 6650000
%                                                                        6660000
%                                                                        6670000
begin si ~ name;                                                         6680000
si ~ si + p;                                                             6690000
di ~ loc char; di ~ di + 7;                                              6700000
ds ~ 1 chr;                                                              6710000
end;                                                                     6720000
%*********************************************************************** 6730000
%********eq************************************************************* 6740000
boolean stream procedure eq(n,l1,i1,l2,i2);                              6750000
value n, i1, i2;                                                         6760000
begin si ~ l1; si ~ si + i1;                                             6770000
di ~ l2; di ~ di + i2;                                                   6780000
n(if 1 sc ! dc then jump out);                                           6790000
if toggle then tally ~ 0 else tally ~ 1;                                 6800000
eq ~ tally;                                                              6810000
end eq;                                                                  6820000
%********eq************************************************************* 6830000
%********equal********************************************************** 6840000
% equal returns true if the n chars starting at the i1th char after l1   6850000
% are the same as the n chars starting at the l2th char after l2. i1     6860000
% and i2 must be } 0 and { 63.                                           6870000
boolean stream procedure equal(n,l1,i1,l2,i2);                           6880000
value n, i1, i2;                                                         6890000
%                                                                        6900000
%                                                                        6910000
begin local na, nb;                                                      6920000
label l;                                                                 6930000
si ~ loc n; si ~ si + 5;                                                 6940000
di ~ loc na; di ~ di + 7; ds ~ 1 chr;                                    6950000
di ~ loc nb; di ~ di + 7; ds ~ 1 chr;                                    6960000
si ~ l1;                                                                 6970000
si ~ si + i1;                                                            6980000
di ~ l2;                                                                 6990000
di ~ di + i2;                                                            7000000
na(16(32(if 8 sc ! dc then jump out 3 to l)));                           7010000
nb(8(if 8 sc ! dc then jump out 2 to l));                                7020000
n(if 1 sc ! dc then jump out);                                           7030000
l:  if toggle then tally ~ 0 else tally ~ 1;                             7040000
equal ~ tally;                                                           7050000
end;                                                                     7060000
%********equal********************************************************** 7070000
begin % move stream procedures                                           7080000
%********mv************************************************************* 7090000
stream procedure mv(n,l1,i1,l2,i2);                                      7100000
value n, i1, i2;                                                         7110000
begin si ~ l1; si ~ si + i1;                                             7120000
di ~ l2; di ~ di + i2;                                                   7130000
ds ~ n chr;                                                              7140000
end mv;                                                                  7150000
%********mv************************************************************* 7160000
%********move*********************************************************** 7170000
stream procedure move(n,source,i1,dest,i2);                              7180000
%                                                                        7190000
value n, i1, i2;                                                         7200000
begin local na, nb;                                                      7210000
si ~ loc n; si ~ si + 5;                                                 7220000
di ~ loc na; di ~ di + 7 ; ds ~ 1 chr;                                   7230000
di ~ loc nb; di ~ di + 7 ; ds ~ 1 chr;                                   7240000
si ~ source;                                                             7250000
si ~ si + i1;                                                            7260000
di ~ dest;                                                               7270000
di ~ di + i2;                                                            7280000
na(4(32(ds ~ 32 chr)));                                                  7290000
nb(2(ds ~ 32 chr));                                                      7300000
ds ~ n chr;                                                              7310000
end move;                                                                7320000
%********move*********************************************************** 7330000
%********movewds******************************************************** 7340000
stream procedure movewds(n,l1,l2); value n;                              7350000
begin local na;                                                          7360000
si ~ loc n; si ~ si + 6;                                                 7370000
di ~ loc na; di ~ di + 7; ds ~ 1 chr;                                    7380000
si ~ l1; di ~ l2;                                                        7390000
na(2(ds ~ 32 wds)); n(ds ~ 1 wds);                                       7400000
end movewds;                                                             7410000
%********movewds******************************************************** 7420000
%********moveword******************************************************* 7430000
stream procedure moveword(a,b); value a, b;                              7440000
begin si ~ a; di ~ b; ds ~ 1 wds; end;                                   7450000
%********moveword******************************************************* 7460000
begin % scan stream procedures                                           7470000
%********scanchar******************************************************* 7480000
% scanchar returns the number of chars from the ith char after l         7490000
% (0 { i { 63) to the first occurence of either c1 or c2.                7500000
integer stream procedure scanchar(c1,c2,l,i); value c1,c2,i;             7510000
begin local p1, p2, p3, temp;                                            7520000
label cherche,trouve;                                                    7530000
si ~ l; si ~ si + i;                                                     7540000
di ~ loc c1; di ~ di + 7;                                                7550000
cherche: if 1 sc = dc then go to trouve;                                 7560000
   temp ~ di; di ~ loc c2;                                               7570000
   di ~ di + 7; si ~ si - 1;                                             7580000
   if 1 sc = dc then go to trouve;                                       7590000
   di ~ temp;                                                            7600000
   di ~ di - 1;                                                          7610000
   tally ~ tally + 1;                                                    7620000
temp ~ si;                                                               7630000
p3 ~ tally; si ~ loc p3; si ~ si + 7;                                    7640000
if sc ! "0" then                                                         7650000
   begin si ~ temp; go to cherche; end;                                  7660000
tally ~ p2; tally ~ tally + 1;                                           7670000
p2 ~ tally; si ~ loc p2; si ~ si + 7;                                    7680000
if sc ! "0" then                                                         7690000
   begin tally ~ 0;                                                      7700000
   si ~ temp; go to cherche;                                             7710000
   end;                                                                  7720000
tally ~ p1; tally ~ tally + 1;                                           7730000
p1 ~ tally; tally ~ 0;                                                   7740000
si ~ temp;                                                               7750000
go to cherche;                                                           7760000
trouve:                                                                  7770000
   di ~ loc scanchar; di ~ di + 5;                                       7780000
   si ~ loc p1; si ~ si + 7; ds ~ 1 chr;                                 7790000
   si ~ loc p2; si ~ si + 7; ds ~ 1 chr;                                 7800000
   si ~ loc p3; si ~ si + 7; ds ~ 1 chr;                                 7810000
end scanchar;                                                            7820000
%********scanchar******************************************************* 7830000
%********skipchar******************************************************* 7840000
integer stream procedure skipchar(c,l,i); value c,i;                     7850000
%                                                                        7860000
begin local p1, p2, p3, temp;                                            7870000
label cherche,trouve;                                                    7880000
si ~ l; si ~ si + i;                                                     7890000
di ~ loc c; di ~ di + 7;                                                 7900000
cherche: if 1 sc ! dc then go to trouve;                                 7910000
   di ~ di - 1;                                                          7920000
   tally ~ tally + 1;                                                    7930000
temp ~ si;                                                               7940000
p3 ~ tally; si ~ loc p3; si ~ si + 7;                                    7950000
if sc ! "0" then                                                         7960000
   begin si ~ temp; go to cherche; end;                                  7970000
tally ~ p2; tally ~ tally + 1;                                           7980000
p2 ~ tally; si ~ loc p2; si ~ si + 7;                                    7990000
if sc ! "0" then                                                         8000000
   begin tally ~ 0;                                                      8010000
   si ~ temp; go to cherche;                                             8020000
   end;                                                                  8030000
tally ~ p1; tally ~ tally + 1;                                           8040000
p1 ~ tally; tally ~ 0;                                                   8050000
si ~ temp;                                                               8060000
go to cherche;                                                           8070000
trouve:                                                                  8080000
   di ~ loc skipchar; di ~ di + 5;                                       8090000
   si ~ loc p1; si ~ si + 7; ds ~ 1 chr;                                 8100000
   si ~ loc p2; si ~ si + 7; ds ~ 1 chr;                                 8110000
   si ~ loc p3; si ~ si + 7; ds ~ 1 chr;                                 8120000
end skipchar;                                                            8130000
%********skipchar******************************************************* 8140000
%*********************************************************************** 8150000
%  cardtype returns a number identifying the type of instruction         8160000
%  being compiled--the types are:                                        8170000
%     1  comment                                                         8180000
%     2  continuation                                                    8190000
%     3  control card                                                    8200000
%     4  end                                                             8210000
%     5  unlabeled                                                       8220000
%     6  labeled                                                         8230000
integer stream procedure cardtype(card);                                 8240000
begin si ~ card;                                                         8250000
if sc = "*" then tally ~ 1 else                                          8260000
if sc = "%" then tally ~ 1 else                                          8270000
if sc = "." then tally ~ 2 else                                          8280000
if sc = "-" then tally ~ 3 else                                          8290000
if sc = "e" then                                                         8300000
   begin si ~ si + 1;                                                    8310000
   if sc = "n" then                                                      8320000
      begin si ~ si + 1;                                                 8330000
      if sc = "d" then                                                   8340000
         begin si ~ si + 1;                                              8350000
         if sc = " " then tally ~ 4 else tally ~ 6;                      8360000
         end else tally ~ 6;                                             8370000
      end else tally ~ 6;                                                8380000
   end else                                                              8390000
if sc = " " then tally ~ 5 else tally ~ 6;                               8400000
cardtype ~ tally;                                                        8410000
end type;                                                                8420000
%********cardtype******************************************************* 8430000
begin    % algol procedures                                              8440000
%********forward declarations******************************************* 8450000
procedure clear(ar,n);                                                   8460000
   value n; integer n;                                                   8470000
   alpha array ar[0];                                                    8480000
   forward;                                                              8490000
boolean procedure combinearithmetic(i);                                  8500000
   value i;                                                              8510000
   integer i;                                                            8520000
   forward;                                                              8530000
procedure combinefunction(mks);                                          8540000
   value mks;                                                            8550000
   integer mks;                                                          8560000
   forward;                                                              8570000
boolean procedure combinegotopart(mks);                                  8580000
   value mks;                                                            8590000
   integer mks;                                                          8600000
   forward;                                                              8610000
boolean procedure combinegroup(mks,con);                                 8620000
   value mks, con;                                                       8630000
   integer mks;                                                          8640000
   boolean con;                                                          8650000
   forward;                                                              8660000
boolean procedure combineindirection(mks);                               8670000
   value mks;                                                            8680000
   integer mks;                                                          8690000
   forward;                                                              8700000
boolean procedure combinestrvarname(mks);                                8710000
   value mks;                                                            8720000
   integer mks;                                                          8730000
   forward;                                                              8740000
procedure compile(inst);                                                 8750000
   alpha array inst[0];                                                  8760000
   forward;                                                              8770000
integer procedure controlparameter(a,p);                                 8780000
   alpha array a[0];                                                     8790000
   integer p;                                                            8800000
   forward;                                                              8810000
procedure convert(a);                                                    8820000
   alpha array a[0];                                                     8830000
   forward;                                                              8840000
alpha procedure date;                                                    8850000
   forward;                                                              8860000
procedure debug(l);                                                      8870000
   value l;                                                              8880000
   label l;                                                              8890000
   forward;                                                              8900000
integer procedure digits(n);                                             8910000
   value n;                                                              8920000
   real n;                                                               8930000
   forward;                                                              8940000
alpha procedure enterst(n,l,p,x);                                        8950000
   value n, p, x;                                                        8960000
   integer n, p;                                                         8970000
   alpha array l[0];                                                     8980000
   alpha x;                                                              8990000
   forward;                                                              9000000
procedure findusers;                                                     9010000
   forward;                                                              9020000
procedure garbagecollector;                                              9030000
   forward;                                                              9040000
procedure indirect(sp);                                                  9050000
   value sp;                                                             9060000
   integer sp;                                                           9070000
   forward;                                                              9080000
procedure inform0(i);                                                    9090000
   value i;                                                              9100000
   integer i;                                                            9110000
   forward;                                                              9120000
procedure informa(i,p);                                                  9130000
   value i, p;                                                           9140000
   integer i; alpha p;                                                   9150000
   forward;                                                              9160000
procedure informi(i,p);                                                  9170000
   value i, p;                                                           9180000
   integer i, p;                                                         9190000
   forward;                                                              9200000
procedure informia(i,p1,p2);                                             9210000
   value i, p1, p2;                                                      9220000
   integer i, p1;                                                        9230000
   alpha p2;                                                             9240000
   forward;                                                              9250000
procedure informii(i,p1,p2);                                             9260000
   value i, p1, p2;                                                      9270000
   integer i, p1, p2;                                                    9280000
   forward;                                                              9290000
procedure initializesymbtabl;                                            9300000
   forward;                                                              9310000
boolean procedure input;                                                 9320000
   forward;                                                              9330000
procedure insertstringconvert(sp);                                       9340000
   value sp;                                                             9350000
   integer sp;                                                           9360000
   forward;                                                              9370000
procedure interpreter;                                                   9380000
   forward;                                                              9390000
integer procedure intrinsic(l,p,s);                                      9400000
   value p, s;                                                           9410000
   alpha array l[0];                                                     9420000
   integer p, s;                                                         9430000
   forward;                                                              9440000
procedure loader(f);                                                     9450000
   file f;                                                               9460000
   forward;                                                              9470000
procedure lst(a);                                                        9480000
   alpha array a[0];                                                     9490000
   forward;                                                              9500000
procedure message0(i);                                                   9510000
   value i;                                                              9520000
   integer i;                                                            9530000
   forward;                                                              9540000
procedure messageai(i,p1,p2);                                            9550000
   value i, p1, p2;                                                      9560000
   integer i, p2;                                                        9570000
   alpha p1;                                                             9580000
   forward;                                                              9590000
procedure messagei(i,p);                                                 9600000
   value i, p;                                                           9610000
   integer i, p;                                                         9620000
   forward;                                                              9630000
procedure messagett0(i);                                                 9640000
   value i;                                                              9650000
   integer i;                                                            9660000
   forward;                                                              9670000
procedure messagetta(i,p1);                                              9680000
   value i, p1;                                                          9690000
   integer i;                                                            9700000
   alpha p1;                                                             9710000
   forward;                                                              9720000
procedure messagettai(i,p1,p2);                                          9730000
   value i, p1, p2;                                                      9740000
   integer i, p2;                                                        9750000
   alpha p1;                                                             9760000
   forward;                                                              9770000
procedure messagetti(i,p);                                               9780000
   value i, p;                                                           9790000
   integer i, p;                                                         9800000
   forward;                                                              9810000
integer procedure mnemno(n, a, p);                                       9820000
   value n;                                                              9830000
   integer n, p;                                                         9840000
   array a[0];                                                           9850000
   forward;                                                              9860000
alpha procedure newcell(i);                                              9870000
   value i;                                                              9880000
   integer i;                                                            9890000
   forward;                                                              9900000
procedure newstrow(i);                                                   9910000
   value i;                                                              9920000
   integer i;                                                            9930000
   forward;                                                              9940000
boolean procedure nullargs(n);                                           9950000
   value n;                                                              9960000
   integer n;                                                            9970000
   forward;                                                              9980000
boolean procedure numval(st,val);                                        9990000
   value st;                                                            10000000
   alpha st;                                                            10010000
   integer val;                                                         10020000
   forward;                                                             10030000
boolean procedure output;                                               10040000
   forward;                                                             10050000
boolean procedure pop(stloc);                                           10060000
   value stloc;                                                         10070000
   alpha stloc;                                                         10080000
   forward;                                                             10090000
procedure processcontrolcard(a);                                        10100000
   alpha array a[0];                                                    10110000
   forward;                                                             10120000
boolean procedure push(s,t);                                            10130000
   value s, t; alpha s, t;                                              10140000
   forward;                                                             10150000
procedure returncell(l);                                                10160000
   value l; alpha l;                                                    10170000
   forward;                                                             10180000
procedure returntemps;                                                  10190000
   forward;                                                             10200000
alpha procedure scatter(size,loc,p,x);                                  10210000
   value size, p, x;                                                    10220000
   integer size,p;                                                      10230000
   alpha array loc[0];                                                  10240000
   alpha x;                                                             10250000
   forward;                                                             10260000
alpha procedure searchst(n,l,p,x);                                      10270000
   value n, p, x;                                                       10280000
   integer n, p;                                                        10290000
   alpha array l[0];                                                    10300000
   alpha x;                                                             10310000
   forward;                                                             10320000
boolean procedure snbldefine(st1,st2,st3);                              10330000
   value st1, st2, st3;                                                 10340000
   alpha st1, st2, st3;                                                 10350000
   forward;                                                             10360000
boolean procedure snblin(st);                                           10370000
   value st;                                                            10380000
   alpha st;                                                            10390000
   forward;                                                             10400000
boolean procedure snblout(st);                                          10410000
   value st;                                                            10420000
   alpha st;                                                            10430000
   forward;                                                             10440000
procedure storechars(n,l,i);                                            10450000
   value n, i;                                                          10460000
   integer n, i;                                                        10470000
   alpha l;                                                             10480000
   forward;                                                             10490000
alpha procedure string(n,stloc);                                        10500000
   value n, stloc;                                                      10510000
   integer n; alpha stloc;                                              10520000
   forward;                                                             10530000
procedure stringdump(n);                                                10540000
   value n;                                                             10550000
   integer n;                                                           10560000
   forward;                                                             10570000
procedure syntaxerr(n,p);                                               10580000
   value n, p;                                                          10590000
   integer n, p;                                                        10600000
   forward;                                                             10610000
alpha procedure tempcell;                                               10620000
   forward;                                                             10630000
alpha procedure tempval(i);                                             10640000
   value i;                                                             10650000
   integer i;                                                           10660000
   forward;                                                             10670000
boolean procedure tracefctcall(f);                                      10680000
   value f;                                                             10690000
   integer f;                                                           10700000
   forward;                                                             10710000
boolean procedure tracefctreturn(f,suc);                                10720000
   value f, suc;                                                        10730000
   integer f;                                                           10740000
   boolean suc;                                                         10750000
   forward;                                                             10760000
integer procedure ttindex(st);                                          10770000
   value st;                                                            10780000
   alpha st;                                                            10790000
   forward;                                                             10800000
boolean procedure writebuff(bufout,p,size);                             10810000
   value size;                                                          10820000
   integer p, size;                                                     10830000
   array bufout[0];                                                     10840000
   forward;                                                             10850000
procedure writedata;                                                    10860000
   forward;                                                             10870000
procedure writeinst;                                                    10880000
   forward;                                                             10890000
procedure writest;                                                      10900000
   forward;                                                             10910000
procedure writestack(n);                                                10920000
   value n;                                                             10930000
   integer n;                                                           10940000
   forward;                                                             10950000
procedure writetime(f,n);                                               10960000
   value f, n;                                                          10970000
   integer f, n;                                                        10980000
   forward;                                                             10990000
label                                                                   11000000
   abortion,       % fatal system error                                 11010000
   endofrun,       % final dumps, if any                                11020000
   endterpret;     % transferred to at end or fatal error               11030000
%********checkoutuse****************************************************11040000
boolean procedure checkoutuse(st);                                      11050000
value st; alpha st;                                                     11060000
checkoutuse ~ if boolean(valtabl[st.str,st.stw].outuse)                 11070000
   then snblout(st) else true;                                          11080000
%********checkoutuse****************************************************11090000
%********checksymbtabl**************************************************11100000
%  checksymtabl looks for symbol table entries which point to strings   11110000
%  not preceded by a pointer back to the same symtabl location.  if     11120000
%  any such entries are found, an error message is printed and          11130000
%  the job is terminated abnormally (with a complete dump).             11140000
procedure checksymbtabl;                                                11150000
begin integer i, j, k, rw, chr, p;                                      11160000
boolean urk;                                                            11170000
alpha aa;                                                               11180000
format ff(/"**symbtabl location ",a2," is not pointed to by its string" 11190000
   " at data[",i2,",*]+ ",i4," chars."),                                11200000
   fpush (//"**push-down stack into available space list at ",a2),      11210000
   fg (/"**symbtabl location zero has been altered.");                  11220000
urk ~ false;                                                            11230000
if namtabl[0,0]!0 or valtabl[0,0]!0 then                                11240000
   begin write(print,fg);                                               11250000
   urk ~ true;                                                          11260000
   end;                                                                 11270000
for i ~ 0 step 1 while i { strmax and usedst[i] do                      11280000
   begin j ~ nextcell[i].stw;                                           11290000
   if j ! 0 then do                                                     11300000
      begin namtabl [i,j].[3:1] ~ 1;                                    11310000
      j ~ (namtabl[i,j].link).stw;                                      11320000
      end until j = 0 or j } strmax;                                    11330000
   for j ~ 0 step 1 until stwmax do                                     11340000
      begin                                                             11350000
      for aa ~ namtabl[i,j],valtabl[i,j] do if aa.ch > 3 then           11360000
         % check strings for back-pointers                              11370000
         begin rw ~ temp.r;                                             11380000
         chr ~ temp.ch - 2;                                             11390000
         mv(2,data[rw,chr.w],chr.c,p,6);                                11400000
         if i ! p.str or j ! p.stw then                                 11410000
            begin write(print,ff,j&i concstr,rw,chr+2);                 11420000
            urk ~ true;                                                 11430000
            end;                                                        11440000
         end;                                                           11450000
      if namtabl[i,j].[1:2]=0 then % string--check push-down stack      11460000
         begin                                                          11470000
      aa ~ valtabl[i,j].link;                                           11480000
      while aa ! 0 do                                                   11490000
         begin if boolean(name[aa].[3:1]) then                          11500000
            begin write(print,fpush,aa);                                11510000
            urk ~ true;                                                 11520000
            end;                                                        11530000
         aa ~ valu[aa].link;                                            11540000
         end;                                                           11550000
         end;                                                           11560000
      end;                                                              11570000
   end;                                                                 11580000
if urk then abort;                                                      11590000
end checksymbtabl;                                                      11600000
%********checksymbtabl**************************************************11610000
%********clear**********************************************************11620000
procedure clear(ar,n); value n; alpha array ar[0]; integer n;           11630000
for n ~ n - 1 while n } 0 do move(8,blanks,0,ar[n],0);                  11640000
%********clear**********************************************************11650000
%********combinearithmetic**********************************************11660000
boolean procedure combinearithmetic(i);                                 11670000
   value i;                                                             11680000
   integer i;                                                           11690000
begin                                                                   11700000
label faut, fin, unary;                                                 11710000
integer j, k, levop, n;                                                 11720000
% if inform then inform0(20);                                           11730000
combinearithmetic ~ false;                                              11740000
if i+1 } sp then                                                        11750000
   begin syntaxerr(29,ploc[i]);                                         11760000
   go to fin;                                                           11770000
   end;                                                                 11780000
if i + 2 < sp then if ptype[i+2] = 7 then                               11790000
   if oplevel[pst[i+2]] > levop~oplevel[pst[i]] then                    11800000
      if not combinearithmetic(i+2) then go to fin;                     11810000
j ~ i;                                                                  11820000
do j ~ j-1 until if j < pback[i] then true else ptype[j]!0;             11830000
if j < pback[i] then go to unary;                                       11840000
for k ~ j, i+1 do                                                       11850000
   case ptype[k] of                                                     11860000
      begin go to faut;                                                 11870000
   % 1: string name                                                     11880000
   ;                                                                    11890000
   % 2: function name:                                                  11900000
      go  to if k=j then unary else faut;                               11910000
   % 3: literal                                                         11920000
      ;                                                                 11930000
   % 4: "(" of group                                                    11940000
      go to if k=j then unary else faut;                                11950000
   % 5: string variable                                                 11960000
      begin syntaxerr(16,ploc[k]);                                      11970000
      go to fin;                                                        11980000
      end;                                                              11990000
   % 6: indirection, uncombined                                         12000000
      if not combineindirection(k) then go to fin;                      12010000
   % 7: consecutive arithmetic operators                                12020000
      begin syntaxerr(16,ploc[k]);                                      12030000
      go to fin;                                                        12040000
      end;                                                              12050000
   % 8: "/" of fixed-length var                                         12060000
      go to if k=j then unary else faut;                                12070000
   % 9: str ref, pattern & replacement                                  12080000
      go to faut;                                                       12090000
   % 10: indirection combined                                           12100000
      ;                                                                 12110000
   % 11: not in use                                                     12120000
      go to faut;                                                       12130000
   % 12: not in use                                                     12140000
      go to faut;                                                       12150000
   % 13: "*" of str var                                                 12160000
      begin syntaxerr(16,ploc[k]);                                      12170000
      go to fin;                                                        12180000
      end;                                                              12190000
   % 14: label in go-to part                                            12200000
      go to faut;                                                       12210000
   % 15: expression                                                     12220000
      ;                                                                 12230000
   % 16: arith expr                                                     12240000
      ;                                                                 12250000
   % 17: "*(" of bal var                                                12260000
       go to faut;                                                      12270000
   % 18: str ref & pattern                                              12280000
       go to faut;                                                      12290000
   % 19: complete arith expr-- remove string convert                    12300000
       psize[k] ~ psize[k] - 2;                                         12310000
   % 20: "s(",, "f(", or "(" of go-to part                              12320000
       go to faut;                                                      12330000
   % 21: combined go-to part                                            12340000
       go to faut;                                                      12350000
       end cases;                                                       12360000
n ~ 0;                                                                  12370000
for k ~ j, i+1, i do                                                    12380000
   begin move(psize[k],code[ppoint[k].w],ppoint[k].c,scratch[n.w],n.c); 12390000
   n ~ n + psize[k];                                                    12400000
   ptype[k] ~ 0;                                                        12410000
   end;                                                                 12420000
move(n,scratch[*],0,code[ppoint[j].w],ppoint[j].c);                     12430000
psize[j] ~ n;                                                           12440000
ptype[j] ~ 16; % incomplete arith expr                                  12450000
combinearithmetic ~ true;                                               12460000
go to fin;                                                              12470000
faut:                                                                   12480000
   writeinst;                                                           12490000
   syntaxerr(40,0);                                                     12500000
   write(print,17,code[*]);                                             12510000
   writestack(sp);                                                      12520000
   systemerror ~ true;                                                  12530000
   go to fin;                                                           12540000
unary:                                                                  12550000
   if pst[i] = "-" then                                                 12560000
      begin move(k~psize[i+1],code[(J~ppoint[i+1]).w],j.c,scratch[*],0);12570000
      aa ~ ".N";                                                        12580000
      mv(2,aa,6,scratch[k.w],k.c);                                      12590000
      move(k+2,scratch[*],0,code[(j~ppoint[i]).w],j.c);                 12600000
      ptype[i+1] ~ 0;                                                   12610000
      ptype[i] ~ 16; % arith expr--no string convert                    12620000
      psize[i] ~ k+2;                                                   12630000
      combinearithmetic ~ true;                                         12640000
      go to fin;                                                        12650000
      end else                                                          12660000
   % cant be as unary:                                                  12670000
      begin syntaxerr(11,ploc[i]);                                      12680000
      go to fin;                                                        12690000
      end;                                                              12700000
fin:                                                                    12710000
   if systemerror then inform0(20);                                     12720000
   % if inform then writeinst;                                          12730000
end combinearithmetic;                                                  12740000
%********combinearithmetic**********************************************12750000
%********combinefunction************************************************12760000
procedure combinefunction(mks);                                         12770000
   value mks;                                                           12780000
   integer mks;                                                         12790000
begin integer i, j, n;                                                  12800000
% if inform then inform0(25);                                           12810000
n ~ j ~ 0;                                                              12820000
for i ~ mks+1 step 1 until sp-1 do if ptype[i] ! 0 then                 12830000
   begin move(psize[i],code[ppoint[i].w],ppoint[i].c,scratch[j.w],j.c); 12840000
   i ~ i;                                                               12850000
   j ~ j + psize[i];                                                    12860000
   ptype[i] ~ 0;   % wipe out element                                   12870000
   n ~ n + 1;                                                           12880000
   end;                                                                 12890000
mv(3,code[(i~ppoint[mks]).w],i.c,scratch[j.w],j.c);                     12900000
mv(1,n,7,scratch[j.w],j.c+3);                                           12910000
move(j+4,scratch[*],0,code[i.w],i.c);                                   12920000
ptype[mks] ~ 15;   % expression                                         12930000
pname[mks] ~ false;                                                     12940000
ptr ~ i + (psize[mks]~j+4);                                             12950000
% if inform then writeinst;                                             12960000
end combinefunction;                                                    12970000
%********combinefunction************************************************12980000
%********combinegotopart************************************************12990000
boolean procedure combinegotopart(mks);                                 13000000
   value mks;                                                           13010000
   integer mks;                                                         13020000
begin                                                                   13030000
label fail, faut, fin;                                                  13040000
integer i, m;                                                           13050000
% if inform then inform0(24);                                           13060000
if ptype[mks] ! 20 then go to faut;                                     13070000
m ~ mks + 1;                                                            13080000
if ptype[m] = 6 then % indirection                                      13090000
   begin                                                                13100000
   % get number of indirections:                                        13110000
   i ~ char(code[ppoint[m].w],ppoint[m].c+1);                           13120000
   if i > 1 then                                                        13130000
      begin i ~ i - 1;                                                  13140000
      mv(1,i,7,code[ppoint[m].w],ppoint[m].c+1); % decrease by 1        13150000
      if not combineindirection(m) then go to fail;                     13160000
      end else     % move back to m:                                    13170000
      begin ptype[m+1] ~ 0;                                             13180000
      ppoint[m] ~ ppoint[m+1];                                          13190000
      ploc[m] ~ ploc[m+1];                                              13200000
      psize[m] ~ psize[m+1];                                            13210000
      end;                                                              13220000
   ptr ~ ppoint[m] + psize[m];                                          13230000
   storechars(1,"l",7); % label indirection code                        13240000
   psize[m] ~ psize[m] + 1;                                             13250000
   ptype[m] ~ 14;  % label expression                                   13260000
   end;                                                                 13270000
if ptype[m] ! 14 then                                                   13280000
   begin syntaxerr(8,ploc[m]); % illegal label                          13290000
   go to fail;                                                          13300000
   end;                                                                 13310000
for i ~ m+1 step 1 until sp-1 do if ptype[i] ! 0 then                   13320000
   begin syntaxerr(8,ploc[i]); % illegal label                          13330000
   go to fail;                                                          13340000
   end;                                                                 13350000
ptr ~ ppoint[m] + psize[m];                                             13360000
   psize[mks] ~ psize[m];                                               13370000
ptype[mks] ~ 21;   % go-to part combined                                13380000
ppoint[mks] ~ ppoint[m];                                                13390000
ploc[mks] ~ ploc[m];                                                    13400000
combinegotopart ~ true;                                                 13410000
go to fin;                                                              13420000
%                                                                       13430000
faut:                                                                   13440000
   writeinst;                                                           13450000
   syntaxerr(40,0);                                                     13460000
   writestack(sp);                                                      13470000
   systemerror ~ true;                                                  13480000
fail:                                                                   13490000
   if systemerror then inform0(24);                                     13500000
   combinegotopart ~ false;                                             13510000
fin:                                                                    13520000
   % if inform then writeinst;                                          13530000
end combinegotopart;                                                    13540000
%********combinegotopart************************************************13550000
%********combinegroup***************************************************13560000
boolean procedure combinegroup(mks,con);                                13570000
   value mks, con;                                                      13580000
   integer mks;                                                         13590000
   boolean con;                                                         13600000
begin                                                                   13610000
label faut, fail, fin;                                                  13620000
boolean arith;     % for deleting parens around arith exprs             13630000
integer errno, errpoint, i, j, k, n;                                    13640000
%                                                                       13650000
% if inform then inform0(21);                                           13660000
combinegroup ~ arith ~ false;                                           13670000
for i ~ mks step 1 until sp-1 do if ptype[i] ! 0 then                   13680000
   case ptype[i] of                                                     13690000
      begin                                                             13700000
   % 1: string name                                                     13710000
      ;                                                                 13720000
   % 2: function (incomplete)                                           13730000
      go to faut;                                                       13740000
   % 3: literal                                                         13750000
      ;                                                                 13760000
   % 4: start of group                                                  13770000
      go to faut;                                                       13780000
   % 5: not used                                                        13790000
      go to faut;                                                       13800000
   % 6: $n--indirection, uncombined                                     13810000
      if not combineindirection(k) then go to fin;                      13820000
   % 7: arith operators                                                 13830000
      begin                                                             13840000
      if not combinearithmetic(i) then go to fin;                       13850000
      while i > 0 and ptype[i]!16 do i ~ i - 1;  % find result          13860000
      if ptype[i] ! 16 then go to faut;                                 13870000
      insertstringconvert(i);                                           13880000
      arith ~ true;                                                     13890000
      end;                                                              13900000
   % 8: fixed-length "/"                                                13910000
      go to faut;                                                       13920000
   % 9: str ref, pattern & replacement                                  13930000
      go to faut;                                                       13940000
   % 10: indirection combined                                           13950000
      ;                                                                 13960000
   % 11: not in use                                                     13970000
      go to faut;                                                       13980000
   % 12: qmark--error                                                   13990000
      go to faut;                                                       14000000
   % 13: "*" of str var--error                                          14010000
      go to faut;                                                       14020000
   % 14: label in go-to part                                            14030000
      go to faut;                                                       14040000
   % 15: expression                                                     14050000
      ;                                                                 14060000
   % 16: arith expr--no string convert                                  14070000
      begin                                                             14080000
      insertstringconvert(i);                                           14090000
      arith ~ true;     % might be arith expr                           14100000
      end;                                                              14110000
   % 17: "*(" of bal var                                                14120000
       go to faut;                                                      14130000
   % 18: str ref & pattern                                              14140000
       go to faut;                                                      14150000
   % 19: complete arith expr                                            14160000
       arith ~ true;                                                    14170000
   % 20: "s(",, "f(", or "(" of go-to part                              14180000
       go to faut;                                                      14190000
   % 21: combined go-to part                                            14200000
       go to faut;                                                      14210000
       end cases;                                                       14220000
n ~ j ~ 0;                                                              14230000
for i ~ mks step 1 until sp-1 do if ptype[i] ! 0 then                   14240000
   begin                                                                14250000
   n ~ n + 1;                                                           14260000
   move(psize[i],code[ppoint[i].w],ppoint[i].c,scratch[j.w],j.c);       14270000
   if n { 1 and not con then                                            14280000
      begin pname[mks] ~ pname[i];                                      14290000
      ptype[mks] ~ ptype[i];                                            14300000
      end else ptype[i] ~ 0;                                            14310000
   j ~ j + psize[i];                                                    14320000
   end;                                                                 14330000
if j = 0 then                                                           14340000
   begin aa ~ "%00";                                                    14350000
   mv(j~3,aa,5,scratch[*],0);                                           14360000
   ptype[mks] ~ 1; % string name                                        14370000
   pname[mks] ~ true;                                                   14380000
   end;                                                                 14390000
if n > 1 then arith ~ false; % not a simple arith expr.                 14400000
if arith then                                                           14410000
   begin ptype[mks] ~ 19; % complete arith expr                         14420000
   pname[mks] ~ false;                                                  14430000
   end else                                                             14440000
if n > 1 or con then                                                    14450000
   begin aa ~ n & "("[36:42:6];                                         14460000
   mv(2,aa,6,scratch[j.w],j.c);                                         14470000
   j ~ j + 2;                                                           14480000
   pname[mks] ~ false;                                                  14490000
   ptype[mks] ~ 15; % expression                                        14500000
   end;                                                                 14510000
move(j,scratch[*],0,code[(i~ppoint[mks]).w],i.c);                       14520000
ptr ~ i + (psize[mks]~j);                                               14530000
combinegroup ~ true;                                                    14540000
go to fin;                                                              14550000
%                                                                       14560000
faut:                                                                   14570000
   writeinst;                                                           14580000
   syntaxerr(40,0);                                                     14590000
   write(print,17,code[*]);                                             14600000
   writestack(sp);                                                      14610000
   systemerror ~ true;                                                  14620000
   go to fin;                                                           14630000
fail:                                                                   14640000
   syntaxerr(errno,errpoint);                                           14650000
fin:                                                                    14660000
   if systemerror then inform0(21);                                     14670000
   % if inform then writeinst;                                          14680000
end combinegroup;                                                       14690000
%********combinegroup***************************************************14700000
%********combineindirection*********************************************14710000
boolean procedure combineindirection(mks);                              14720000
   value mks;                                                           14730000
   integer mks;                                                         14740000
begin integer i, errno, j, k;                                           14750000
label fin, fail, faut;                                                  14760000
%                                                                       14770000
% if inform then inform0(22);                                           14780000
for i ~ mks step 1 until sp-2 do if ptype[i] = 6 then                   14790000
   begin                                                                14800000
   case ptype[i+1] of  % check for syntax erros                         14810000
      begin go to faut;                                                 14820000
   % 1: string name                                                     14830000
      begin j ~ "%";    % to mark as non-input string name              14840000
      mv(1,j,7,code[ppoint[i+1].w],ppoint[i+1].c);                      14850000
      end;                                                              14860000
   % 2: function--incomplete                                            14870000
      ; % to become an error eventually                                 14880000
   % 3: literal                                                         14890000
      ;                                                                 14900000
   % 4: grouping--incomplete                                            14910000
      begin errno ~ 27;                                                 14920000
      go to fail;                                                       14930000
      end;                                                              14940000
   % 5: not used                                                        14950000
      go to faut;                                                       14960000
   % 6: indirection--should not occur                                   14970000
      go to faut;                                                       14980000
   % 7: arithmetic operators                                            14990000
      begin errno ~ 34;                                                 15000000
      go to fail;                                                       15010000
      end;                                                              15020000
   % 8: fixed-length "/"                                                15030000
      begin errno ~ 34;                                                 15040000
      go to fail;                                                       15050000
      end;                                                              15060000
   % 9: str ref, pattern & replacement                                  15070000
      go to faut;                                                       15080000
   % 10: indirection combined                                           15090000
      go to faut;                                                       15100000
   % 11: ","                                                            15110000
      begin errno ~ 34;                                                 15120000
      go to fail;                                                       15130000
      end;                                                              15140000
   % 12: qmark--error                                                   15150000
      go to faut;                                                       15160000
   % 13: "*" of str var                                                 15170000
      begin errno ~ 34;                                                 15180000
      go to fail;                                                       15190000
      end;                                                              15200000
   % 14: label in go-to part                                            15210000
      go to faut;                                                       15220000
   % 15: expression                                                     15230000
      ;                                                                 15240000
   % 16: incomplete arith expression                                    15250000
      insertstringconvert(i);                                           15260000
   % 17: "*(" of bal var                                                15270000
       go to faut;                                                      15280000
   % 18: str ref & pattern                                              15290000
       go to faut;                                                      15300000
   % 19: complete arith expr                                            15310000
       ;                                                                15320000
   % 20: "s(",, "f(", or "(" of go-to part                              15330000
       go to faut;                                                      15340000
   % 21: combined go-to part                                            15350000
       go to faut;                                                      15360000
       end cases;                                                       15370000
   % interchange elements:                                              15380000
   move(k~psize[i+1],code[(j~ppoint[i+1]).w],j.c,scratch[*],0);         15390000
   mv(3,code[ppoint[i].w],ppoint[i].c,scratch[k.w],k.c);                15400000
   move(k+3,scratch[*],0,code[ppoint[i].w],ppoint[i].c);                15410000
   psize[i] ~ k + 3;                                                    15420000
   ptype[i] ~ 10;  % indirection, combined                              15430000
   pname[i] ~ true;                                                     15440000
   ptype[i+1] ~ 0; % wipe out next element                              15450000
   combineindirection ~ true;                                           15460000
   go to fin;                                                           15470000
   end;                                                                 15480000
%  if fall thru, no argument to %:                                      15490000
   errno ~ 34;                                                          15500000
   go to fail;                                                          15510000
faut:                                                                   15520000
   writeinst;                                                           15530000
   syntaxerr(40,0);                                                     15540000
   write(print,17,code[*]);                                             15550000
   writestack(sp);                                                      15560000
   systemerror ~ true;                                                  15570000
   go to fin;                                                           15580000
fail:                                                                   15590000
   syntaxerr(errno,ploc[i+1]);                                          15600000
fin:                                                                    15610000
   if systemerror then inform0(22);                                     15620000
   % if inform then writeinst;                                          15630000
end combineindirection;                                                 15640000
%********combineindirection*********************************************15650000
%********combinestrvarname**********************************************15660000
boolean procedure combinestrvarname(mks);                               15670000
   value mks;                                                           15680000
   integer mks;                                                         15690000
begin label fin, succeed;                                               15700000
integer i;                                                              15710000
% if inform then inform0(23);                                           15720000
combinestrvarname ~ false;                                              15730000
if i~ptype[mks] ! 13 and i ! 17 then                                    15740000
   begin writeinst;                                                     15750000
   syntaxerr(40,0);                                                     15760000
   write(print,17,code[*]);                                             15770000
   writestack(sp);                                                      15780000
   systemerror ~ true;                                                  15790000
   go to fin;                                                           15800000
   end;                                                                 15810000
ptype[mks] ~ 0;                                                         15820000
if not combinegroup(mks,false) then go to fin;                          15830000
if not pname[mks] then                                                  15840000
   begin syntaxerr(52,ploc[mks+1]); % invalid name                      15850000
   go to succeed;                                                       15860000
   end;                                                                 15870000
% mark as non-input                                                     15880000
if ptype[mks] = 1 then   % identifier--change to "%" type               15890000
   begin i ~ "%";                                                       15900000
   mv(1,i,7,code[ppoint[mks].w],ppoint[mks].c);                         15910000
   end else                                                             15920000
if ptype[mks] = 10 then % indirection--remove "i"                       15930000
   begin ptype[mks] ~ 15; % expression                                  15940000
   psize[mks] ~ psize[mks] - 1;                                         15950000
   end;                                                                 15960000
succeed:                                                                15970000
   combinestrvarname ~ true;                                            15980000
fin:                                                                    15990000
   if systemerror then inform0(23);                                     16000000
    % if inform then writeinst;                                         16010000
end combinestrvarname;                                                  16020000
%********combinestrvarname**********************************************16030000
%********compile********************************************************16040000
%                                                                       16050000
%     the internal form of a snobol program is described here:          16060000
%     the program is "segmented", with a labeled instruction starting a 16070000
%  segment, and the unlabeled instructions following it are in the      16080000
%  same segement.  a segment is a string, whose "name" is the label of  16090000
%  its first instruction, and whose "value" is the internal coded       16100000
%  form of the instructions in the segement.                            16110000
%     each segment starts with 2 chars giving the loc of the next       16120000
%  segment, for patching purposes,                                      16130000
%     each instruction starts with a 7-char "introduction" giving:      16140000
%        1 char: the illegal char                                       16150000
%        2 chars: the number of the instruction, as given in the listing16160000
%        2 chars: the location of the success exit, relative to the     16170000
%           first char of the segment.                                  16180000
%        2 chars: the same for the failure exit.                        16190000
%     if either exit isnt specified, and the next instruction is        16200000
%  unlabeled, the pointer is to the illegal char at the start of the    16210000
%  next instruction; if the next inst is labeled, the go-to part is     16220000
%  "filled out" with a transfer to this label.                          16230000
%                                                                       16240000
%  the internal code is:                                                16250000
%     string names and labels in the go-to parts are represented by     16260000
%  a quote followed by a 12-bit (2-chars) pointer to symbtabl.          16270000
%     literals are represented by "@" followed by a 2-char pointer      16280000
%  to symbtabl.                                                         16290000
%     pattern matches are indicated by "=" following the code for       16300000
%  the pattern; replacements are indicated by "~" following the code    16310000
%  for the replacement.  (both are postfix operators.)                  16320000
%     the reserved labels are represented as follows:                   16330000
%        end: "-E"                                                      16340000
%        return: "-r"                                                   16350000
%        freturn: "-f"                                                  16360000
%     syntax errors cause the character "X" where the string reference  16370000
%  should be.                                                           16380000
%     functions are postfix operators, which use 4 characters: "#"      16390000
%  to indicate the function call, 2 chars for the pointer to the        16400000
%  symbol table entry for the function, and 1 char to give the number   16410000
%  of parameters.                                                       16420000
%     indirection is a postfix operator consisting of a "$" and one     16430000
%  character giving the number of indirections.  note that this means   16440000
%  that the system cant handle more than 63 consecutive dollar signs    16450000
%  without using parentheses to cause a grouping.  this is not          16460000
%  expected to create any hardships with any users.                     16470000
%                                                                       16480000
%  the following stack arrays are used by the compiler:                 16490000
%                                                                       16500000
%  ploc[*]  holds pointers into inst[*], to the start of the original   16510000
%     code for the element, for diagnostic purposes                     16520000
%  ppoint[*] holds pointers into code[*], to the start of the           16530000
%     compiled code for the elements                                    16540000
%  psize[*] holds the size of the compiled piece of code                16550000
%  pback[*] links back to the start of nextings of groups or            16560000
%     of function calls                                                 16570000
%  pst[*] holds the operator for arithmetic operators                   16580000
%  ptype[*] is the type of element, as follows:                         16590000
%   0: ignore--combined with earlier elements                           16600000
%   1: string name                                                      16610000
%   2: start of function call (#---)                                    16620000
%   3: literal                                                          16630000
%   4: "(" at start of grouping                                         16640000
%   5: string variable--combined into one element                       16650000
%   6: indirection, uncombined ($n)                                     16660000
%   7: arithmetic operator                                              16670000
%   8: "/" of fixed-length variable                                     16680000
%   9: str ref, pattern, & replacement combined                         16690000
%  10: indirection, combined (includes "i" for input check)             16700000
%  11: not in use                                                       16710000
%  12: not in use                                                       16720000
%  13: "*" at start of string variable                                  16730000
%  14: label in go-to part                                              16740000
%  15: expression (combined)                                            16750000
%  16: arithmetic expression--no string convert added                   16760000
%  17: "*(" of balanced string variable                                 16770000
%  18: str ref & pattern together.                                      16780000
%  19: complete arith expr (with string convert)                        16790000
%  20: "s(", "f(", or "(" of go-to part                                 16800000
%  21: combined go-to part                                              16810000
%                                                                       16820000
%                                                                       16830000
procedure compile(inst); alpha array inst[0];                           16840000
begin label                                                             16850000
    next, illegal,                                                      16860000
    bl, lit, str,                                                       16870000
    name, name1, cma, goto, gtpart,                                     16880000
    condensepattern,                                                    16890000
    condensereplacement,                                                16900000
    dlr,                                                                16910000
    endstrvar,                                                          16920000
    error,                                                              16930000
    nop,                                                                16940000
    op,                                                                 16950000
    parenerr,                                                           16960000
    qmrk, return,                                                       16970000
    mesfil,                                                             16980000
    semicolon, start, l1                                                16990000
    ;                                                                   17000000
%********                                                               17010000
boolean                                                                 17020000
   arith,                                                               17030000
   arf,                                                                 17040000
   fixedlength,                                                         17050000
   nf,                                                                  17060000
   pattern,                                                             17070000
   replacement,                                                         17080000
   svf;                                                                 17090000
boolean array compilingfct[0:50];                                       17100000
integer                                                                 17110000
   firstchar,      % flags for first of inst.                           17120000
   i,                                                                   17130000
   j,                                                                   17140000
   t,                                                                   17150000
   temp;                                                                17160000
%                                                                       17170000
p ~ scanchar(" ", " ",inst[*],0);                                       17180000
start:                                                                  17190000
for i ~ 0 step 1 until 5 do backtrack[0,i] ~ 0;                         17200000
firstchar ~ mks ~ parencount ~ 0;                                       17210000
gtlast ~ gt;                                                            17220000
pattern ~ replacement ~ gt ~ gts ~ gtf ~ systemerror ~ svf ~ arf ~      17230000
   fixedlength ~ false;                                                 17240000
p ~ p + 1;                                                              17250000
p ~ p + skipchar(" ",inst[p.w],p.c);                                    17260000
if p } instsize then go to return;                                      17270000
   sp ~ -1;                                                             17280000
   if datacomf then if instnum mod 10 = 0 then                          17290000
      if instnum = 0 then  % return, line feed.                         17300000
         begin mv(3,crlf,5,dcwrite[*],0);                               17310000
         if output then;                                                17320000
         end else                                                       17330000
      % write inst #:                                                   17340000
         messagetti(15,instnum);  % type # on teletype.                 17350000
next:                                                                   17360000
   if (sp~sp+1) } stacksize then                                        17370000
      begin syntaxerr(21,p);                                            17380000
      go to return;                                                     17390000
      end;                                                              17400000
%  if inform then                                                       17410000
%     begin mv(6,inst[p.w],p.c,aa,2);                                   17420000
%     informia(2,sp,aa);                                                17430000
%     end;                                                              17440000
   ppoint[sp] ~ ptr;                                                    17450000
   ploc[sp] ~ p;   % save for syntax errors                             17460000
   if p } instsize then go to qmrk;                                     17470000
   case chartype[char(inst[p.w],p.c)] of                                17480000
   begin                                                                17490000
% 0: error                                                              17500000
   begin syntaxerr(3,p);                                                17510000
   go to return;                                                        17520000
   end;                                                                 17530000
% 1: blank                                                              17540000
   begin p ~ p + skipchar(" ",inst[p.w],p.c);                           17550000
   sp ~ sp - 1;                                                         17560000
   go to next;                                                          17570000
   end;                                                                 17580000
% 2: "~" or "="                                                         17590000
   begin                                                                17600000
   if sp < 1 then                                                       17610000
      begin syntaxerr(6,p);                                             17620000
      go to return;                                                     17630000
      end;                                                              17640000
   if not (pname[0] or ptype[0]=6) then                                 17650000
      begin syntaxerr(15,p); % replacement in value expr                17660000
      go to return;                                                     17670000
      end;                                                              17680000
   if arf then                                                          17690000
      begin syntaxerr(13,p); % extra "~" or "="                         17700000
      go to return;                                                     17710000
      end;                                                              17720000
   if parencount ! 0 then                                               17730000
      begin syntaxerr(27,p); % missing ")"                              17740000
      go to return;                                                     17750000
      end;                                                              17760000
   if svf then                                                          17770000
      begin syntaxerr(38,p); % missing "*"                              17780000
      go to return;                                                     17790000
      end;                                                              17800000
   if gt then                                                           17810000
      begin syntaxerr(7,p);  % unrecognized go-to construct             17820000
      go to return;                                                     17830000
      end;                                                              17840000
   arf ~ true;                                                          17850000
   p ~ p + 1;                                                           17860000
condensepattern:                                                        17870000
   % if inform then inform0(27);                                        17880000
   for i ~ 0 step 1 until sp-1 do                                       17890000
      case ptype[i] of                                                  17900000
         begin;  % if 0, ignore                                         17910000
      % 1: string name                                                  17920000
         ;                                                              17930000
      % 2: start of function call                                       17940000
         go to error;                                                   17950000
      % 3: literal                                                      17960000
         ;                                                              17970000
      % 4: "(" of grouping                                              17980000
         go to error;                                                   17990000
      % 5: str var                                                      18000000
         ;                                                              18010000
      % 6: indirection                                                  18020000
         if not combineindirection(i) then go to return;                18030000
      % 7: arith operators                                              18040000
         begin if not combinearithmetic(i) then go to return;           18050000
         while i > 0 and ptype[i]!16 do i ~ i - 1;  % find result       18060000
         if ptype[i] ! 16 then go to error;                             18070000
         insertstringconvert(i);                                        18080000
         end;                                                           18090000
      % 8: "/" of fixed-length var                                      18100000
         go to error;                                                   18110000
      % 9: str ref, pattern & repl                                      18120000
         go to error;                                                   18130000
      % 10: indirection combined                                        18140000
         ;                                                              18150000
      % 11: unused                                                      18160000
         go to error;                                                   18170000
      % 12: unused                                                      18180000
         go to error;                                                   18190000
      % 13: "*" of str var                                              18200000
         go to error;                                                   18210000
      % 14: label in go-to part                                         18220000
         go to error;                                                   18230000
      % 15: expression                                                  18240000
         ;                                                              18250000
      % 16: arith expr--no string convert                               18260000
         insertstringconvert(i);                                        18270000
      % 17: "*(" of bal var                                             18280000
         go to error;                                                   18290000
      % 18: str ref & pattern                                           18300000
         go to error;                                                   18310000
      % 19: complete arith expr                                         18320000
         ;                                                              18330000
      % 20: "s(", "f(", or "(" of go-to part                            18340000
         go to error;                                                   18350000
      % 21: combined go-to part                                         18360000
         go to error;                                                   18370000
         end cases;                                                     18380000
   i1 ~ i2 ~ 0;                                                         18390000
   for i ~ 1 step 1 until sp-1 do if ptype[i] ! 0 then                  18400000
      begin                                                             18410000
      move(psize[i],code[ppoint[i].w],ppoint[i].c,scratch[i2.w],i2.c);  18420000
      i2 ~ i2 + psize[i];                                               18430000
      i1 ~ i1 + 1;                                                      18440000
      ptype[i] ~ 0;                                                     18450000
      end;                                                              18460000
   if i1 } 1 then                                                       18470000
      begin                                                             18480000
      if ptype[0] = 1 then                                              18490000
         begin aa ~ "%";                                                18500000
         mv(1,aa,7,code[ppoint[0].w],ppoint[0].c);                      18510000
         end else                                                       18520000
      if ptype[0] = 10 then                                             18530000
         begin ptype[0] ~ 15; % expression                              18540000
         psize[0] ~ psize[0] - 1; % drop "i"                            18550000
         end;                                                           18560000
   ptr ~ ppoint[0] + psize[0];                                          18570000
      storechars(1,"s",7);                                              18580000
      storechars(i2,scratch[0],0);                                      18590000
      storechars(1,"=",7);                                              18600000
      psize[0] ~ psize[0] + i2 + 2;                                     18610000
      firstchar.[43:2] ~ 3;  % str ref, pattern exist                   18620000
      ptype[0] ~ 18;    % str ref & pattern                             18630000
      end else                                                          18640000
      firstchar.[43:2] ~ 2;  % str ref, no pattern                      18650000
   if gt then      % put in "/" as go-to delimiter                      18660000
      begin storechars(1,"/",7);                                        18670000
      psize[0] ~ psize[0] + 1;                                          18680000
      end;                                                              18690000
   pattern ~ true;                                                      18700000
   sp ~ 0;                                                              18710000
   pback[mks~1] ~ 0;                                                    18720000
   % if inform then writeinst;                                          18730000
   go to next;                                                          18740000
   end;  % case for "=" or "~".                                         18750000
% 3: letter, digit, or period                                           18760000
   go to name;                                                          18770000
% 4: """                                                                18780000
   go to lit;                                                           18790000
% 5: "("                                                                18800000
   begin                                                                18810000
   if gt then if parencount = 0 then go to gtpart;                      18820000
   compilingfct[parencount~parencount+1] ~ false;                       18830000
   p ~ p + 1;                                                           18840000
   pback[sp] ~ mks;                                                     18850000
   mks ~ sp;                                                            18860000
   ptype[sp] ~ 4;  % "("--begin grouping                                18870000
   psize[sp] ~ 0;  % nothing to store in code here                      18880000
   go to next;                                                          18890000
   end;                                                                 18900000
% 6: ")"                                                                18910000
   begin                                                                18920000
   if parencount { 0 then                                               18930000
      begin syntaxerr(12,p); % extra right paren                        18940000
      go to return;                                                     18950000
      end;                                                              18960000
   if svf and not fixedlength then if parencount = 1 then               18970000
      if ptype[mks] = 17 then                                           18980000
      begin                                                             18990000
      if char(inst[p.w],p.c+1) ! "*" then                               19000000
         begin syntaxerr(38,p+1);                                       19010000
         go to return;                                                  19020000
         end;                                                           19030000
      p ~ p + 1; % skip ")"                                             19040000
      parencount  ~ 0;                                                  19050000
      go to endstrvar;                                                  19060000
      end balanced variable element;                                    19070000
   if gt and parencount=1 then  % end of a piece of the go-to part      19080000
      begin                                                             19090000
      if not combinegotopart(mks) then go to return;                    19100000
      end else                                                          19110000
   if compilingfct[parencount] then                                     19120000
      begin                                                             19130000
      if not combinegroup(mks+1,false) then go to return;               19140000
      combinefunction(if ptype[mks]=2 then mks else (mks~pback[mks]));  19150000
      end else                                                          19160000
      begin ptype[mks] ~ 0; % wipe out "(" entry                        19170000
      if not combinegroup(mks,true) then go to return;                  19180000
      end;                                                              19190000
   parencount ~ parencount - 1;                                         19200000
   p ~ p + 1;                                                           19210000
   if ptype[sp~mks]!2 then mks ~ pback[mks];                            19220000
   go to next;                                                          19230000
   end;                                                                 19240000
% 7: "*"                                                                19250000
   go to str;                                                           19260000
% 8: "$"                                                                19270000
   go to dlr;                                                           19280000
% 9: ":" go-to part                                                     19290000
goto:                                                                   19300000
   begin                                                                19310000
   if svf then  % unmatched str var * before go-to.                     19320000
      begin syntaxerr(38,ppoint[sp-1]);                                 19330000
      go to return;                                                     19340000
      end;                                                              19350000
   if gt then                                                           19360000
      begin syntaxerr(7,p);  % unrecognized construct                   19370000
      go to return;                                                     19380000
      end;                                                              19390000
   if parencount ! 0 then                                               19400000
      begin syntaxerr(10,p); % paren count non-zero                     19410000
      go to return;                                                     19420000
      end;                                                              19430000
   gt ~ true;                                                           19440000
   p ~ p + 1;                                                           19450000
   psize[sp] ~ ptype[sp] ~ 0;                                           19460000
   if not arf then                                                      19470000
      begin firstchar.[45:1] ~ 0; % no replacement                      19480000
      go to condensepattern;                                            19490000
      end;                                                              19500000
   % replacement to be condensed                                        19510000
condensereplacement:                                                    19520000
   % if inform then inform0(28);                                        19530000
   for i ~ 0 step 1 until sp-1 do                                       19540000
      case ptype[i] of                                                  19550000
         begin                                                          19560000
      % 0: ignore                                                       19570000
         ;                                                              19580000
      % 1: string name                                                  19590000
         ;                                                              19600000
      % 2: function call                                                19610000
         go to error;                                                   19620000
      % 3: literal                                                      19630000
         ;                                                              19640000
      % 4: "(" of grouping                                              19650000
         go to error;                                                   19660000
      % 5: str var combined                                             19670000
         go to error;                                                   19680000
      % 6: indirection                                                  19690000
         if not combineindirection(i) then go to return;                19700000
      % 7: arith operator                                               19710000
         begin                                                          19720000
         if not combinearithmetic(i) then go to return;                 19730000
         while i > 0 and ptype[i]!16 do i ~ i-1; % find result          19740000
         if ptype[i] ! 16 then go to error;                             19750000
         insertstringconvert(i);                                        19760000
         end;                                                           19770000
      % 8: "/" of fixed-length var                                      19780000
         go to error;                                                   19790000
      % 9: str ref, pattern & replacement                               19800000
         go to error;                                                   19810000
      % 10: indirection combined                                        19820000
         ;                                                              19830000
      % 11: unused                                                      19840000
         go to error;                                                   19850000
      % 12: unused                                                      19860000
         go to error;                                                   19870000
      % 13: "*" of str var                                              19880000
         go to error;                                                   19890000
      % 14: go-to label                                                 19900000
         go to error;                                                   19910000
      % 15: expression                                                  19920000
         ;                                                              19930000
      % 16: arith expr--no str convert                                  19940000
         insertstringconvert(i);                                        19950000
      % 17: "*(" of bal var                                             19960000
         go to error;                                                   19970000
      % 18: str ref & pattern                                           19980000
         if i ! 0 then go to error;                                     19990000
      % 19: complete arith expr                                         20000000
         ;                                                              20010000
      % 20: "s(",, "f(", or "(" of go-to part                           20020000
         go to error;                                                   20030000
      % 21: combined go-to part                                         20040000
         go to error;                                                   20050000
         end cases;                                                     20060000
   if ptype[0] = 1 then % mark as non-input                             20070000
      begin aa ~ "%";                                                   20080000
      mv(1,aa,7,code[ppoint[0].w],ppoint[0].c);                         20090000
      end else                                                          20100000
   if ptype[0] = 10 then                                                20110000
      begin ptype[0] ~ 15;    % expression                              20120000
      psize[0] ~ psize[0] - 1; % drop "i"                               20130000
      end;                                                              20140000
   i1 ~ i2 ~ 0;                                                         20150000
   for i ~ 1 step 1 until sp-1 do if ptype[i]!0 then                    20160000
      begin                                                             20170000
      move(psize[i],code[ppoint[i].w],ppoint[i].c,scratch[i2.w],i2.c);  20180000
      i2 ~ i2 + psize[i];                                               20190000
      i1 ~ i1 + 1;                                                      20200000
      ptype[i] ~ 0;                                                     20210000
      end;                                                              20220000
   ptr ~ ppoint[0] + psize[0];                                          20230000
   firstchar.[45:1] ~ 1; % replacement exits                            20240000
   storechars(i2,scratch[0],0);                                         20250000
   storechars(1,"~",7);                                                 20260000
   psize[0] ~ psize[0] + i2 + 1;                                        20270000
   ptype[0] ~ 9;   % str ref, pattern & replacement                     20280000
   replacement ~ true;                                                  20290000
   sp ~ 0;                                                              20300000
   pback[mks~1] ~ 0;                                                    20310000
   % if inform then writeinst;                                          20320000
   go to next;                                                          20330000
   end;   % case for go-to ":" or " /"                                  20340000
% 10: "-","+", or "|"                                                   20350000
   go to op;                                                            20360000
% 11: ","                                                               20370000
   begin                                                                20380000
   if not compilingfct[parencount] then                                 20390000
      begin syntaxerr(9,p);  % illegal comma                            20400000
      go to return;                                                     20410000
      end;                                                              20420000
   if not combinegroup(mks+1,false) then go to return;                  20430000
   pback[mks+1] ~ (if ptype[mks]=2 then mks else pback[mks]);           20440000
   mks ~ sp ~ mks+1;                                                    20450000
   p ~ p + 1;                                                           20460000
   go to next;                                                          20470000
   end;                                                                 20480000
% 12: "/"                                                               20490000
   begin if svf and parencount = 0 and not fixedlength then             20500000
      begin % fixed-length variable slash                               20510000
      if ptype[mks] ! 13 then                                           20520000
         begin syntaxerr(14,p);                                         20530000
         go to return;                                                  20540000
         end;                                                           20550000
      if not combinestrvarname(mks) then go to return;                  20560000
      ptype[sp~mks+1] ~ 8; % fixed-length "/"                           20570000
      ppoint[sp] ~ ptr;                                                 20580000
      psize[sp] ~ 0;                                                    20590000
      p ~ p + 1;                                                        20600000
      fixedlength ~ true;                                               20610000
      pback[sp] ~ pback[mks];                                           20620000
      mks ~ sp;                                                         20630000
      go to next;                                                       20640000
      end;                                                              20650000
   if parencount = 0 then                                               20660000
      if char(inst[(p-1).w],(p-1).c) = " " then                         20670000
         if i~char(inst[p.w],p.c+1) = "S" or i = "f" or i = "("         20680000
            then go to goto;                                            20690000
   go to op;                                                            20700000
   end; % case for "/"                                                  20710000
% 13: qmark                                                             20720000
   if p } instsize then go to qmrk;                                     20730000
% 14: ";"                                                               20740000
   go to semicolon;                                                     20750000
   end cases;                                                           20760000
illegal:                                                                20770000
   syntaxerr(3,p);                                                      20780000
   go to return;                                                        20790000
lit:                                                                    20800000
   if gt then if parencount { 1 then                                    20810000
      begin syntaxerr(28,p); go to return; end;                         20820000
   begin                                                                20830000
   psize[sp] ~ 3; ptype[sp] ~ 3;   % literal                            20840000
   t ~ p;                                                               20850000
   p ~ p  + scanchar(""",""",inst[p.w],p.c+1) + 1;                      20860000
   if p } instsize then                                                 20870000
      begin syntaxerr(0,t);                                             20880000
      go to return;                                                     20890000
      end;                                                              20900000
   t ~ enterst(p-t-1,inst[*],t+1,"lit") & "@"[30:42:6];                 20910000
   storechars(3,t,5);                                                   20920000
   p ~ p + 1;                                                           20930000
   go to next;                                                          20940000
   end;                                                                 20950000
name:                                                                   20960000
   if gt then if parencount = 0 or ptype[sp-1] = 20 then go to gtpart;  20970000
   psize[sp] ~ 3;                                                       20980000
   t ~ p;                                                               20990000
   do p ~ p + 1 until chartype[char(inst[p.w],p.c)] ! 3;                21000000
   t ~ if char(inst[p.w],p.c) = "("                                     21010000
      then enterst(p-t,inst[*],t,"fct") & "#"[30:42:6]                  21020000
      else enterst(p-t,inst[*],t,"symb") & """[30:42:6];                21030000
   storechars(3,t,5);                                                   21040000
   if char(inst[p.w],p.c) = "(" then                                    21050000
      begin                                                             21060000
      compilingfct[parencount~parencount+1] ~ true;                     21070000
      ptr ~ ptr + 1; % make room for char giving # of params            21080000
      p ~ p + 1;                                                        21090000
      pback[sp] ~ mks;                                                  21100000
      mks ~ sp;                                                         21110000
      ptype[sp] ~ 2;    % function caall                                21120000
      psize[sp] ~ 3;    % #--                                           21130000
      go to next;                                                       21140000
      end else                                                          21150000
      begin ptype[sp] ~ 1; % string name                                21160000
      pname[sp] ~ true;                                                 21170000
      end;                                                              21180000
   go to next;                                                          21190000
gtpart:                                                                 21200000
   if parencount = 0 then                                               21210000
      begin                                                             21220000
      if (temp ~ char(inst[p.w],p.c)) = "s" or temp = "f" then          21230000
      if char(inst[p.w],p.c+1) = "(" then                               21240000
         begin                                                          21250000
         if (if temp="s" then gts else gtf) then                        21260000
            begin syntaxerr(4,p);                                       21270000
            go to return;                                               21280000
            end;                                                        21290000
         p ~ p + 2;                                                     21300000
         parencount ~ 1; compilingfct[1] ~ false;                       21310000
         if temp = "s" then gts ~ true else gtf ~ true;                 21320000
         ptype[sp] ~ 20; % "s(", "f(", or "(" of go-to part             21330000
         pback[sp] ~ mks; mks ~ sp;                                     21340000
         pst[sp] ~ temp;                                                21350000
         go to next;                                                    21360000
         end else                                                       21370000
         begin syntaxerr(5,p+1);                                        21380000
         comment char after s or f not "(";                             21390000
         go to return;                                                  21400000
         end else                                                       21410000
      if temp = "(" then                                                21420000
         begin                                                          21430000
         if gts and gtf then                                            21440000
            begin syntaxerr(4,p);                                       21450000
            go to return;                                               21460000
            end;                                                        21470000
         p ~ p + 1;                                                     21480000
         parencount ~ 1; compilingfct[1] ~ false;                       21490000
         gts ~ gtf ~ true;                                              21500000
         ptype[sp] ~ 20; % "s(", "f(", or "(" of  go-to part            21510000
         pback[sp] ~ mks; mks ~ sp;                                     21520000
         pst[sp] ~ "(";                                                 21530000
         go to next;                                                    21540000
         end else                                                       21550000
         begin syntaxerr(7,p);                                          21560000
         go to return;                                                  21570000
         end;                                                           21580000
      end else                                                          21590000
   if parencount = 1 then                                               21600000
      begin                                                             21610000
      t ~ p; p ~ p + 1;                                                 21620000
      p ~ p + min(scanchar(" ","(",inst[p.w],p.c),                      21630000
                  scanchar(" ",")",inst[p.w],p.c));                     21640000
      if char(inst[p.w],p.c) = "(" then                                 21650000
         begin syntaxerr(8,p);                                          21660000
         go to return;                                                  21670000
         end;                                                           21680000
      if char(inst[p.w],p.c) = " " then                                 21690000
         begin temp ~ p;                                                21700000
         while char(inst[p.w],p.c) = " " do p ~ p + 1;                  21710000
         if p } instsize then                                           21720000
            begin syntaxerr(18,0);                                      21730000
            go to return;                                               21740000
            end;                                                        21750000
         if char(inst[p.w],p.c) ! ")" then                              21760000
            begin syntaxerr(8,p);                                       21770000
            go to return;                                               21780000
            end;                                                        21790000
         end else temp ~ p;                                             21800000
         if eq(3,words[6],2,inst[t.w],t.c) then                         21810000
            if t+3 = temp then                                          21820000
               begin storechars(2,"-e",6);                              21830000
            psize[sp] ~ 2;                                              21840000
               go to l1;                                                21850000
               end else                                                 21860000
            else                                                        21870000
         if eq(6,words[6],6,inst[t.w],t.c) then                         21880000
            if t+6 = temp then                                          21890000
               begin storechars(2,"-r",6);                              21900000
            psize[sp] ~ 2;                                              21910000
               go to l1;                                                21920000
               end else                                                 21930000
            else                                                        21940000
         if eq(7,words[6],5,inst[t.w],t.c) then                         21950000
             if t+7 = temp then                                         21960000
                begin storechars(2,"-f",6);                             21970000
             psize[sp] ~ 2;                                             21980000
                go to l1;                                               21990000
                end;                                                    22000000
       t ~ enterst(temp-t,inst[*],t,"inst") & ":"[30:42:6];             22010000
       storechars(3,t,5);                                               22020000
       psize[sp] ~ 3;                                                   22030000
l1:    ptype[sp] ~ 14; % identifier--label                              22040000
       go to next;                                                      22050000
       end;                                                             22060000
    go to error;                                                        22070000
str:      % "*" encountered--test for string variable or multiply,      22080000
    % an asterisk is a string variable asterisk iff it  is in the       22090000
    % pattern part and outside of parentheses.                          22100000
    begin                                                               22110000
    define dummy=#;                                                     22120000
    if sp < 1 then                                                      22130000
       begin syntaxerr(2,p);  % unrecognized construct in str ref       22140000
       go to return;                                                    22150000
       end;                                                             22160000
    if parencount > 0 then go to op;                                    22170000
    if arf and not gt then go to op;                                    22180000
    if svf then go to endstrvar;                                        22190000
    if gt then                                                          22200000
       begin syntaxerr(3,p);                                            22210000
       go to return;                                                    22220000
       end;                                                             22230000
    if char(inst[p.w],p.c+1) = "(" then                                 22240000
       begin ptype[sp] ~ 17;  % "*(" of bal str var                     22250000
       parencount ~ 1;                                                  22260000
       p ~ p + 2;                                                       22270000
       end else                                                         22280000
       begin ptype[sp] ~ 13;  % "*" of arb or f/l str var               22290000
       p ~ p + 1;                                                       22300000
       end;                                                             22310000
    psize[sp] ~ 0;                                                      22320000
    ptr ~ ptr + 2; % for *n                                             22330000
    pback[sp] ~ mks;                                                    22340000
    mks ~ sp;                                                           22350000
    svf ~ true;                                                         22360000
    go to next;                                                         22370000
    end;                                                                22380000
endstrvar:                                                              22390000
    begin                                                               22400000
    if i~ptype[mks] = 13 then % simple str var                          22410000
       begin                                                            22420000
       if not combinestrvarname(mks) then go to return;                 22430000
       aa ~ "*1";                                                       22440000
       end else                                                         22450000
    if i = 17 then  % balance str var                                   22460000
       begin                                                            22470000
       if not combinestrvarname(mks) then go to return;                 22480000
       aa ~ "*2";                                                       22490000
       end else                                                         22500000
    if i = 8 then   % fixed-length var                                  22510000
       begin ptype[mks] ~ 0;                                            22520000
       if not combinegroup(mks,false) then go to return;                22530000
       aa ~ "*3";                                                       22540000
       end else                                                         22550000
    % error-mks doesnt point to valid element                           22560000
       go to error;                                                     22570000
    ptr ~ ppoint[mks] + psize[mks];                                     22580000
    storechars(2,aa,6);                                                 22590000
    psize[sp~mks] ~ psize[mks] + 2;                                     22600000
    ptype[sp] ~ 5;  % str var--combined                                 22610000
    p ~ p + 1;  % skip "*"                                              22620000
    svf ~ fixedlength ~ false;                                          22630000
    go to next;                                                         22640000
    end;                                                                22650000
op:                                                                     22660000
    i ~ char(inst[p.w],p.c);                                            22670000
    if i = "*" then                                                     22680000
       if char(inst[p.w],p.c) = "*"                                     22690000
          then p ~ p + 1 % two start--exponentiation                    22700000
          else i ~ "|";  % one star--multiplication                     22710000
    pst[sp] ~ i;    % for combinearithmetic                             22720000
    i.c6 ~ ".";                                                         22730000
    ptype[sp] ~ 7;                                                      22740000
    pback[sp] ~ mks;                                                    22750000
    psize[sp] ~ 2;                                                      22760000
    storechars(2,i,6);                                                  22770000
    ptr ~ ptr + 2;  % make room for string convert (2 chars).           22780000
    p ~ p + 1;                                                          22790000
    go to next;                                                         22800000
parenerr:                                                               22810000
    syntaxerr(12,p);                                                    22820000
    go to return;                                                       22830000
error:                                                                  22840000
    writeinst;                                                          22850000
    syntaxerr(40,0);                                                    22860000
    writestack(sp);                                                     22870000
    go to return;                                                       22880000
dlr:                                                                    22890000
    i ~ 1;                                                              22900000
    do begin p ~ p + 1;                                                 22910000
       if j ~ char(inst[p.w],p.c) = "$" then i ~ i + 1;                 22920000
       end until j ! "$" and j ! " ";                                   22930000
    aa ~ "$-i" & i[36:42:6];                                            22940000
    storechars(3,aa,5);  % "$", no. of indirections, "i"                22950000
    ptype[sp] ~ 6;       % indirection                                  22960000
    psize[sp] ~ 2;                                                      22970000
    go to next;                                                         22980000
mesfil:                                                                 22990000
    syntaxerr(38,0);                                                    23000000
    comment missing str var asterisk;                                   23010000
    go to return;                                                       23020000
semicolon:                                                              23030000
   begin                                                                23040000
   % if inform then inform0(29);                                        23050000
   if sp > 1 then go to qmrk;                                           23060000
   if arf then if not gt then if sp=1 then if ptype[0]!9                23070000
      then storechars(1,"~",7);   % stmt of form <strref> ~             23080000
   if not gts then sloc ~ ptr;                                          23090000
   if not gtf then floc ~ ptr;                                          23100000
   temp ~ floc & sloc[24:36:12];                                        23110000
   move(4,temp,4,code[marker.w],marker.c+3);                            23120000
   instnum ~ instnum + 1;                                               23130000
   marker ~ ptr;                                                        23140000
   aa ~ 0 & instnum[12:36:12] & qmark[6:42:6];                          23150000
   storechars(7,aa,1);                                                  23160000
   ptr ~ ptr + 1;                                                       23170000
   go to start;                                                         23180000
   end;                                                                 23190000
qmrk:                                                                   23200000
   if parencount ! 0 then                                               23210000
      begin syntaxerr(18,0);                                            23220000
      comment parencount not-zero at end of instruction;                23230000
      go to return;                                                     23240000
      end;                                                              23250000
   if svf then go to mesfil;                                            23260000
   ptype[sp] ~ psize[sp] ~ 0;                                           23270000
   if not gt then                                                       23280000
      begin                                                             23290000
      if not arf then if ptype[0]!18 then if sp>1                       23300000
         then go to condensepattern;                                    23310000
      if arf then if not gt then if ptype[0] ! 9                        23320000
         then go to condensereplacement;                                23330000
      end;                                                              23340000
   i1 ~ 0;                                                              23350000
   ptr ~ ppoint[0];                                                     23360000
   sloc ~ floc ~ 0;                                                     23370000
   for i ~ 0 step 1 until sp do if ptype[i] ! 0 then                    23380000
      begin                                                             23390000
      move(psize[i],code[ppoint[i].w],ppoint[i].c,scratch[i1.w],i1.c);  23400000
      if ptype[i] = 21 then  % go-to part--check locs                   23410000
         if i2~pst[i] = "s" then sloc ~ ptr+i1 else                     23420000
         if i2 = "f" then floc ~ ptr+i1 else                            23430000
         if i2 = "(" then                                               23440000
            begin                                                       23450000
            if sloc = 0 then sloc ~ ptr + i1;                           23460000
            if floc = 0 then floc ~ ptr + i1;                           23470000
            end else go to error;                                       23480000
      i1 ~ i1 + psize[i];                                               23490000
      ptype[i] ~ 0;                                                     23500000
      end;                                                              23510000
   storechars(i1,scratch[0],0);                                         23520000
   psize[0] ~ i1;                                                       23530000
   if p < instsize then                                                 23540000
      begin sp ~ 1;                                                     23550000
      go to semicolon;                                                  23560000
      end;                                                              23570000
   if not gts then sloc ~ ptr;                                          23580000
   if not gtf then floc ~ ptr;                                          23590000
return:                                                                 23600000
   mv(2,sloc,6,code[marker.w],marker.c+3);                              23610000
   mv(2,floc,6,code[marker.w],marker.c+5);                              23620000
   mv(1,firstchar,7,code[marker.w],marker.c+7);                         23630000
   if inform then writeinst;                                            23640000
end compile;                                                            23650000
%********compile********************************************************23660000
%********controlparameter***********************************************23670000
integer procedure controlparameter(a,p);                                23680000
   alpha array a[*];                                                    23690000
   integer p;                                                           23700000
begin define dummy =#;                                                  23710000
i1 ~ p;                                                                 23720000
while char(a[*],i1) > 9 and i1 < 64 do i1 ~ i1 + 1;                     23730000
p ~ i1;                                                                 23740000
while char(a[*],p) { 9 and p < 64 do p ~ p + 1;                         23750000
if i1 } p then i1 ~ -1 else                                             23760000
   read(a[*],fnum,i1,p-i1,i1);                                          23770000
controlparameter ~ i1;                                                  23780000
end controlparameter;                                                   23790000
%********controlparameter***********************************************23800000
%********convert********************************************************23810000
% this routine does a character-set convert, and (if convertstrings     23820000
% is true) a conversion of i/o string names.  it is currently set       23830000
% to convert from cdc 3600 snobol (as implemented at the univ. of       23840000
% wisconsi) to b5500 snobol.  users at other installation will          23850000
% probably want to write thier own routine, to convert from a           23860000
% local version of snobol to b5500 snobol.                              23870000
procedure convert(a);                                                   23880000
   alpha array a[0];                                                    23890000
begin integer i;                                                        23900000
alpha array c[0:79];                                                    23910000
define d = c[i]#, d1 = c[i+1]#, d2 = c[i+2]#,                           23920000
  d3 = c[i+3]#, D4 = c[i+4]#, d5 = c[i+5]#;                             23930000
read(a[*],f80a1,for i ~ 0 step 1 until 79 do c[i]);                     23940000
if convertstrings then                                                  23950000
for i ~ 1 step 1 until fieldsize-6 do                                   23960000
  if d = "s" and d1 = "y" and d2 = "s" then                             23970000
     if d3 = "l" and d4 = "o" and d5 = "k" then         % syslok : look 23980000
    begin d ~ "l"; d1 ~ "o"; d2 ~ "o"; d3 ~ "k"; d4 ~ d5 ~ " ";         23990000
  end else if d3 = "p" and d5 = "t" then                                24000000
   if d4 = "i" then                     % syspit : read                 24010000
    begin d ~ "r"; d1 ~ "e"; d2 ~ "a"; d3 ~ "d"; d4 ~ d5 ~ " ";         24020000
   end else if d4 = "p" then            % sysppt : punch                24030000
    begin d ~ "p"; d1 ~ "u"; d2 ~ "n"; d3 ~ "c"; d4 ~ "h"; d5 ~ " ";    24040000
    end;                                                                24050000
for i ~ 0 step 1 until 79 do                                            24060000
   c[i] ~ convertval[c[i]];                                             24070000
write(a[*],f80a1,for i ~ 0 step 1 until 79 do c[i]);                    24080000
end convert;                                                            24090000
%********convert********************************************************24100000
%********createlibrary**************************************************24110000
procedure createlibrary(mfid,fid);                                      24120000
value mfid, fid;                                                        24130000
alpha mfid, fid;                                                        24140000
begin integer i, j;                                                     24150000
alpha array x[0:5];                                                     24160000
save file libe disk serial [20:200] (15,6,60,save 15);                  24170000
%                                                                       24180000
fill libe with mfid, fid;                                               24190000
write(libe,flib0,entier(version));                                      24200000
write(libe,flib1,scatterno,maxinstsize,                                 24210000
      cpulimitexists,cpulimit,                                          24220000
      iolimitexists,iolimit,                                            24230000
      rulelimitexists,rulelimit);                                       24240000
write(libe,flib2,entry,for i~0 step 1 until 15 do usedst[i],instnum);   24250000
write(libe,flib3,for i~0 step 1 until 15 do nextcell[i]);               24260000
for i ~ 0 step 1 until 15 do                                            24270000
   if usedst[i] then                                                    24280000
      for j ~ 0 step 2 until 254 do                                     24290000
         write(libe,flib4,namtabl[i,j],valtabl[i,j],iotabl[i,j],        24300000
            namtabl[i,j+1],valtabl[i,j+1],iotabl[i,j+1]);               24310000
write(libe,flib5,for i~0 step 1 until 31 do usedrow[i]);                24320000
write(libe,flib6,for i~0 step 1 until 31 do dpntr[i]);                  24330000
for I ~ 0 Step 1 while usedrow[i] do                                    24340000
   for j ~ 0 step 6 until dpntr[i].w do                                 24350000
      begin movewds(6,data[i,j],x[*]);                                  24360000
      write(libe,6,x[*]);                                               24370000
      end;                                                              24380000
lock(libe,save);                                                        24390000
end createlibrary;                                                      24400000
%********createlibrary**************************************************24410000
%********date***********************************************************24420000
alpha procedure date;                                                   24430000
begin % produces date in form:                                          24440000
%              mm/dd/yy                                                 24450000
alpha x;                                                                24460000
integer d, m, y;                                                        24470000
stream procedure alphadate(d,m,y,w);                                    24480000
   value d, m, y;                                                       24490000
   begin di ~ w;                                                        24500000
   si ~ loc m; ds ~ 2 dec; ds ~ 1 lit "/";                              24510000
   si ~ loc d; ds ~ 2 dec; ds ~ 1 lit "/";                              24520000
   si ~ loc y; ds ~ 2 dec;                                              24530000
   end alphadate;                                                       24540000
%                                                                       24550000
x ~ time(0);                                                            24560000
y ~ 10 | x.[18:6] + x.[24:6];                                           24570000
x ~ 100 | x.[30:6] + 10 | x.[36:6] + x.[42:6];                          24580000
m ~ 0;                                                                  24590000
while x > 0 do                                                          24600000
   begin m ~ m + 1;                                                     24610000
   x ~ x - months[m];                                                   24620000
   end;                                                                 24630000
d ~ x + months[m];                                                      24640000
alphadate(d,m,y,x);                                                     24650000
date ~ x;                                                               24660000
end date;                                                               24670000
%********date***********************************************************24680000
%********debug**********************************************************24690000
% this is the central control routine for the interactive               24700000
% debugging tools.                                                      24710000
procedure debug(returnlabel);                                           24720000
value returnlabel;                                                      24730000
label returnlabel;                                                      24740000
begin integer i, j, k, l, saveuser;                                     24750000
boolean newinst;                                                        24760000
define numcommands= 7 #;                                                24770000
alpha array command[0:numcommands];                                     24780000
switch format fdbug ~                                                   24790000
   ("{!statement ",i*,"~"),                                          %0024800000
   ("{!",i*," statements executed~"),                                %0124810000
   ("{!last label: ",x*,"~"),                                        %0224820000
   ("{!at label: ",x*,"~"),                                          %0324830000
   ("{!type requests...{!~"),                                        %0424840000
   ("{!level = ",i*,"{!~"),                                          %0524850000
   ("{!",x*," not defined{!~"),                                      %0624860000
   ("{!",x*," not in use{!~"),                                       %0724870000
   ("{!unrecognized command{!~"),                                    %0824880000
   ("{!ok{!~"),                                                      %0924890000
   ("{!",x*," executed ",i*," times{!~"),                            %1024900000
   ("{!",x*," = ","""),                                              %1124910000
   ("{!too many labels.{!~"),                                        %1224920000
   ("{!suspended{!~"),                                               %1324930000
   ("{!!end format--fdbug{!!~",(o));                                    24940000
switch format fsuspendreason ~                                          24950000
   ("{!suspend called{!~"),                                          %0024960000
   ("{!rule limit hit{!~"),                                          %0124970000
   ("{!label limit hit{!~"),                                         %0224980000
   ("{!fatal error{!~"),                                             %0324990000
   ("{!end fmt--fsusrsn{!~");                                           25000000
label                                                                   25010000
   getcommand,                                                          25020000
   get1,                                                                25030000
   fail,                                                                25040000
   illegal,                                                             25050000
   resume,                                                              25060000
   runloop;                                                             25070000
%                                                                       25080000
saveuser ~ user;                                                        25090000
user ~ mainuser;                                                        25100000
newinst ~ false;                                                        25110000
debugging ~ true;                                                       25120000
fill command[*] with                                                    25130000
   "end",                                                               25140000
   "type",                                                              25150000
   "set",                                                               25160000
   "run",                                                               25170000
   "label",                                                             25180000
   "abort",                                                             25190000
   "where",                                                             25200000
   "why",                                                               25210000
   0;                                                                   25220000
write(dcwrite[*],fdbug[13]);                                            25230000
if output then;                                                         25240000
getcommand:                                                             25250000
   if not input then go to fail;                                        25260000
get1:                                                                   25270000
   mv(1,arrow,7,dcread[dcsize.w],dcsize.c);                             25280000
   % if inform then write(print,10,dcread[*]);                          25290000
   if char(dcread[*],0) = "-" then % control card;                      25300000
      begin instsize ~ dcsize;                                          25310000
      mv(3,stopper,5,dcread[dcsize.w],dcsize.c);                        25320000
      processcontrolcard(dcread[*]);                                    25330000
      mv(3,crlf,5,dcwrite[*],0);                                        25340000
      if output then;                                                   25350000
      go to getcommand;                                                 25360000
      end;                                                              25370000
   i ~ skipchar(" ",dcread[*],0);                                       25380000
% edit routines go here sometime...                                     25390000
   j ~ i + scanchar(" ","~",dcread[*],i);                               25400000
   aa ~ 0;                                                              25410000
   if j-i > 5 then go to illegal;                                       25420000
   mv(j-i,dcread[*],i,aa,8-j+i);                                        25430000
   for i ~ numcommands step -1 until 0 do                               25440000
      if aa = command[i] then case i of                                 25450000
         begin     % code for various commands:                         25460000
%***************************************                                25470000
% 0: end~                                                               25480000
   begin result ~ true;                                                 25490000
   go to endterpret;                                                    25500000
   end;                                                                 25510000
% 1: type <name>~                                                       25520000
   begin                                                                25530000
   if (aa~searchst(i~(dcsize-j-1),dcread[*],j+1,"symb")) { 0 then       25540000
      begin write(dcwrite[*],fdbug[7],i~min(i,63));                     25550000
      mv(i,dcread[*],j+1,dcwrite[*],2);                                 25560000
      if output then;                                                   25570000
      go to getcommand;                                                 25580000
      end;                                                              25590000
   ab ~ name[aa];                                                       25600000
   ac ~ valu[aa];                                                       25610000
   write(dcwrite[*],fdbug[11],i~min(i,63));                             25620000
   mv(i,dcread[*],j+1,dcwrite[*],2);                                    25630000
   i ~ i + 6; k ~ ac.ch;                                                25640000
   mv(j~min(70-i,l~ac.s),firstchar(ac),dcwrite[i.w],i.c);               25650000
   mv(1,arrow,7,dcwrite[(i+j).w],(i+j).c);                              25660000
   while i + j } 70 do                                                  25670000
      begin if not output then go to getcommand;                        25680000
      k ~ k + j;                                                        25690000
      l ~ l - j;                                                        25700000
      mv(i~2,crlf,5,dcwrite[*],0);                                      25710000
      move(j~min(70-i,l),data[ac.r,k.w],k.c,dcwrite[*],2);              25720000
      end;                                                              25730000
   mv(1,quote,7,dcwrite[(i~i+j).w],i.c);                                25740000
   mv(3,crlf,5,dcwrite[i.w],i.c+1);                                     25750000
   if output then;                                                      25760000
   go to getcommand;                                                    25770000
   end type;                                                            25780000
% 2: set <name>~  <value>~                                              25790000
   begin                                                                25800000
   aa ~ enterst(dcsize-j-1,dcread[*],j+1,"symb");                       25810000
   mv(3,crlf,5,dcwrite[*],0); if output then;                           25820000
   if not input then go to fail;                                        25830000
   ab ~ string(dcsize,aa);                                              25840000
   if death then go to endterpret;                                      25850000
   move(dcsize,dcread[*],0,firstchar(ab));                              25860000
   valu[aa].loc ~ ab;                                                   25870000
   mv(3,crlf,5,dcwrite[*],0); if output then;                           25880000
   go to getcommand;                                                    25890000
   end set;                                                             25900000
% 3: run <limit> from <label> to <label> <label> <label> ...~           25910000
   begin                                                                25920000
   i1 ~ nlabellimit;  % save in case of  "to~".                         25930000
   nlabellimit ~ -1;  % -1 means no to-part found yet.                  25940000
   debugrulelimitexists ~ newinst ~ false;                              25950000
runloop:                                                                25960000
   j ~ j + skipchar(" ",dcread[j.w],j.c);                               25970000
   if i2 ~ char(dcread[j.w],j.c) = "~" then go to resume;               25980000
   if i2 { 9 then % <integer>                                           25990000
      begin                                                             26000000
      if debugrulelimitexists then % two of them--error                 26010000
         begin write(dcwrite[*],feh,qmark);                             26020000
         if output then;                                                26030000
         go to getcommand;                                              26040000
         end;                                                           26050000
      i ~ 0;    % for building limit                                    26060000
      do begin i ~ i|10 + i2;                                           26070000
         j ~ j + 1;                                                     26080000
         end until i2~char(dcread[j.w],j.c) > 9;                        26090000
      debugrulelimitexists ~ true;                                      26100000
      debugrulelimit ~ rules[0] + i;                                    26110000
      go to runloop;                                                    26120000
      end;                                                              26130000
   if (i~mnemno(1,dcread[*],j)) = 1 then                                26140000
      begin    % from <label>                                           26150000
      if newinst then   % two of them--error                            26160000
         begin write(dcwrite[*],feh,qmark);                             26170000
         if output then;                                                26180000
         go to getcommand;                                              26190000
         end;                                                           26200000
      j ~ j + skipchar(" ",dcread[j.w],j.c);                            26210000
      i ~ scanchar(" ","~",dcread[j.w],j.c);                            26220000
      if i { 0 then go to illegal;                                      26230000
      aa ~ searchst(i,dcread[*],j,"inst");                              26240000
      if (ab~valu[aa]).s { 9 then  % no such label:                     26250000
         begin write(dcwrite[*],fdbug[6],k~min(63,i));                  26260000
         mv(k,dcread[j.w],j.c,dcwrite[*],2);                            26270000
         if output then;                                                26280000
         go to getcommand;                                              26290000
         end;                                                           26300000
      newinst ~ true;                                                   26310000
      pst[0] ~ aa;                                                      26320000
      j ~ j + i;                                                        26330000
      go to runloop;                                                    26340000
      end;                                                              26350000
   if i = 2 then                                                        26360000
      begin    % to <label> <label> <label> ...~                        26370000
      j ~ j + skipchar(" ",dcread[j.w],j.c);                            26380000
      if char(dcread[j.w],j.c) = "~" then                               26390000
         begin     % to~  (same limits as last time)                    26400000
         nlabellimit ~ i1;                                              26410000
         go to resume;                                                  26420000
      end;                                                              26430000
      do begin     % find labels;                                       26440000
         i ~ scanchar(" ","~",dcread[j.w],j.c);                         26450000
         if i > 0 then  % label found                                   26460000
            begin                                                       26470000
            if (nlabellimit~nlabellimit+1) > maxlabellimit then         26480000
               begin    % too many labels:                              26490000
               write(dcwrite[*],fdbug[12]);                             26500000
               if output then;                                          26510000
               go to getcommand;                                        26520000
               end;                                                     26530000
            if labellimit[nlabellimit]~searchst(i,dcread[*],j,"inst")   26540000
                  { 0 then   % no such label:                           26550000
               begin write(dcwrite[*],fdbug[6],k~min(63,i));            26560000
               mv(k,dcread[j.w],j.c,dcwrite[*],2);                      26570000
               if output then;                                          26580000
               go to getcommand;                                        26590000
               end;                                                     26600000
            j ~ j + i + skipchar(" ",dcread[(j+i).w],(j+i).c);          26610000
            end;                                                        26620000
         end until char(dcread[j.w],j.c) = "~";                         26630000
      go to resume;                                                     26640000
      end;                                                              26650000
   % fall through: invalid delimiter:                                   26660000
   go to illegal;                                                       26670000
   end run;                                                             26680000
% 4: label <label>~                                                     26690000
   begin                                                                26700000
   if (aa~searchst(i~(dcsize-j-1),dcread[*],j+1,"inst")) { 0            26710000
      then write(dcwrite[*],fdbug[6],i~min(i,63))                       26720000
      else write(dcwrite[*],fdbug[10],i~min(i,63),                      26730000
           digits(k~valu[aa].link),k);                                  26740000
   mv(i,dcread[*],j+1,dcwrite[*],2);                                    26750000
   if output then;                                                      26760000
   go to getcommand;                                                    26770000
   end label;                                                           26780000
% 5: abort ~                                                            26790000
   begin result ~ false;                                                26800000
   go to endterpret;                                                    26810000
   end abort;                                                           26820000
% 6: where~ gives place  of suspension.                                 26830000
   begin                                                                26840000
   % type statement number:                                             26850000
   write(dcwrite[*],fdbug[0],digits(instno),instno);                    26860000
   if not output then go to getcommand;                                 26870000
   % type number of rules executed.                                     26880000
   write(dcwrite[*],fdbug[1],digits(rules[0]),rules[0]);                26890000
   if not output then go to getcommand;                                 26900000
   % last label:                                                        26910000
   aa ~ name[entry];                                                    26920000
   j ~ min(aa.s,63);                                                    26930000
   if instruct > 0 or nearpoint > 9 then                                26940000
      begin write(dcwrite[*],fdbug[2],j);                               26950000
      i ~ 14;                                                           26960000
      end else                                                          26970000
      begin write(dcwrite[*],fdbug[3],j);                               26980000
      i ~ 12;                                                           26990000
      end;                                                              27000000
   mv(j,firstchar(aa),dcwrite[*],i);                                    27010000
   if not output then go to getcommand;                                 27020000
   % type level:                                                        27030000
   write(dcwrite[*],fdbug[5],digits(level),level);                      27040000
   if output then;                                                      27050000
   go to getcommand;                                                    27060000
   end;                                                                 27070000
% 7: why~    gives reasons for suspension.                              27080000
   begin                                                                27090000
   for i ~ 0 step 1 until maxsuspendreason do                           27100000
      if suspendreason[i] then                                          27110000
         begin write(dcwrite[*],fsuspendreason[i]);                     27120000
         if not output then go to getcommand;                           27130000
         end;                                                           27140000
   go to getcommand;                                                    27150000
   end;                                                                 27160000
%***************************************                                27170000
      end command cases;                                                27180000
illegal:                                                                27190000
   write(dcwrite[*],fdbug[8]);                                          27200000
   if output then;                                                      27210000
   go to getcommand;                                                    27220000
fail:                                                                   27230000
   if input then go to get1;                                            27240000
   debugrulelimitexists ~ false;                                        27250000
resume:                                                                 27260000
   write(dcwrite[*],fdbug[9]);                                          27270000
   if output then;                                                      27280000
   setlimitflag;                                                        27290000
   user ~ saveuser;                                                     27300000
   for i ~ 0 step 1 until maxsuspendreason do suspendreason[i] ~ false; 27310000
   if newinst then go to returnlabel;                                   27320000
   aa ~ pst[0];                                                         27330000
   % aa contains the symbol table addressof the next inst.              27340000
end debug;                                                              27350000
%********debug**********************************************************27360000
%********digits*********************************************************27370000
integer procedure digits(n);                                            27380000
   value n;                                                             27390000
   real n;                                                              27400000
begin integer d;                                                        27410000
d ~ if n > 0 then 0 else 1;                                             27420000
n ~ entier(abs(n));                                                     27430000
while n > 0 do                                                          27440000
   begin d ~ d + 1;                                                     27450000
   n ~ entier(n div 10);                                                27460000
   end;                                                                 27470000
digits ~ d;                                                             27480000
end digits;                                                             27490000
%********digits*********************************************************27500000
%********enterst********************************************************27510000
% enterst(n,l,p,x) searches the symbol table for the object of          27520000
% type x (see below); if the object is not present, a new entry         27530000
% is created for it.  the return value is the symb table address        27540000
% of the object.  the name consits of the n chars starting from         27550000
% l[p.w],p.c--n can be any (non-negative) number.                       27560000
% if the symbol table is full and a new entry must be created,          27570000
% messages are printed (lp and tt), and -1 is returned.  also,          27580000
% the procedure newcell will have set the death flag true.              27590000
alpha procedure enterst(n,l,p,x);                                       27600000
   value n, p, x;                                                       27610000
   integer n, p;                                                        27620000
   alpha array l[0];                                                    27630000
   alpha x;                                                             27640000
begin alpha j, k;                                                       27650000
integer i, y, m, xtest;                                                 27660000
label found, fail, return, create;                                      27670000
define stword = (if boolean(y) then valu[i] else name[i])#;             27680000
%                                                                       27690000
xtest ~ if x = "symb" then 0 else                                       27700000
        if x = "lit"  then 1 else                                       27710000
        if x = "fct"  then 2 else                                       27720000
        if x = "inst" then 3 else 0;                                    27730000
y ~ if x = "lit" then 1 else 0;                                         27740000
i ~ scatter(n,l,p,x);                                                   27750000
while true do                                                           27760000
   % if you dont understand this, you arent necessarily stupid:         27770000
   begin if (if n ! (k ~ stword).s                                      27780000
             then false                                                 27790000
             else equal(n,l[p.w],p.c,firstchar(k)))                     27800000
         then if (if n = 0 then (k.loc ! 0) else true)                  27810000
              then if (if x = "lit"                                     27820000
                       then name[i]                                     27830000
                       else k).type = xtest                             27840000
                   then go to found;                                    27850000
   if x = "lit" then k ~ name[i];                                       27860000
   if k.link = 0 then go to create;                                     27870000
   i ~ k.link;                                                          27880000
   end;                                                                 27890000
create:                                                                 27900000
   begin define dummy=#;                                                27910000
   j ~ string(n,0);                                                     27920000
   move(n,l[p.w],p.c,firstchar(j));                                     27930000
   if stword.loc ! 0 then                                               27940000
      begin m ~ newcell(i.str);                                         27950000
      if death then go to fail;                                         27960000
      name[i].link ~ i ~ m;                                             27970000
      end;                                                              27980000
   name[i] ~ if boolean(y) then 1 else j;                               27990000
   valu[i] ~ if boolean(y) then j else 1;                               28000000
   m ~ j.ch - 2;                                                        28010000
   mv(2,i,6,data[j.r,m.w],m.c);                                         28020000
   name[i].type ~ xtest;                                                28030000
   if x = "fct" then                                                    28040000
      begin                                                             28050000
      k ~ intrinsic(l,p,n);                                             28060000
      if k ! 0 then valu[i] ~ 1 & k clink;                              28070000
      end;                                                              28080000
   if traceall then                                                     28090000
      begin valu[i].inuse ~ (if x="fct" then 3 else 1);                 28100000
      io[i] ~ 0 & 2 ciotype & 3 cfilno                                  28110000
         & (if x="fct" then 3 else 1) ciouse;                           28120000
      end;                                                              28130000
   go to found;                                                         28140000
   end;                                                                 28150000
fail:                                                                   28160000
   message0(14);                                                        28170000
   messagett0(14);                                                      28180000
   i ~ -1;                                                              28190000
found: enterst ~ i;                                                     28200000
return:                                                                 28210000
end enterst;                                                            28220000
%********enterst********************************************************28230000
%********findusers******************************************************28240000
procedure findusers;                                                    28250000
begin integer i, j;                                                     28260000
alpha array x[0:2|ttmax];                                               28270000
alpha st1, st2;                                                         28280000
%                                                                       28290000
st1 ~ stat[user].[9:9];                                                 28300000
st2 ~ stat[mainuser].[9:9];                                             28310000
numusers ~ status(x[*]) / 2;                                            28320000
for i ~ numusers-1 step -1 until 0 do                                   28330000
   begin j ~ i | 2;                                                     28340000
   stat[i] ~ x[j];                                                      28350000
   id[i] ~ x[j+1];                                                      28360000
   end;                                                                 28370000
if st2 ! stat[mainuser].[9:9] then                                      28380000
   begin mainuser ~ 0;                                                  28390000
   for i ~ numusers-1 step -1 until 0 do                                28400000
      if stat[i].[9:9] = st2 then mainuser ~ i;                         28410000
   end;                                                                 28420000
if st1 ! stat[user].[9:9] then                                          28430000
   begin user ~ -1;                                                     28440000
   for i ~ 0 step 1 while user < 0 and i < numusers do                  28450000
      if st1 = stat[i].[9:9] then user ~ i;                             28460000
   if user < 0 then user ~ mainuser;                                    28470000
   end;                                                                 28480000
datacomf ~ numusers > 0;                                                28490000
end findusers;                                                          28500000
%********findusers******************************************************28510000
%********garbage collector**********************************************28520000
procedure garbagecollector;                                             28530000
%                                                                       28540000
begin integer i,k,m,max,p,rows,st,total;                                28550000
real timecp, timeio;                                                    28560000
alpha j;                                                                28570000
integer array newpntr[0:datasize];                                      28580000
label l;                                                                28590000
%                                                                       28600000
timecp ~ time(2); timeio ~ time(3);                                     28610000
if inform then                                                          28620000
   begin                                                                28630000
   write(print,fgc);                                                    28640000
   writetime(0,0);                                                      28650000
   checksymbtabl;                                                       28660000
   end;                                                                 28670000
%  free strings attached to cells on available space lists:             28680000
for i ~ 0 step 1 until strmax do if usedst[i] then                      28690000
   begin k ~ nextcell[i];                                               28700000
   while k ! 0 do                                                       28710000
      begin name[k].loc ~ valu[k] ~ 0;                                  28720000
      k ~ name[k].link;                                                 28730000
      end;                                                              28740000
   end;                                                                 28750000
% check for cells held a long time, then discard:                       28760000
if gcs.c = 0 then                                                       28770000
   fill notmoved[*] with 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                 28780000
                         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;                 28790000
max ~ total ~ rows ~ 0;                                                 28800000
if not death then                                                       28810000
for i ~ 0 step 1 until datasize do                                      28820000
   if usedrow[i] then                                                   28830000
      begin                                                             28840000
      rows ~ rows + 1;                                                  28850000
      mv(1,qmark,7,data[i,dpntr[i].w],dpntr[i].c);                      28860000
      p ~ newpntr[i] ~ notmoved[i];                                     28870000
      l: p ~ p + scanchar(qmark,qmark,data[i,p.w],p.c);                 28880000
      if p < dpntr[i] then                                              28890000
         begin mv(2,data[i,p.w],p.c+1,st,6);                            28900000
         for k ~ 1,0 do                                                 28910000
            begin                                                       28920000
            j ~ if boolean(k) then valu[st] else name[st];              28930000
            if j.ch = p+3 then                                          28940000
            if j.r = i then if j.ch-3 > newpntr[i] then                 28950000
               begin m ~ j.ch - 3;                                      28960000
               move(j.s+3,data[i,m.w],m.c,                              28970000
                  data[i,newpntr[i].w],newpntr[i].c);                   28980000
               if boolean(k)                                            28990000
                  then valu[st].ch ~ newpntr[i] + 3                     29000000
                  else name[st].ch ~ newpntr[i] + 3;                    29010000
               newpntr[i] ~ newpntr[i] + j.s + 3;                       29020000
               p ~ p + j.s + 3;                                         29030000
               go to l;                                                 29040000
               end else                                                 29050000
               begin p ~ p + j.s + 3;                                   29060000
               notmoved[i] ~ newpntr[i] ~ p;                            29070000
               go to l;                                                 29080000
               end;                                                     29090000
            end;                                                        29100000
         p ~ p + 1; go to l;                                            29110000
         end;                                                           29120000
      if 8184 - (dpntr[i] ~ newpntr[i]) > max then                      29130000
         max ~ 8184 - dpntr[i];                                         29140000
      total ~ total + 8184 - dpntr[i];                                  29150000
      end;                                                              29160000
if max < 1000 or total < 2000 then                                      29170000
   begin i ~ 0;                                                         29180000
   while usedrow[i] and i < datasize do i ~ i + 1;                      29190000
   usedrow[i] ~ true;                                                   29200000
   end;                                                                 29210000
checksymbtabl;                                                          29220000
if inform then                                                          29230000
   begin                                                                29240000
   writetime(0,0);                                                      29250000
   write(print,fgcres,rows,max,total);                                  29260000
   end;                                                                 29270000
gcs ~ gcs + 1;                                                          29280000
gctimecp ~ gctimecp + (time(2)-timecp)/60;                              29290000
gctimeio ~ gctimeio + (time(3)-timeio)/60;                              29300000
end garbagecollector;                                                   29310000
%********garbage collector**********************************************29320000
%********indirect*******************************************************29330000
% indirect(sp) indirects on the string names by stack[i], and           29340000
% leaves the result in the same stack location.  this routine is        29350000
% called by various intrinsic functions that need to interpret          29360000
% their parameters as string names.                                     29370000
procedure indirect(sp);                                                 29380000
value sp; integer sp;                                                   29390000
begin alpha aa, ab;                                                     29400000
% if inform then inform0(19);                                           29410000
aa ~ pst[sp];                                                           29420000
ab ~ valu[aa];                                                          29430000
pst[sp] ~ enterst(ab.s,data[ab.r,*],ab.ch,"symb");                      29440000
pname[sp] ~ true;                                                       29450000
end indirect;                                                           29460000
%********indirect*******************************************************29470000
%********inform*********************************************************29480000
%  the following procedures are called only to output certain           29490000
%  infomrative messages.  the procedure names consit of "inform"        29500000
%  followed by a tgring of "i"-s or "a"-s, telling what sotr of         29510000
%  format the parameters will be written out as.  the first parameter   29520000
%  gives the subscript to a switch format.                              29530000
%                                                                       29540000
procedure inform0(i);                                                   29550000
value i; integer i;                                                     29560000
begin switch format nfrm0 ~                                             29570000
   (x80,"scansuccess"),                                              %0029580000
   (x80,"assignment of string variables"),                           %0129590000
   (x80,"delete pattern"),                                           %0229600000
   (x80,"rreturn"),                                                  %0329610000
   (x80,"instruction failed"),                                       %0429620000
   (x80,"start of define segment"),                                  %0529630000
   (x80,"end of define segment"),                                    %0629640000
   (x80,"returntemps"),                                              %0729650000
   (x80,"scan failed"),                                              %0829660000
   (/"**illegal argument to .s"),                                    %0929670000
   (//"**dummy format--nfrm0[10]",i10),                              %1029680000
   (///"**send copy of program to system authors."//),               %1129690000
   (x90,"scan--constant"),                                           %1229700000
   (x90,"scan--dropback"),                                           %1329710000
   (x80,"function"),                                                 %1429720000
   (x80,"group"),                                                    %1529730000
   (x80,"indirection"),                                              %1629740000
   (x80,"dotfct"),                                                   %1729750000
   (x80,"element"),                                                  %1829760000
   (x80,"indirect"),                                                 %1929770000
   (x80,"**combineartithmetic."),                                    %2029780000
   (x80,"**combinegroup."),                                          %2129790000
   (x80,"**combineindirection."),                                    %2229800000
   (x80,"**combinestrvarname."),                                     %2329810000
   (x80,"**combinegotopart."),                                       %2429820000
   (x80,"**combinefunction."),                                       %2529830000
   (x80,"go-to part"),                                               %2629840000
   (x80,"**condenseparttern"),                                       %2729850000
   (x80,"**condensereplacement"),                                    %2829860000
   (x80,"**semicolon"),                                              %2929870000
   (x80,"**insert string convert"),                                  %3029880000
   (/"**end format--nfrm0");                                            29890000
write(print,nfrm0[i]);                                                  29900000
end inform0;                                                            29910000
procedure informa(i,p);                                                 29920000
value i, p; integer i; alpha p;                                         29930000
begin switch format nfrma ~                                             29940000
    (/"**entry = ",a2),                                              %0029950000
    (x80,"push(",a2,")"),                                            %0129960000
    (x80,"pop(",a2,")"),                                             %0229970000
    (x80,"returncell(",a2,")"),                                      %0329980000
    (x80,"program segment = ",a6),                                   %0429990000
    (//"**illegal i/o descriptor at word ",a2),                      %0530000000
    (/"**end format--nfrma",a6);                                        30010000
if i > 5 or i < 0 then i ~ 5;                                           30020000
write(print,nfrma[i],p);                                                30030000
end infomra;                                                            30040000
procedure informi(i,p);                                                 30050000
value i, p; integer i, p;                                               30060000
begin switch format nfrmi ~                                             30070000
   (x80,"fixed length = ",i4),                                       %0030080000
   (//"invalid type ",i5," in grouping."),                           %0130090000
   (//"error in dotfct in statement ",i6/),                          %0230100000
   (//"error in grouping in statement ",i6/),                        %0330110000
   (//"interpreter stack overflow in statement ",i6//),              %0430120000
   (//"**pattern error in statement ",i6),                           %0530130000
   (x80,"input from file ",i2),                                      %0630140000
   (x80,"tempcell(",i2,") called."),                                 %0730150000
   (x80,"instno = ",i6),                                             %0830160000
   (x80,"interpreter called--level = ",i3),                          %0930170000
   (x80,"end interpreter--level = ",i3),                             %1030180000
   (x80,"intrinsic ",i2),                                            %1130190000
   (x80,"numval = ",i12),                                            %1230200000
   (x80,"output to file ",i2),                                       %1330210000
   (/"**end format--nfrmi",i10);                                        30220000
write(print,nfrmi[i],p);                                                30230000
end informi;                                                            30240000
procedure informia(i,p1,p2);                                            30250000
value i, p1, p2; integer i, p1; alpha p2;                               30260000
begin switch format nfrmia ~                                            30270000
   (x80,"tempcel(",i2,") = ",a2),                                    %0030280000
   (x80,"newcell(",i2,") = ",a2),                                    %0130290000
   (x80,"sp = ",i3,"; code =",a6),                                   %0230300000
   (/"**end format--nfrmia",i10,a6);                                    30310000
write(print,nfrmia[i],p1,p2);                                           30320000
end informia;                                                           30330000
procedure informii(i,p1,p2);                                            30340000
value i, p1, p2;                                                        30350000
integer i, p1, p2;                                                      30360000
begin switch format nfrmii ~                                            30370000
   ("dummy format--nfrmii[0]",2i10),                                 %0030380000
   ("dummy format--nfrmii[1]",2i10),                                 %0130390000
   (x80,"**dummy format--nfrmii[2]"),                                %0230400000
   (//"**fatal error in scanner in statement ",i6,"; sp = ",i4),     %0330410000
   (x80,"tt in from ",i2,"/",i2),                                    %0430420000
   (x80,"tt out to  ",i2,"/",i2),                                    %0530430000
   (x85,"scan--sp = ",i3,", point = ",i4),                           %0630440000
   (/"**end format--nfrmii",2i10);                                      30450000
write(print,nfrmii[i],p1,p2);                                           30460000
end informii;                                                           30470000
%********inform*********************************************************30480000
%********initializesymbtabl*********************************************30490000
procedure initializesymbtabl;                                           30500000
begin define dummy=#;                                                   30510000
for i ~ 0 step 1 until scatterno do                                     30520000
   begin                                                                30530000
   for j ~ scattersize+16 step 1 while j < stwmax do                    30540000
      namtabl[i,j].link ~ (j+1) & i concstr;                            30550000
   nextcell[i] ~ (scattersize+16) & i concstr;                          30560000
   usedst[i] ~ true;                                                    30570000
   end;                                                                 30580000
symbtablsetup ~ true;                                                   30590000
end initializesymtabl;                                                  30600000
%********initializesymbtabl*********************************************30610000
%********input**********************************************************30620000
% teletype input procedure:                                             30630000
boolean procedure input;                                                30640000
begin                                                                   30650000
switch format flags ~ ("{!flags[0]{!~"),                                30660000
          ("!{  message was too long...please reenter!{~"),             30670000
          ("!{  message  was  partly lost...please reenter!{~");        30680000
array sink[0:bufinsize-1];                                              30690000
integer siz, timex, fl, q, r;                                           30700000
label loop, nogo, abnorm, checkit, exit, fail;                          30710000
alpha s;                                                                30720000
integer stream procedure size(a);                                       30730000
          begin si ~ a; tally ~ 0;                                      30740000
            dcinchar(if sc="~" then jump out; si~si+1; tally~tally+1);  30750000
            size ~ tally                                                30760000
          end size;                                                     30770000
stream procedure move(a,b,c,d); value c, d;                             30780000
          begin si~a; di~b; di~di+d; ds~c chr  end move;                30790000
%                                                                       30800000
% if inform then informii(4,stat[user].[9:4],stat[user].[14:4]);        30810000
if not datacomf then go to fail;                                        30820000
input ~ true;                                                           30830000
break ~ false;                                                          30840000
fl ~ dcsize ~ 0;                                                        30850000
timex ~ time(1);                                                        30860000
loop: q ~ dcsize div 8; r ~ dcsize mod 8;                               30870000
   if datacomf                                                          30880000
      then read(dcin(stat[user],0),bufinsize,sink[*]) [nogo:abnorm]     30890000
      else go to fail;                                                  30900000
   if boolean((s~status(stat[user],0)).[28:1]) then                     30910000
      begin % buffer overflow                                           30920000
      fl ~ 2;                                                           30930000
      go to loop;                                                       30940000
      end;                                                              30950000
      timex ~ time(1);                                                  30960000
   if boolean(sink[0].[25:1])                                           30970000
      then siz ~ dcinchar                                               30980000
      else siz ~ size(sink[1]);                                         30990000
   if dcsize ~ dcsize + siz > msgsize                                   31000000
      then fl ~ 1                                                       31010000
      else move(sink[1],dcread[q],siz,r);                               31020000
   if boolean(sink[0].[25:1])                                           31030000
      then go to loop;                                                  31040000
checkit: % check for overflow and transmission error                    31050000
   if fl > 0 then                                                       31060000
      begin write(dcwrite[*],flags[fl]);                                31070000
      if not output then go to fail;                                    31080000
      if input then go to exit;                                         31090000
      end else go to exit;                                              31100000
abnorm:  s ~ status(stat[user],0);                                      31110000
   % [28:1] = 1 if buffer overflow                                      31120000
   if boolean(s.[28:1]) then fl ~ 2;                                    31130000
   % [23:1]  = 1 if abnormal condition                                  31140000
   % [24:1]  = 1 if buffer is read ready                                31150000
   % [30:1]  = 1 if unit not ready                                      31160000
   if s.[23:2]=3 or boolean(s.[30:1]) then go to fail;                  31170000
   read(dcin(stat[user],0),bufinsize,sink[*]) [nogo:nogo];              31180000
nogo:                                                                   31190000
   if time(1) - timex < waittime then                                   31200000
      begin when(1); go to loop; end;                                   31210000
   s ~ status(stat[user],1);                                            31220000
   if boolean(s.[30:1]) then go to fail;                                31230000
   if boolean(s.[28:1]) then                                            31240000
      begin fl ~ 2; go to loop; end;                                    31250000
fail:                                                                   31260000
   input ~ false;                                                       31270000
   findusers;                                                           31280000
exit:   end input;                                                      31290000
%========== end data com input procedure ===============================31300000
%********insertstringconvert********************************************31310000
procedure insertstringconvert(sp);                                      31320000
   value sp;                                                            31330000
   integer sp;                                                          31340000
begin integer i;                                                        31350000
% if inform then inform0(30);                                           31360000
i ~ ppoint[sp] + psize[sp];                                             31370000
aa ~ ".s";                                                              31380000
mv(2,aa,6,code[i.w],i.c);                                               31390000
psize[sp] ~ psize[sp] + 2;                                              31400000
pname[sp] ~ false;                                                      31410000
ptype[sp] ~ 19;  % combined arithmetic expression                       31420000
end insertstringconvert;                                                31430000
%********insertstringconvert********************************************31440000
%********interpreter****************************************************31450000
% this is the central control routine for the interpreter.  it is       31460000
% several thousands cards long.                                         31470000
procedure interpreter;                                                  31480000
begin                                                                   31490000
%******************                                                     31500000
integer stream procedure char(l,i);                                     31510000
value i;                                                                31520000
begin si ~ l; si ~ si + i;                                              31530000
di ~ loc char; di ~ di + 7;                                             31540000
ds ~ 1 chr;                                                             31550000
end char;                                                               31560000
%******************                                                     31570000
boolean stream procedure eq(n,l1,i1,l2,i2);                             31580000
value n, i1, i2;                                                        31590000
begin si ~ l1; si ~ si + i1;                                            31600000
di ~ l2; di ~ di + i2;                                                  31610000
n(if sc ! dc then jump out);                                            31620000
if toggle then tally ~ 0 else tally ~ 1;                                31630000
eq ~ tally;                                                             31640000
end eq;                                                                 31650000
%******************                                                     31660000
stream procedure mv(n,l1,i1,l2,i2);                                     31670000
value n, i1, i2;                                                        31680000
begin si ~ l1; si ~ si + i1;                                            31690000
di ~ l2; di ~ di + i2;                                                  31700000
ds ~ n chr;                                                             31710000
end move;                                                               31720000
%******************                                                     31730000
alpha                                                                   31740000
   fct,                                                                 31750000
   fctn,                                                                31760000
   fctv,                                                                31770000
   returnval;                                                           31780000
alpha array                                                             31790000
   inst[0:maxinstsize.w];                                               31800000
define                                                                  31810000
   die = go to dead #,                                                  31820000
   fail=go to failed#;                                                  31830000
boolean ingotopart;                                                     31840000
alpha firstch;                                                          31850000
label                                                                   31860000
   arithovfl,      % integer overflow in arithmetic                     31870000
   branch,         % intrinsic fct case swt                             31880000
   dead,           % fatal error label                                  31890000
   definedfct,     % program-defined function                           31900000
   fctfail,        % failure of function calls                          31910000
   dvdzero,        % divide-by-zero in arithmetic                       31920000
   failed,         % statement failure label                            31930000
   fixerr,                                                              31940000
   goto,                                                                31950000
   interpret,                                                           31960000
   limithit,                                                            31970000
   minlef,                                                              31980000
   nonnumeric,     % non-num arith operand                              31990000
   perror,                                                              32000000
   pfix,                                                                32010000
   pscan,                                                               32020000
   refset,                                                              32030000
   return,                                                              32040000
   scanfailure,                                                         32050000
   setgo,                                                               32060000
   succeed,        % function success label                             32070000
   undeffct,       % call of undefined function                         32080000
   undefined;      % undefined label                                    32090000
label    % local to scanner:                                            32100000
   balance,                                                             32110000
   dropback,                                                            32120000
   newpoint,                                                            32130000
   nextpattern,                                                         32140000
   scanerr,                                                             32150000
   scansuccess,                                                         32160000
   sizefailure;                                                         32170000
%                                                                       32180000
nearpoint ~ 9;                                                          32190000
level ~ level + 1;                                                      32200000
aa ~ entry;                                                             32210000
entry ~ rules[level] ~ 0;                                               32220000
% if inform then informi(9,level);                                      32230000
go to setgo;                                                            32240000
%                                                                       32250000
interpret:                                                              32260000
   % start of a single instruction                                      32270000
   if death then die;                                                   32280000
%  if inform then                                                       32290000
%     begin write(print,fbl);                                           32300000
%     write(print,17,inst[*]);                                          32310000
%     informi(8,instno);                                                32320000
%     writetime(0,0);                                                   32330000
%     end;                                                              32340000
   if alimitexists then                                                 32350000
      begin                                                             32360000
      if rulelimitexists then                                           32370000
         if rules[0] > rulelimit then go to limithit;                   32380000
      if cpulimitexists then                                            32390000
         if time(2) > cpulimit then go to limithit;                     32400000
      if iolimitexists then                                             32410000
         if time(3) > iolimit then go to limithit;                      32420000
      if debugging then                                                 32430000
         if debugrulelimitexists then                                   32440000
            if debugrulelimit { rules[0] then                           32450000
               begin suspendreason[1] ~ true;                           32460000
               debug(setgo);                                            32470000
               end;                                                     32480000
      end;                                                              32490000
   rules[0] ~ rules[0] + 1;         % incr global rule count.           32500000
   rules[level] ~ rules[level] + 1; % incr local rule count.            32510000
   sp ~ rsize ~ frontend ~ rearend ~ 0;                                 32520000
   ingotopart ~ selfreflag ~ noreplacement ~ varflag ~ false;           32530000
   success ~ true;                                                      32540000
   relativepointer ~ 1;                                                 32550000
   % controlpoint should be at the 1st char of the instruction.         32560000
   % first char no longer in use by interpreter.                        32570000
pscan:   % next pattern element                                         32580000
   if (nearpoint~nearpoint+relativepointer) } 63 then                   32590000
      begin instruct ~ instruct + nearpoint.w;                          32600000
      nearpoint ~ nearpoint.c;                                          32610000
      end;                                                              32620000
   relativepointer ~ 0;                                                 32630000
   % controlpoint should now point to the next pattern element.         32640000
   mv(3,controlpoint,aa,2);  % get next piece of code.                  32650000
   % if inform then informaa(4,aa);                                     32660000
   case aa.c2 of                                                        32670000
      begin                                                             32680000
%***************************************                                32690000
%********op codes***********************                                32700000
% 0-9: errors                                                           32710000
   ;;;;;;;;;;                                                           32720000
%***************************************                                32730000
%********function call******************                                32740000
% 10: "#"  function call                                                32750000
   % 2-char pointer to symb table loc of fct                            32760000
   % 1 char giving the number of parameters.                            32770000
   begin                                                                32780000
   % if inform then inform0(14);                                        32790000
   mks ~ sp - char(controlpoint+3); % find first param,                 32800000
   returnval ~ 0; % holds st loc of return value.                       32810000
   fct ~ aa.[18:12];                                                    32820000
   ptype[mks] ~ 1;                                                      32830000
   fctv ~ valu[fct];                                                    32840000
branch:                                                                 32850000
   if boolean(fctv.inuse) then                                          32860000
      if not tracefctcall(fct) then go to fctfail;                      32870000
   if boolean(fctv.[1:1]) then go to definedfct;                        32880000
   % if inform then informii(11,fctv.link);                             32890000
   case fctv.link of                                                    32900000
%***************************************                                32910000
%********intrinsic functions************                                32920000
% the intrinsic functions are arranged in the  following order:         32930000
%   1 anchor                                                            32940000
%   2 callf                                                             32950000
%   3 close                                                             32960000
%   4 date                                                              32970000
%   5 define                                                            32980000
%   6 detach                                                            32990000
%   7 dump                                                              33000000
%   8 eof                                                               33010000
%   9 .eq                                                               33020000
%  10 equals                                                            33030000
%  11 execute                                                           33040000
%  12 file                                                              33050000
%  13 fill                                                              33060000
%  14 .ge                                                               33070000
%  15 .gt                                                               33080000
%  16 .le                                                               33090000
%  17 level                                                             33100000
%  18 look                                                              33110000
%  19 .lt                                                               33120000
%  20 mode                                                              33130000
%  21 .ne                                                               33140000
%  22 .num                                                              33150000
%  23 opsyn                                                             33160000
%  24 page                                                              33170000
%  25 pop                                                               33180000
%  26 push                                                              33190000
%  27 .remdr                                                            33200000
%  28 rewind                                                            33210000
%  29 rules                                                             33220000
%  30 size                                                              33230000
%  31 space                                                             33240000
%  32 time                                                              33250000
%  33 traces                                                            33260000
%  34 tracef                                                            33270000
%  35 tracel                                                            33280000
%  36 trim                                                              33290000
%  37 unanch                                                            33300000
%  38 uneql                                                             33310000
%  39 wait                                                              33320000
%  40 suspend                                                           33330000
%  41 status                                                            33340000
%  42 user                                                              33350000
%  43 seek                                                              33360000
%  44 release                                                           33370000
%  45 record                                                            33380000
%  46 trace                                                             33390000
%  47 assign                                                            33400000
%  48 copy                                                              33410000
%  49 search                                                            33420000
%  50 .ranf                                                             33430000
%                                                                       33440000
   begin % code for intrinsic functions follows:                        33450000
% 0: undefined                                                          33460000
   go to undeffct;                                                      33470000
% 1: anchor                                                             33480000
   begin ptype[0] ~ 3;                                                  33490000
   if sp > mks then                                                     33500000
      begin if not numval(pst[mks],i1) or i1 < 0                        33510000
         then go to fctfail;                                            33520000
      psize[0] ~ i1;                                                    33530000
      end else psize[0] ~ anchorsize;                                   33540000
   go to succeed;                                                       33550000
   end anchor;                                                          33560000
% 2: callf(f,p1,p2,...,pn)  calls the function named by f, with the     33570000
   % parameters p1, p2, ..., pn.                                        33580000
   begin segment                                                        33590000
   aa ~ pst[mks];                                                       33600000
   ab ~ valu[aa];                                                       33610000
   fct ~ enterst(ab.s,data[ab.r,*],ab.ch,"fct");                        33620000
   FCTV ~ valu[fct];                                                    33630000
   sp ~ sp - 1;                                                         33640000
   for i ~ mks step 1 until sp do                                       33650000
      begin pst[i] ~ pst[i+1];                                          33660000
      pname[i] ~ pname[i+1];                                            33670000
      end;                                                              33680000
   go to branch;                                                        33690000
   end callf;                                                           33700000
% 3: close(f,p)                                                         33710000
   % close(f,p) closes the file associated with $f, in the manner       33720000
   % specified by p, the values of p are:                               33730000
   %     "*"  only for tape files.  the tape is positioned just beyond  33740000
   %        the end-of-file for the current file.  if last i/o          33750000
   %        operation had eof, no action is taken.                      33760000
   %     "lock"  closes the file and saves the unit for the program.    33770000
   %        new disk files are saved for the time given in their declar-33780000
   %        ations; tape files are rewound and the operator is told     33790000
   %        to remove the tape and save it.                             33800000
   %     "release"  releases i/o unit to the system.  tape files are    33810000
   %        rewound and disk files are destroyed if created by          33820000
   %        the program.                                                33830000
   %     "purge"  the file is closed, purged, and released to the       33840000
   %        system.                                                     33850000
   begin segment                                                        33860000
   if sp { mks then go to fctfail;                                      33870000
   if sp-mks = 1 then if not nullargs(1) then go to fctfail;            33880000
   indirect(mks);                                                       33890000
   aa ~ pst[mks];                                                       33900000
   ab ~ pst[mks+1];                                                     33910000
   aa ~ io[aa];                                                         33920000
   if aa.iouse=0 or i1~aa.filno=0 then go to fctfail;                   33930000
   ab ~ valu[ab];                                                       33940000
   if (i2~ab.s) > 7 then go to fctfail;                                 33950000
   ac ~ 0;                                                              33960000
   if i2 = 0                                                            33970000
      then ac ~ 0                                                       33980000
      else mv(i2,firstchar(ab),ac,8-i2);                                33990000
   ac ~ ac;                                                             34000000
   if ac = 0 then close(iofile[i1]) else                                34010000
   if ac = "lock" then lock(iofile[i1],save) else                       34020000
   if ac = "save" then close(iofile[i1],save) else                      34030000
   if ac = "purge" then close(iofile[i1],purge) else                    34040000
   if ac = "release" then                                               34050000
      begin iofileopen[i1] ~ false;                                     34060000
      close(iofile[i1],release);                                        34070000
      end else                                                          34080000
   if ac = "*" then close(iofile[i1],*) else                            34090000
      begin if printmessages then                                       34100000
         begin messagei(8,instno);                                      34110000
         messagetti(8,instno);                                          34120000
         end;                                                           34130000
      go to fctfail;                                                    34140000
      end;                                                              34150000
   go to succeed;                                                       34160000
   end intrinsic function close;                                        34170000
% 4: date() returns the current date in the form:                       34180000
   %           mm/dd/yy                                                 34190000
   begin segment                                                        34200000
   aa ~ date;                                                           34210000
   ab ~ tempcell;                                                       34220000
   ac ~ string(8,ab);                                                   34230000
   mv(8,aa,0,firstchar(ac));                                            34240000
   valu[ab] ~ ac;                                                       34250000
   returnval ~ ab;                                                      34260000
   go to succeed;                                                       34270000
   end ldate;                                                           34280000
% 5: define(a,b,c) creates a snobol function.  the values of the        34290000
   % parameters are of the forms:                                       34300000
   %     a ::= <fct name>  (  <params>  )                               34310000
   %     b ::= <label>                                                  34320000
   %     c ::= <loc vars>                                               34330000
   % <fct name> is a legal snobol identifier.                           34340000
   % <label> is a label that occurs in the program, or is null.  if     34350000
   %     b is null, the entry point is taken to be spelled the same     34360000
   %     as <fct name>.                                                 34370000
   % <params> and <loc vars> are  the formal parameters and local       34380000
   %     variables.  they can be null, or can consist of a list of      34390000
   %     identifiers separated by commas.  see also the procedure       34400000
   %     snbldefine and the define part of processcontrolcard.          34410000
   begin segment                                                        34420000
   if sp - mks < 3 then                                                 34430000
      if not nullargs(3-sp+mks) then go to fctfail;                     34440000
   if snbldefine(pst[mks],pst[mks+1],pst[mks+2])                        34450000
      then go to succeed;                                               34460000
   messagei(9,instno);                                                  34470000
   messagetti(9,instno);                                                34480000
   go to fctfail;                                                       34490000
   end ldefine;                                                         34500000
% 6: detach(f,v) terminates any i/o use of the quantity named by f.     34510000
   % the type of this quantity is determined by the first character     34520000
   % of v, as follows:                                                  34530000
   %     "s" or null = string name                                      34540000
   %     "f"  = function name                                           34550000
   %     "l"  = label                                                   34560000
   begin segment                                                        34570000
   if sp { mks then go to fctfail;                                      34580000
   if sp - mks > 1 then                                                 34590000
      begin aa ~ pst[mks+1];                                            34600000
      ab ~ valu[aa];                                                    34610000
      ac ~ char(firstchar(ab));                                         34620000
      if ab.s = 0 or ac = "s" then ac ~ "symb" else                     34630000
      if ac = "f" then ac ~ "fct" else                                  34640000
      if ac = "l" then ac ~ "inst" else go to fctfail;                  34650000
      end else ac ~ "symb";                                             34660000
   aa ~ pst[mks];                                                       34670000
   ab ~ valu[aa];                                                       34680000
   aa ~ enterst(ab.s,data[ab.r,*],ab.ch,ac);                            34690000
   valu[aa].iouse ~ io[aa] ~ 0;                                         34700000
   go to succeed;                                                       34710000
   end ldetach;                                                         34720000
% 7: dump()                                                             34730000
   begin segment                                                        34740000
   messagei(10,instno); % dump requested...                             34750000
   if inform then begin writest; writedata; end;                        34760000
   stringdump(instno);                                                  34770000
   go to succeed;                                                       34780000
   end dump;                                                            34790000
% 8: eof(f) succeeds if the last i/o operation on the file associated   34800000
   % with $f failed due to end-o-file.  if not, or if $f is not an      34810000
   % i/o string, then eof(f) fails.                                     34820000
   begin segment                                                        34830000
   if sp { mks then go to fctfail;                                      34840000
   indirect(mks);                                                       34850000
   aa ~ valu[pst[mks]];                                                 34860000
   if aa.iouse = 0 then go to fctfail;                                  34870000
   go to if ioeof[aa.filno] then succeed else fctfail;                  34880000
   end eof;                                                             34890000
% 9: .eq(a,b)) succeeds iff both a and b are numeric, and a = b.        34900000
   begin segment                                                        34910000
   if sp - mks < 2 then                                                 34920000
      if not nullargs(2-sp+mks) then go to fctfail;                     34930000
   if numval(pst[mks],aa) and numval(pst[mks+1],ab)                     34940000
       then go to if aa = ab then succeed else fctfail;                 34950000
   if printmessages then                                                34960000
      begin messageai(0,"eq",instno);                                   34970000
      messagettai(0,"eq",instno);                                       34980000
      end;                                                              34990000
   go to fctfail;                                                       35000000
   end;  % .eq(a,b)                                                     35010000
% 10: equals(a,b) succeeds iff a and b have the same strings as values. 35020000
   begin                                                                35030000
   if sp - mks < 2 then                                                 35040000
      if not nullargs(2-sp+mks) then go to fctfail;                     35050000
   ab ~ pst[mks];                                                       35060000
   ac ~ pst[mks+1];                                                     35070000
   ab ~ valu[ab];                                                       35080000
   ac ~ valu[ac];                                                       35090000
   go to if ab.s ! ac.s                                                 35100000
      then fctfail                                                      35110000
      else if equal(ab.s,firstchar(ab),firstchar(ac))                   35120000
         then succeed                                                   35130000
         else fctfail;                                                  35140000
   end lequals;                                                         35150000
% 11: execute(s) currently works if the first char of s is qmark, in    35160000
   % which case the algol "zip" with <array row" is executed on s;      35170000
   % or if s is an input string, in which case the algol "zip with      35180000
   % <file part>" is executed on the file belonging to s, or if s       35190000
   % starts with "-", which is a snobol control card.                   35200000
   begin segment                                                        35210000
   if mks } sp then go to fctfail;                                      35220000
   aa ~ pst[mks];                                                       35230000
   ab ~ valu[aa];                                                       35240000
   if boolean(ab.inuse) then % zip with file                            35250000
      begin                                                             35260000
      if boolean(ab.inuse) and ab.filno > 0 then                        35270000
         begin                                                          35280000
         zip with iofile[ab.filno];                                     35290000
         go to succeed;                                                 35300000
         end;                                                           35310000
      go to fctfail;                                                    35320000
      end;                                                              35330000
   if (i1~char(firstchar(ab))) = qmark then  % mcp control card         35340000
      begin alpha array z[0:ab.[17:10]];                                35350000
      move(stringloc(ab),z[*],0);                                       35360000
      zip with z[*];                                                    35370000
      go to succeed;                                                    35380000
      end;                                                              35390000
   if i1 = "-" then   % snobol control card                             35400000
      begin alpha array scratch[0:(ab.s).w];                            35410000
      instsize ~ ab.s;                                                  35420000
      move(instsize,firstchar(ab),scratch[0],0);                        35430000
      scratch[instsize.w] ~ stopper;                                    35440000
      processcontrolcard(scratch);                                      35450000
      go to succeed;                                                    35460000
      end;                                                              35470000
   go to fctfail;                                                       35480000
   end lexecute;                                                        35490000
%12: file(name,i.o,buffers,rec.size,buff.size,save.fact,dsk.areas,size) 35500000
   % file(...) opens a file, as descibed by the parameters:             35510000
   % name contains the name of the primary i/o string                   35520000
   % i.o starts with "i" for input files, "o" for output files, and     35530000
   %     is null for files with both input and output use.              35540000
   % buffers is the number of buffer areas to be used.                  35550000
   % rec.size is the size (in characters) of an i/o record              35560000
   % buff.size is the size (in characters) of a buffer (physical record)35570000
   % save.fact is the save factor for files created by the program      35580000
   % dsk.areas is the number of disk areas for new disk files ({20)     35590000
   % size is the size of one of these disk areas, in logical records.   35600000
   begin                                                                35610000
   integer                                                              35620000
      areas,                                                            35630000
      asize,                                                            35640000
      blockcount,                                                       35650000
      buffers,                                                          35660000
      bufsize,                                                          35670000
      cyc,                                                              35680000
      recsize,                                                          35690000
      savefactor,                                                       35700000
      typea,        % "algol" type: 9, 10, or 11                        35710000
      types,        % "snobol" type: 1, 2, or 3                         35720000
      unit;                                                             35730000
   monitor print (areas,asize,blockcount,buffers,bufsize,cyc,recsize,   35740000
      iosize,valtabl,iousage,                                           35750000
      savefactor,typea,types,unit,aa,ab,ac,i1,i2);                      35760000
   %                                                                    35770000
   go to undeffct; % until a way is found to implement file declarations35780000
   unit ~ 0;                                                            35790000
   cyc ~ 16;                                                            35800000
   for i ~ 1 step 1 until filmax do                                     35810000
      if not iofileopen[i] then                                         35820000
         if iousage[i].cycle < cyc then                                 35830000
            begin unit ~ i; cyc ~ iousage[i].cycle; end;                35840000
   if unit = 0 then                                                     35850000
      begin messagei(14,instno); % no file available                    35860000
      go to fctfail;                                                    35870000
      end;                                                              35880000
   if sp - mks < 3 then go to fctfail;                                  35890000
   %                                                                    35900000
   aa ~ pst[mks+1];                                                     35910000
   ab ~ valu[aa];                                                       35920000
   if ab.s = 0 then                                                     35930000
      begin typea ~ 11;                                                 35940000
      types ~ 3;                                                        35950000
      end else                                                          35960000
   if (i1~char(data[ab.r,ab.w],ab.c)) = "i" then                        35970000
      begin typea ~ 9;                                                  35980000
      types ~ 2;                                                        35990000
      end else                                                          36000000
   if i1 = "o" then                                                     36010000
      begin typea ~ 10;                                                 36020000
      types ~ 1;                                                        36030000
      end else                                                          36040000
      begin  % error: invalid i/o type                                  36050000
      messagei(15,instno);                                              36060000
      go to fctfail;                                                    36070000
      end;                                                              36080000
   if not numval(pst[mks+2],buffers) or buffers < 1 then                36090000
      begin  % error: invalid buffer number                             36100000
      messagei(16,instno);                                              36110000
      go to fctfail;                                                    36120000
      end;                                                              36130000
   if sp - mks { 3 then recsize ~ 0 else                                36140000
      if not numval(pst[mks+3],recsize) or recsize < 0                  36150000
            or recsize > 8182 then                                      36160000
         begin  % error: invalid record size                            36170000
         go to fctfail;                                                 36180000
         end;                                                           36190000
   iosize[unit] ~ recsize;                                              36200000
   recsize ~ (recsize+7).w;                                             36210000
   if sp - mks { 4 then bufsize ~ 0 else                                36220000
      if not numval(pst[mks+4],bufsize) or bufsize < 0                  36230000
            or bufsize > 8182 then                                      36240000
         begin  % error: invalid buffer size                            36250000
         go to fctfail;                                                 36260000
         end;                                                           36270000
   bufsize ~ (bufsize+7).w;                                             36280000
   if sp - mks { 5 then savefactor ~ 0 else                             36290000
       if not numval(pst[mks+5],savefactor) or savefactor { 0 then      36300000
          begin  % error: invalid savefactor                            36310000
          go to fctfail;                                                36320000
          end;                                                          36330000
   if sp - mks { 6 then areas ~ 0 else                                  36340000
      if not numval(pst[mks+6],areas) or areas < 0                      36350000
            or areas > 20 then                                          36360000
        begin  % error: invalid number of disk areas                    36370000
        go to fctfail;                                                  36380000
        end;                                                            36390000
   if sp - mks { 7 then asize ~ 0 else                                  36400000
      if not numval(pst[mks+7],asize) or asize < 0 then                 36410000
         begin  % error: invalid disk area sizez                        36420000
         go to fctfail;                                                 36430000
         end;                                                           36440000
   cyc ~ iousage[unit].cycle;                                           36450000
   cyc ~ cyc + 1;                                                       36460000
   % create new file here.                                              36470000
   go to succeed;                                                       36480000
   end intrinsic file;                                                  36490000
% 13: fill(name,mfid,fid,media,date,reel,cycle)  files the file         36500000
   % $name with a description of an actual file, as described by        36510000
   % the parameters as follows:                                         36520000
   %     mfid/fid is the external name of the file.  if either          36530000
   %        mfid or fid contain more than 7 chars, only the first 7     36540000
   %        will be used.  if either is null, "0000000" will used.      36550000
   %     media  is one of the media digits listed in the algol manual.  36560000
   %     date is the date that should be used with output files,        36570000
   %        usually the current date.  it can be in the form mm/dd/yy   36580000
   %        or the form yyddd (which is how it is stored in the         36590000
   %        standard file label).                                       36600000
   %     reel is the reel number, for multi-reel tapes                  36610000
   %     cycle is the cycle number, also for tapes mainly.              36620000
   % if any of the parameters is missing, it will not be assigned;      36630000
   % thus, multiple calls of fill() can fill in different pieces of     36640000
   % information.  if file() is to be effective, it must be used        36650000
   % before any i/o is done on the file.                                36660000
   begin alpha st, sio, mfid, fid, d, m, y;                             36670000
   integer med, reel, cyc;                                              36680000
   if sp { mks then go to fctfail;                                      36690000
   if sp - mks < 3 then                                                 36700000
      if not nullargs(3-sp+mks) then go to fctfail;                     36710000
   indirect(mks);                                                       36720000
   st ~ pst[mks];                                                       36730000
   if valu[st].iouse = 0 then go to fctfail;                            36740000
   sio ~ io[st];                                                        36750000
   % get mfid:                                                          36760000
   aa ~ pst[mks+1];                                                     36770000
   ab ~ valu[aa];                                                       36780000
   if ab.s = 0 then mfid ~ -1 else                                      36790000
      begin mv(7,blanks,1,mfid,1);                                      36800000
      mv(min(7,ab.s),firstchar(ab),mfid,1);                             36810000
      end;                                                              36820000
   mfid ~ mfid;                                                         36830000
   % get fid:                                                           36840000
   aa ~ pst[mks+2];                                                     36850000
   ab ~ valu[aa];                                                       36860000
   if ab.s = 0 then fid ~ -1 else                                       36870000
      begin mv(7,blanks,1,fid,1);                                       36880000
      mv(min(7,ab.s),firstchar(ab),fid,1);                              36890000
      end;                                                              36900000
   fid ~ fid;                                                           36910000
   % get media digit;                                                   36920000
   if sp-mks{3 or valtabl[(aa~pst[mks+3]).str,aa.stw].s = 0             36930000
      then med ~ -1 else                                                36940000
      if not numval(aa,med) then go to fctfail;                         36950000
   med ~ med;                                                           36960000
   % get date:                                                          36970000
   if sp-mks { 4 or valtabl[(aa~pst[mks+4]).str,aa.stw].s = 0           36980000
      then d ~ -1 else                                                  36990000
      begin aa ~ pst[mks+4];                                            37000000
      ab ~ valu[aa];                                                    37010000
      if ab.s = 0 then d ~ -1 else                                      37020000
      if ab.s = 5 then                                                  37030000
         mv(5,firstchar(ab),d,3) else                                   37040000
      if ab.s = 8 then                                                  37050000
         begin mv(8,firstchar(ab),d,0);                                 37060000
         if char(d,0) > 1 then go to fctfail;                           37070000
         if d.[12:8] ! "/" or d.[30:6] ! "/" then go to fctfail;        37080000
         y ~ d.[36:12];                                                 37090000
         m ~ d.[1:5] | 10 + d.[6:6];                                    37100000
         if m > 12 then go to fctfail;                                  37110000
         d ~ d.[18:6] | 10 + d.[24:6];                                  37120000
         if d > 31 then go to fctfail;                                  37130000
         for i ~ 1 step 1 until m do d ~ d + months[i];                 37140000
         d ~ entier(d mod 10) & y[18:36:12] &                           37150000
            entier(d div 100)[30:42:6] &                                37160000
            entier((d mod 100) div 10)[36:42:6];                        37170000
         end;                                                           37180000
      end;                                                              37190000
   % find reel number:                                                  37200000
   if (if sp-mks{5 then t else valtabl[(aa~pst[mks+5]).str,aa.stw].s=0) 37210000
      then reel ~ -1 else                                               37220000
      if not numval(aa,reel) then go to fctfail;                        37230000
   % find cycle number:                                                 37240000
   if (if sp-mks{6 then t else valtabl[(aa~pst[mks+6]).str,aa.stw].s=0) 37250000
      then cyc ~ -1                                                     37260000
      else if not numval(aa,cyc) then go to fctfail;                    37270000
   % found parameters; fill file:                                       37280000
   % note that a fill element of -1 means "no change".                  37290000
   fill iofile[sio.filno] with mfid, fid, reel, d, cyc, med;            37300000
   go to succeed;                                                       37310000
   end fill;                                                            37320000
% 14: .ge(a,b) succeeds iff a and b are numeric and a } b.              37330000
   begin segment                                                        37340000
   if sp - mks < 2 then                                                 37350000
      if not nullargs(2-sp+mks) then go to fctfail;                     37360000
   if numval(pst[mks],aa) and numval(pst[mks+1],ab)                     37370000
      then go to if aa } ab then succeed else fctfail;                  37380000
   if printmessages then                                                37390000
      begin messageai(0,"ge",instno);                                   37400000
      messagettai(0,"ge",instno);                                       37410000
      end;                                                              37420000
   go to fctfail;                                                       37430000
   end lge;                                                             37440000
% 15: .gt(a,b)                                                          37450000
   % .gt(a,b) succeeds iff a and b are both numeric and a > b.          37460000
   begin segment                                                        37470000
   if sp - mks < 2 then                                                 37480000
      if not nullargs(2-sp+mks) then go to fctfail;                     37490000
   if numval(pst[mks],aa) and numval(pst[mks+1],ab)                     37500000
      then go to if aa > ab then succeed else fctfail;                  37510000
   if printmessages then                                                37520000
      begin messageai(0,"gt",instno);                                   37530000
      messagettai(0,"gt",instno);                                       37540000
      end;                                                              37550000
   go to fctfail;                                                       37560000
   end lgt;                                                             37570000
% 16: .le(a,b)                                                          37580000
    % .le(a,b) succeeds iff a and b are both numeric and a { b.         37590000
    begin segment                                                       37600000
    if sp - mks < 2 then if not nullargs(2-sp+mks) then go to fctfail;  37610000
    if numval(pst[mks],aa) and numval(pst[mks+1],ab)                    37620000
       then go to if aa { ab then succeed else fctfail;                 37630000
    if printmessages then                                               37640000
       begin messageai(0,"le",instno);                                  37650000
       messagettai(0,"le",instno);                                      37660000
       end;                                                             37670000
    go to fctfail;                                                      37680000
    end lee;                                                            37690000
% 17: level()                                                           37700000
   % level() returns the level at which the program is currently        37710000
   % operating.  the level is defined as follows;  it is 1 at the       37720000
   % start of the program; it increases by 1 with each call on a        37730000
   % programmer-defined function; and it decreases by 1 at each         37740000
   % return (or freturn).                                               37750000
   begin segment                                                        37760000
   returnval ~ tempval(level);                                          37770000
   go to succeed;                                                       37780000
   end;  % level()                                                      37790000
% 18: look(s,f)                                                         37800000
   % look(s,f) turns the string $s into a non-readint i/o string for    37810000
   % the input file belonging to the string $f.  if $f is not an input  37820000
   % string (not datacomm), look fctfail.                               37830000
   begin segment                                                        37840000
   if sp - mks < 2 then go to fctfail;                                  37850000
   indirect(mks);                                                       37860000
   aa ~ pst[mks];                                                       37870000
   indirect(mks+1);                                                     37880000
   ab ~ pst[mks+1];                                                     37890000
   ac ~ iotabl[ab.str,ab.stw];                                          37900000
   if not boolean(ac.inuse) or ac.filno=0 then go to fctfail;           37910000
   valu[aa].iouse ~ 2;                                                  37920000
   io[aa] ~ 0 & 2 ciouse & 2 ciotype & ac tfilno;                       37930000
   go to succeed;                                                       37940000
   end;                                                                 37950000
% 19: .lt(a,b)                                                          37960000
   % .lt(a,b) succeeds iff a and b are both numeric and a < b.          37970000
   begin segment                                                        37980000
   if sp-mks < 2 then if not nullargs(2-sp+mks) then go to fctfail;     37990000
   if numval(pst[mks],aa) and numval(pst[mks+1],ab)                     38000000
      then go to if aa < ab then succeed else fctfail;                  38010000
   if printmessages then                                                38020000
      begin messageai(0,"lt",instno);                                   38030000
      messagettai(0,"lt",instno);                                       38040000
      end;                                                              38050000
   go to fctfail;                                                       38060000
   end lt;                                                              38070000
% 20: mode(v)                                                           38080000
   % mode(v) sets system variable, depending on the contents of v.      38090000
   % the values currently recognized for v are:                         38100000
   %     "dump" execute dump() at end-of-job.                           38110000
   %     "round" round quotients of divisions (standard).               38120000
   %     "integer" division fctfails if remainder ! 0.                  38130000
   %     "truncation" truncate quotients.                               38140000
   %     "anchor"  all scans are anchored unless unanch() is used.      38150000
   %     "unanch"  all scans are unanchored, unless anchor() is used    38160000
   %     "unanchor" same as "unanch" (standard).                        38170000
   %     "inform" turn on system debugging output.                      38180000
   %     "silence" turn off debugging output (standard).                38190000
   begin alpha array word[0:1];                                         38200000
   if sp { mks then go to fctfail;                                      38210000
   aa ~ pst[mks];                                                       38220000
   ab ~ valu[aa];                                                       38230000
   if (i1~ab.s) < 3 or i1 > 10 then go to fctfail;                      38240000
   mv(i1,firstchar(ab),word[*],0);                                      38250000
   case i1 of                                                           38260000
      begin ;;; % none of size 0, 1, or 2.                              38270000
      if eq(3,word[*],0,words[13],5) then                               38280000
         begin debugging ~ false;      % run                            38290000
         setlimitflag;                                                  38300000
         go to succeed;                                                 38310000
         end;                                                           38320000
      if equal(4,word[*],0,words[1],3) then                             38330000
         begin dmpstr ~ true;          % dump                           38340000
         go to succeed;                                                 38350000
         end;                                                           38360000
      if equal(5,word[*],0,words[0],7) then                             38370000
         begin dividemode ~ 0;         % round                          38380000
         go to succeed;                                                 38390000
         end else                                                       38400000
      if eq(5,word[*],0,words[13],0) then                               38410000
         begin debugging ~ true;       % debug                          38420000
         setlimitflag;                                                  38430000
         go to succeed;                                                 38440000
         end;                                                           38450000
      if equal(6,word[*],0,words[0],2) then                             38460000
         begin if sp - mks > 1 then  % anchor                           38470000
            begin if not numval(pst[mks+1],i2) or i2 < 0 or i2 > 8191   38480000
               then go to fctfail;                                      38490000
            anchorsize ~ i2;                                            38500000
            end;                                                        38510000
         anchormode ~ 3;                                                38520000
         go to succeed;                                                 38530000
         end else                                                       38540000
      if equal(6,word[*],0,words[0],0) then                             38550000
         begin anchormode ~ 2;         % unanch                         38560000
         anchorsize ~ 0;                                                38570000
         go to succeed;                                                 38580000
         end else                                                       38590000
      if equal(6,word[*],0,words[4],6) then                             38600000
         begin printmessages ~ true;   % inform                         38610000
         inform ~ systemdebugging;                                      38620000
         go to succeed;                                                 38630000
         end;                                                           38640000
      if equal(7,word[*],0,words[2],0) then                             38650000
         begin dividemode ~ 2;         % integer                        38660000
         go to succeed;                                                 38670000
         end else                                                       38680000
      if equal(7,word[*],0,words[5],4) then                             38690000
         begin                         % silence                        38700000
         printmessages ~ inform ~ false;                                38710000
         go to succeed;                                                 38720000
         end else                                                       38730000
      if eq(7,word[*],0,words[14],0) then                               38740000
         begin errdump ~ true;         % errdump                        38750000
         go to succeed;                                                 38760000
         end;                                                           38770000
      if equal(8,word[*],0,words[0],0) then                             38780000
         begin anchormode ~ 2;         % unanchor                       38790000
         anchorsize ~ 0;                                                38800000
         go to succeed;                                                 38810000
         end else                                                       38820000
      if eq(8,word[*],0,words[14],7) then   % truncate, file            38830000
         begin if sp < mks+2 then go to fctfail;                        38840000
         indirect(mks+2);                                               38850000
         aa ~ pst[mks+1];                                               38860000
         ab ~ io[aa];                                                   38870000
         if boolean(ab.outuse) then if ab.filno ! 0 then                38880000
            begin io[aa].ovfl ~ 0;                                      38890000
            go to succeed;                                              38900000
            end;                                                        38910000
         go to fctfail;                                                 38920000
         end else                                                       38930000
      if eq(8,word[*],0,words[15],7) then   % overflow,file             38940000
         begin if sp < mks+2 then go to fctfail;                        38950000
         indirect(mks+1);                                               38960000
         aa ~ pst[mks+1];                                               38970000
         ab ~ io[aa];                                                   38980000
         if boolean(ab.outuse) then if ab.filno ! 0 then                38990000
            begin io[aa].ovfl ~ 1;                                      39000000
            go to succeed;                                              39010000
            end;                                                        39020000
         go to fctfail;                                                 39030000
         end;                                                           39040000
      ; % none with 9 chars                                             39050000
      if equal(10,word[*],0,words[2],7) then                            39060000
         begin dividemode ~ 1;         % truncation                     39070000
         go to succeed;                                                 39080000
         end;                                                           39090000
      end;                                                              39100000
   go to fctfail;                                                       39110000
   end;  % MODE(V)                                                      39120000
% 21: .ne(a,b)                                                          39130000
   % .ne(a,b) succeeds iff a and b are both numeric and a ! b.          39140000
   begin segment                                                        39150000
   if sp-mks < 2 then if not nullargs(2-sp+mks) then go to fctfail;     39160000
   if numval(pst[mks],aa) and numval(pst[mks+1],ab)                     39170000
      then go to if aa ! ab then succeed else fctfail;                  39180000
   if printmessages then                                                39190000
      begin messageai(0,"ne",instno);                                   39200000
      messagettai(0,"ne",instno);                                       39210000
      end;                                                              39220000
   go to fctfail;                                                       39230000
   end lne;                                                             39240000
% 22: .num(a)                                                           39250000
   % .num(a) succeeds if a is numeric; that is, if a is null, or        39260000
   % a is not null and the first char of a is "-" or a digit and        39270000
   % the other chars of a are all digits.                               39280000
   begin segment                                                        39290000
   if mks = sp then go to succeed;                                      39300000
   go to if numval(pst[mks],aa) then succeed else fctfail;              39310000
   end lnum;                                                            39320000
% 23: opsyn(s1,s2,t)                                                    39330000
   % opsyn(s1,s2,t) causes the altering of the symbol table entry       39340000
   % described by s1 and t; the quantity named by s1 is set to be       39350000
   % identical to the quantity named by s2.  the types of the quantities39360000
   % are determined by t as follows:                                    39370000
   %     t is null: s1 and s2 name functions.                           39380000
   %     t starts with "f":  s1 and s2 name functions.                  39390000
   %     t starts with "s":  s1 and s2 name strings.                    39400000
   %     t starts with "l":  s1 and s2 name labels.                     39410000
   % not only the value of the quantity named by s2 is copied, but      39420000
   % also any i/o use it may have.  thus, opsyn("a,"b","s") creates     39430000
   % a string named "a" (if one does not already exist), and assigns    39440000
   % to a the value and i/o use of b,  opsyn("f","argh","f") creates    39450000
   % a function named "f", which is identical to the function argh.     39460000
   % any former function named "f" is lost.  similarly, opsyn("l1",     39470000
   % ,"l2","l") creates a label named l1, which is the  same statement  39480000
   % as l2.  any transfer to l1 will then result in a transfer to       39490000
   % a statement that is the same as l2.                                39500000
   begin alpha i, type;                                                 39510000
   if sp-mks < 3 then if not nullargs(3-sp+mks) then go to fctfail;     39520000
   aa ~ pst[mks+2];                                                     39530000
   aa  ~ valu[aa];                                                      39540000
   if aa.s = 0 then type ~ "fct" else                                   39550000
      begin aa ~ char(firstchar(aa));                                   39560000
      type ~ if aa = "s" then "symb" else      % "s"  string name       39570000
             if aa = "f" then "fct"  else      % "f"  function          39580000
             if aa = "l" then "inst" else 0;   % "l"  label             39590000
      if type = 0 then go to fctfail;                                   39600000
      end;                                                              39610000
   aa ~ pst[mks];                                                       39620000
   ab ~ valu[aa];                                                       39630000
   ab ~ enterst(ab.s,data[ab.r,*],ab.ch,type);                          39640000
   aa ~ pst[mks + 1];                                                   39650000
   ac ~ valu[aa];                                                       39660000
   ac ~ enterst(ac.s,data[ac.r,*],ac.ch,type);                          39670000
   aa ~ valu[ac];                                                       39680000
   i ~ string(aa.s,ab);                                                 39690000
   move(i.s,firstchar(aa),firstchar(i));                                39700000
   valu[ab] ~ i & aa[1:1:16];                                           39710000
   io[ab] ~ io[ac];                                                     39720000
   go to succeed;                                                       39730000
   end lopsyn;                                                          39740000
% 24: page(n)                                                           39750000
   % page(n) ejects the line printer file print to channel n.  if n < 0 39760000
   % or n > 11, page fails.  if n = 0, channel 1 (the top of the next   39770000
   % page) is used.                                                     39780000
   begin segment                                                        39790000
   if sp > mks+1 then   % output file as 2nd parameter                  39800000
      begin indirect(mks+1);                                            39810000
      ab ~ pst[mks+1];                                                  39820000
      if valu[ab].iouse = 0 then go to fctfail else                     39830000
         if i2~io[ab].filno=0 then go to fctfail;                       39840000
      end else i2 ~ 3;  % assume print.                                 39850000
   if sp = mks then i1 ~ 1 else                                         39860000
      begin aa ~ pst[mks];                                              39870000
      if not numval(aa,i1) or i1<0 or i1>11 then go to fctfail;         39880000
      if i1 = 0 then i1 ~ 1;                                            39890000
      end;                                                              39900000
   record[i2] ~ i1;                                                     39910000
   go to succeed;                                                       39920000
   end lpage;                                                           39930000
% 25: pop(s)                                                            39940000
   % pop(s) pops the variable s--i.e., the top value of the push-down   39950000
   % stack of s is removed.  if s in not a named string or if s cant    39960000
   % be popped (only one value in its stack), pop fails.  if s is an    39970000
   % output string, output occurs.                                      39980000
   begin segment                                                        39990000
   if sp { mks then go to fctfail;                                      40000000
   if not pname[mks] then go to fctfail;                                40010000
   go to if pop(aa~pst[mks])                                            40020000
      then if boolean(valu[aa].outuse)                                  40030000
         then if snblout(aa)                                            40040000
            then succeed                                                40050000
            else fctfail                                                40060000
         else succeed                                                   40070000
      else fctfail;                                                     40080000
   end lpop;                                                            40090000
% 26: push(s,v)                                                         40100000
   % push(s,v) pushes the value of v onto the top of the push-down      40110000
   % stack of the variable s.  if pop(s) is then executed, s returns    40120000
   % to its former value.  push fails if s is not a named string, or    40130000
   % if the symbol table is full (a fatal error).  if s is an output    40140000
   % string, output occurs.                                             40150000
   begin segment                                                        40160000
   if sp { mks then go to fctfail;                                      40170000
   if not pname[mks] then go to fctfail;                                40180000
   go to if push(aa~pst[mks],if sp-mks { 1 then 0 else pst[mks+1])      40190000
      then if boolean(valu[aa].outuse)                                  40200000
         then if snblout(aa)                                            40210000
            then succeed                                                40220000
            else fctfail                                                40230000
         else succeed                                                   40240000
      else fctfail;                                                     40250000
   end lpush;                                                           40260000
% 27: .remdr(a,b)                                                       40270000
   % .remdr(a,b) returns the quotient of a / b.  if either a or b       40280000
   % is nonnumeric, or b = 0, .remdr fails.                             40290000
   begin segment                                                        40300000
   if sp-mks < 2 then go to fctfail;                                    40310000
   aa ~ pst[mks];                                                       40320000
   ab ~ pst[mks+1];                                                     40330000
   if not(numval(aa,aa) and numval(ab,ab)) then go to fctfail;          40340000
   if ab = 0 then go to fctfail;                                        40350000
   returnval ~ tempval(aa - (aa div ab) | ab);                          40360000
   go to succeed;                                                       40370000
   end lremed;                                                          40380000
% 28: rewind(f)                                                         40390000
   % rewind(f) causes the file associated with $f to be rewound.        40400000
   % if $f isnt an i/o string, rewind fails.                            40410000
   begin segment                                                        40420000
   if sp { mks then go to fctfail;                                      40430000
   indirect(mks);                                                       40440000
   ab ~ io[pst[mks]];                                                   40450000
   if ab.iouse = 0 or ab.iotype ! 1 then go to fctfail;                 40460000
   rewind(iofile[ab.filno]);                                            40470000
   go to succeed;                                                       40480000
   end instrinsic function rewind;                                      40490000
% 29: rules(l)                                                          40500000
   % rules(l) returns the number of rules executed at level l s1e       40510000
   % the last time level l was reached.  if l = 0 (or is null), the     40520000
   % total for the program is returned.  if l { level(), the current    40530000
   % rule being executed is included in the total.  rules will fail if  40540000
   % l < 0 or l > maxlevel.  note that if rules(l) = "0", then the      40550000
   % level l has never been reached.                                    40560000
   begin segment                                                        40570000
   aa ~ if sp > mks then pst[mks] else 0;                               40580000
   if aa = 0                                                            40590000
      then i1 ~ 0                                                       40600000
      else if not numval(aa,i1) then go to fctfail;                     40610000
   if i1 < 0 then go to fctfail;                                        40620000
   returnval ~ tempval(if i1 > maxlevel then 0 else rules[i]);          40630000
   go to succeed;                                                       40640000
   end lrules;                                                          40650000
% 30: size(s)                                                           40660000
   % size(s) returns the number of characters in s.                     40670000
   begin                                                                40680000
   returnval ~ tempval(if sp { mks then 0 else valu[pst[mks]].s);       40690000
   go to succeed;                                                       40700000
   end lsize;                                                           40710000
% 31: space(f,n) sets a counter for the i/o file belonging to $f        40720000
   % so that any further i/o operations on this file will be            40730000
   % preceded by a skipping of n records.  space fails in the           40740000
   % following situations:                                              40750000
   %     n non-numeric.                                                 40760000
   %     $f not an i/o string.                                          40770000
   %     $f a datacom i/o string.                                       40780000
   % note that for most files, n < 0 is meaningless.  also, n = 0       40790000
   % for line printer files causes overprinting.                        40800000
   begin segment                                                        40810000
   if sp { mks+1 then if not nullargs(2) then go to fctfail;            40820000
   indirect(mks);                                                       40830000
   ab ~ pst[mks];                                                       40840000
   ab ~ io[ab];                                                         40850000
   if ab.iouse = 0 or ab.filno = 0 then go to fctfail;                  40860000
   if not numval(pst[mks+1],i1) then go to fctfail;                     40870000
   iospace[ab.filno] ~ i1;                                              40880000
   go to succeed;                                                       40890000
   end lspace;                                                          40900000
% 32: time(n)                                                           40910000
   begin alpha array num[0:1];                                          40920000
   stream procedure temps(th,tm,ts,w);                                  40930000
      value th,tm,ts;                                                   40940000
      begin di ~ w; ds ~ 8 lit " ";                                     40950000
      si ~ loc th; ds ~ 2 dec; ds ~ 1 lit ":";                          40960000
      si ~ loc tm; ds ~ 2 dec; ds ~ 1 lit ":";                          40970000
      si ~ loc ts; ds ~ 2 dec;                                          40980000
      end temps;                                                        40990000
   integer th,tm,ts;                                                    41000000
   if sp = mks then                                                     41010000
      if not nullargs(1) then go to fctfail;                            41020000
   ab ~ pst[mks];                                                       41030000
   if not numval(ab,aa) then go to fctfail;                             41040000
   if aa < 0 or aa > 4 then go to fctfail;                              41050000
   if aa = 0 then                                                       41060000
      begin                                                             41070000
      aa ~ time(1) / 60;                                                41080000
      th ~ entier(temp/3600);                                           41090000
      tm ~ entier((temp-th|3600)/60);                                   41100000
      ts ~ aa - th|3600 - tm|60;                                        41110000
      temps(th,tm,ts,num[*]);                                           41120000
      end else                                                          41130000
   if aa = 4 then                                                       41140000
      begin clear(num,2);                                               41150000
      i1 ~ time(4);                                                     41160000
      mv(1,i1,7,num[*],15);                                             41170000
      end else                                                          41180000
      begin returnval ~ tempval(time(aa));                              41190000
      go to succeed;                                                    41200000
      end;                                                              41210000
   aa ~ 16 - skipchar(" ",num[*],0);                                    41220000
   returnval ~ tempcell;                                                41230000
   ac ~ string(aa,returnval);                                           41240000
   move(aa,num[*],16-aa,firstchar(ac));                                 41250000
   valu[returnval] ~ ac;                                                41260000
   go to succeed;                                                       41270000
   end ltime;                                                           41280000
% 33: traces(s1,s2,s3,...)  turns on tracing for the strings            41290000
   % named by s1, s2, s3, etc.  all output is to the standard           41300000
   % output file, print.  whenever any of the strings is altered,       41310000
   % output occurs giving the statement number, the string name, and    41320000
   % the new value.                                                     41330000
   begin segment                                                        41340000
   for i ~ mks step 1 until sp-1 do                                     41350000
      begin indirect(i);                                                41360000
      aa ~ pst[i];                                                      41370000
      valu[aa].iouse ~ 1;                                               41380000
      io[aa] ~ 0 & 3 cfilno & 2 ciotype & 1 ciouse;                     41390000
      end;                                                              41400000
   go to succeed;                                                       41410000
   end traces;                                                          41420000
% 34: tracef(f1,f2,f3,...)  turns on tracing for the functions          41430000
   % whose names are contained in f1, f2, f3, etc.  after this,         41440000
   % unless detach() is used, each call of any of these functions       41450000
   % will produce output on the standard output file, print, giving     41460000
   % the instruction number, the function name, and the values of       41470000
   % all the parameters.                                                41480000
   begin segment                                                        41490000
   for i ~ mks step 1 until sp-1 do                                     41500000
      begin aa ~ pst[i];                                                41510000
      ab ~ valu[aa];                                                    41520000
      ac ~ enterst(ab.s,data[ab.r,*],ab.ch,"fct");                      41530000
      valu[ac].iouse ~ 3;                                               41540000
      io[ac] ~ 0 & 2 ciotype & 3 cfilno & 3 ciouse;                     41550000
      end;                                                              41560000
   go to if death then fctfail else succeed;                            41570000
   end tracef;                                                          41580000
% 35: tracel(l1,l2,l3,...)  turns on tracing for the labels whose       41590000
   % names are contained in l1, l2, l3, etc.  after this, unless        41600000
   % detach() is used, each time any of these labels is encounted,      41610000
   % output on the standard output file, print, will occur, giving      41620000
   % the label and the number of times is has been encounterd so        41630000
   % far during the program"s execution.                                41640000
   begin segment                                                        41650000
   for i ~ mks step 1 until sp-1 do                                     41660000
      begin aa ~ pst[i];                                                41670000
      ab ~ valu[aa];                                                    41680000
      ac ~ enterst(ab.s,data[ab.r,*],ab.ch,"inst");                     41690000
      valu[ac].outuse ~ 1;                                              41700000
      io[ac] ~ 0 & 2 ciotype & 3 cfilno & 1 ciouse;                     41710000
      end;                                                              41720000
   go to if death then fctfail else succeed;                            41730000
   end tracel;                                                          41740000
% 36: trim(s)  returns the value of s with all trailing blanks detected.41750000
   begin stream procedure trim(l,inc,size); value inc;                  41760000
      begin local s5, s6, s7, temp;                                     41770000
      label test, return;                                               41780000
      si ~ size; si ~ si + 5;                                           41790000
      di ~ loc s5; di ~ di + 7; ds ~ 1 chr;                             41800000
      di ~ loc s6; di ~ di + 7; ds ~ 1 chr;                             41810000
      di ~ loc s7; di ~ di + 7; ds ~ 1 chr;                             41820000
      si ~ l; si ~ si + inc;                                            41830000
      s5(4(32(si ~ si + 32)));                                          41840000
      s6(2(si ~ si + 32));                                              41850000
      si ~ si + s7;                                                     41860000
      test: si ~ si - 1;                                                41870000
         if sc ! " " then go to return;                                 41880000
         temp ~ si;                                                     41890000
         si ~ loc s7; si ~ si + 7;                                      41900000
         if sc =  "0" then                                              41910000
            begin                                                       41920000
            si ~ loc s6; si ~ si + 7;                                   41930000
            if sc = "0" then                                            41940000
               begin                                                    41950000
               si ~ loc s5; si ~ si + 7;                                41960000
               if sc = "0" then go to return;                           41970000
               tally ~ s5; tally ~ tally + 63; s5 ~ tally;              41980000
               end;                                                     41990000
            tally ~ s6; tally ~ tally + 63; s6 ~ tally;                 42000000
            end;                                                        42010000
         tally ~ s7; tally ~ tally + 63; s7 ~ tally;                    42020000
         si ~ temp; go to test;                                         42030000
      return: di ~ size; di ~ di + 5;                                   42040000
         si ~ loc s5; si ~ si + 7; ds ~ 1 chr;                          42050000
         si ~ loc s6; si ~ si + 7; ds ~ 1 chr;                          42060000
         si ~ loc s7; si ~ si + 7; ds ~ 1 chr;                          42070000
      end trim;                                                         42080000
   if sp { mks then go to succeed;                                      42090000
   ac ~ pst[mks];                                                       42100000
   aa ~ valu[ac];                                                       42110000
   ab ~ aa.s;                                                           42120000
   trim(firstchar(aa),ab);                                              42130000
   ac ~ tempcell;                                                       42140000
   ab ~ string(ab,ac);                                                  42150000
   valu[ac] ~ ab;                                                       42160000
   move(ab.s,firstchar(aa),firstchar(ab));                              42170000
   returnval ~ ac;                                                      42180000
   go to succeed;                                                       42190000
   end ltrim;                                                           42200000
% 37: unanch()                                                          42210000
   begin ptype[0] ~ 2;                                                  42220000
   psize[0] ~ 0;                                                        42230000
   go to succeed;                                                       42240000
   end unanch;                                                          42250000
% 38: uneql(a,b)                                                        42260000
   begin segment                                                        42270000
   if sp-mks < 2 then if not nullargs(2-sp+mks) then go to fctfail;     42280000
   ab ~ pst[mks];                                                       42290000
   ac ~ pst[mks+1];                                                     42300000
   ab ~ valu[ab];                                                       42310000
   ac ~ valu[ac];                                                       42320000
   go to if ab.s ! ac.s                                                 42330000
      then succeed                                                      42340000
      else if equal(ab.s,firstchar(ab),firstchar(ac))                   42350000
         then fctfail                                                   42360000
         else succeed;                                                  42370000
   end luneql;                                                          42380000
% 39: wait(t)  sets the waiting time for teletype i/o to t seconds.     42390000
   % if t is non-numeric or < 0, wait(t) fails.                         42400000
   begin segment                                                        42410000
   returnval ~ tempval(waittime/60);  % return revious waittime.        42420000
   if sp > mks then if valu[pst[mks]].s > 0 then % get new waittime.    42430000
      begin if not numval(pst[mks],ab) or ab < 0 then go to fctfail;    42440000
      waittime ~ ab | 60;                                               42450000
      end;                                                              42460000
   go to succeed;                                                       42470000
   end wait;                                                            42480000
% 40: suspend(t)  suspends the program for t seconds. if t is missing,  42490000
   % and there is a teletype attached, debug is called.                 42500000
   begin label newinst;                                                 42510000
   if sp > mks then                                                     42520000
      begin if not numval(pst[mks],aa) then go to fctfail;              42530000
      if aa < 0 then go to fctfail;                                     42540000
      if aa > 0 then                                                    42550000
            begin when(aa);                                             42560000
            go to succeed;                                              42570000
            end;                                                        42580000
      end;                                                              42590000
   if not datacomf then findusers;                                      42600000
   if datacomf then                                                     42610000
      begin suspendreason[0] ~ true;                                    42620000
      debug(newinst);                                                   42630000
      end;                                                              42640000
   go to if death then fctfail else succeed;                            42650000
newinst:                                                                42660000
   inst[0] ~ aa & ":"[30:42:6];   % build go-to part                    42670000
   floc ~ 5;                                                            42680000
   entry ~ 0;  % since inst[*] has been altered.                        42690000
   go to fctfail; % terminate current instruction                       42700000
   end suspend;                                                         42710000
% 41: status(a,i)  returns the status of attached teletypes, as         42720000
   % given by a, which is either null or a teletype address.  i is the  42730000
   % integer in the algol status(s,i) function.  if a is null, the      42740000
   % status of all attached teletypes is returned.                      42750000
   % the form of the status for one teletype is:                        42760000
   %     <status> ::= ( <proj#> / <user#> : <tu> / <ba> : <conditions> )42770000
   % where <proj#>/<user#> is the user i.d., <tu>/<ba> is the address   42780000
   % of the teletype, and <conditions> is a  string of 8 0-s or 1-s     42790000
   % with the following meanings:                                       42800000
   %     1st = 1 if unit is ready                                       42810000
   %     2nd = 1 if unit is read ready                                  42820000
   %     3rd = 1 if unit is write ready                                 42830000
   %     4th = 1 if write is in progress                                42840000
   %     5th = 1 if break key used during last output                   42850000
   %     6th = 1 if abnormal condition sensed                           42860000
   %     7th = 1 if unit is busy                                        42870000
   %     8th = 1 if seek in effect on station                           42880000
   % when the status of all teletypes is returned, the form of          42890000
   % the value is:                                                      42900000
   %     <status> <status> <status> ... <status>                        42910000
   % i. e., there is one <status> for each attached teletype.           42920000
   % status() fail if:                                                  42930000
   %     a is not null, and is not the address of an attached teletype  42940000
   %     a is null, and to telletypes are attached                      42950000
   begin                                                                42960000
   alpha array stts[0:4|ttmax];    % for building status string         42970000
   integer array size[0:ttmax,0:3]; % holds sizes of status numbers     42980000
   integer high, low, n, stype, u;                                      42990000
   boolean all;                                                         43000000
   %                                                                    43010000
   findusers;                                                           43020000
   if sp { mks then all ~ true else                                     43030000
      begin % find unit or units                                        43040000
      aa ~ pst[mks];                                                    43050000
      if valu[aa].s = 0 then all ~ true else                            43060000
         begin all ~ false;  % only one unit.                           43070000
         if u~ttindex(aa) < 0 then go to fctfail;                       43080000
         end;                                                           43090000
      end finding units;                                                43100000
   if sp { mks+1 then stype ~ 0 else                                    43110000
      if not numval(pst[mks+1],stype) or stype < 0 or stype > 1         43120000
         then go to fctfail;                                            43130000
   if n~numusers-1 < 0 then go to fctfail;                              43140000
   low ~ -1;                                                            43150000
   if all then                                                          43160000
      begin low ~ 0;                                                    43170000
      high ~ n;                                                         43180000
      end else high ~ low ~ u;                                          43190000
   % update status words if necessary:                                  43200000
   if stype > 0 then                                                    43210000
      for i ~ low step 1 until high do                                  43220000
         stat[i] ~ status(stat[i],stype);                               43230000
   %                                                                    43240000
   % other installations will want to re-do the i.d. part of this fct   43250000
   %                                                                    43260000
   % write status string:                                               43270000
   write(stts[*],fstat,high-low+1,for i ~ low step 1 until high do      43280000
     [size[i,0]~digits(id[i].[12:18]),     % i.d. part                  43290000
      id[i].[12:18],    % proj #           % i.d. part                  43300000
      size[i,1]~digits(id[i].[30:18]),     % i.d. part                  43310000
      id[i].[30:18],    % user #           % i.d. part                  43320000
      size[i,2]~digits(stat[i].[9:4]),                                  43330000
      stat[i].[9:4],    % terminal unit                                 43340000
      size[i,3]~digits(stat[i].[14:4]),                                 43350000
      stat[i].[14:4],   % buffer address                                43360000
      1-stat[i].[30:1], % ready                                         43370000
      stat[i].[24:1],   % read ready                                    43380000
      stat[i].[27:1],   % write ready                                   43390000
      stat[i].[29:1],   % write in progress                             43400000
      stat[i].[26:1],   % break key on last input                       43410000
      stat[i].[23:1],   % abnormal condition sensed                     43420000
      stat[i].[22:1],   % station busy                                  43430000
      stat[i].[38:1]]); % seek in effect                                43440000
   % calculate size of string:                                          43450000
   i1 ~ 0;                                                              43460000
   for i ~ low step 1 until high do  % calculate size of string         43470000
      begin i1 ~ i1 + 14;  % for "(/:/:)" & conditions                  43480000
      for j ~ 0 step 1 until 3 do                                       43490000
         i1 ~ i1 + size[i,j];                                           43500000
      end;                                                              43510000
   % set up string for return value:                                    43520000
      returnval ~ tempcell;                                             43530000
      aa ~ string(i1,returnval);                                        43540000
      if death then go to fctfail;                                      43550000
      move(i1,stts[*],0,firstchar(aa));                                 43560000
      valu[returnval] ~ aa;                                             43570000
      go to succeed;                                                    43580000
   end status;                                                          43590000
% 42: user(a) or user()  has two uses.  if used without parameter,      43600000
   % it returns the address of the teletype on which the last teletype  43610000
   % i/o took place.  if it has a parameter, it must be the address of  43620000
   % an attached teletype; further ouput will be to this teletype,      43630000
   % and the value returned will be a.                                  43640000
   begin integer tu, ba;                                                43650000
   alpha array addr[0:1];                                               43660000
   findusers;                                                           43670000
   if not datacomf then go to fctfail;                                  43680000
   if sp > mks then                                                     43690000
      begin i1 ~ pst[mks];                                              43700000
      if valu[i1].s ! 0 then                                            43710000
         begin if i1 ~ ttindex(i1) < 0 then go to fctfail;              43720000
         user ~ i1;                                                     43730000
         end;                                                           43740000
      end;                                                              43750000
   i2 ~ stat[user].[9:9];                                               43760000
   write(addr[*],fttaddr,i~digits(i2.[39:4]),i2.[39:4],                 43770000
      j~digits(i2.[44:4]),i2.[44:4]);                                   43780000
   i ~ i + j + 1;                                                       43790000
   returnval ~ tempcell;                                                43800000
   ab ~ string(i,returnval);                                            43810000
   mv(i,addr[*],0,firstchar(ab));                                       43820000
   valu[returnval] ~ ab;                                                43830000
   go to if death then fctfail else succeed;                            43840000
   end user;                                                            43850000
% 43: seek(u)  does a read seek on terminal unit u.                     43860000
   begin segment                                                        43870000
   if sp { mks then go to fctfail;                                      43880000
   findusers;                                                           43890000
   if i~ttindex(pst[mks]) < 0 then go to fctfail;                       43900000
   aa ~ stat[i];                                                        43910000
   seek(dcin(aa));                                                      43920000
   go to succeed;                                                       43930000
   end seek;                                                            43940000
% 44: release(a)  eliminates teletype a from the list of users.         43950000
   begin segment                                                        43960000
   if sp { mks then go to fctfail;                                      43970000
   if i~ttindex(pst[mks]) < 0 then go to fctfail;                       43980000
   release(stat[i]);                                                    43990000
   findusers;                                                           44000000
   go to succeed;                                                       44010000
   end release;                                                         44020000
% 45: record(file,n)  sets the record pointer for the next i/o          44030000
   % operation on the file $file.  failure occurs if:                   44040000
   %     n non-numeric or < 0                                           44050000
   %     $file not an i/o string (not teletype)                         44060000
   begin segment                                                        44070000
   if sp < mks+2 then if not nullargs(2) then go to fctfail;            44080000
   if not numval(pst[mks+1],i1) or i1 < 0 then go to fctfail;           44090000
   indirect(mks);                                                       44100000
   aa ~ pst[mks];                                                       44110000
   ab ~ io[aa];                                                         44120000
   if ab.iouse = 0 or ab.filno = 0 then go to fctfail;                  44130000
   record[ab.filno] ~ i1;                                               44140000
   go to succeed;                                                       44150000
   end record;                                                          44160000
% 46: trace(name,type,file,fct)                                         44170000
   go to undeffct;                                                      44180000
% 47: assign(s,v)  assigns the value of v to s.  the value of v is      44190000
   % wiped out, s1e a strict transfer of pointers is the method         44200000
   % used.  literals should never be used as parameters to assign().    44210000
   begin                                                                44220000
   if sp{mks or aa~pst[mks]=0 then go to fctfail;                       44230000
   if sp = mks+1 then                                                   44240000
      valu[aa].loc ~ 1 else                                             44250000
      begin                                                             44260000
      ab ~ pst[mks+1];                                                  44270000
      ac ~ valu[ab];                                                    44280000
      i ~ ac.ch - 2;                                                    44290000
      mv(2,aa,6,data[ac.r,i.w],i.c);                                    44300000
      valu[aa].loc ~ ac;                                                44310000
      valu[ab].loc ~ 1; % necessary due to checksymbtabl                44320000
      end;                                                              44330000
   go to succeed;                                                       44340000
   end assign;                                                          44350000
% 48: copy(s,n)  produces n copies of s. if n is not } 0, copy fails.   44360000
   begin segment                                                        44370000
   if sp-mks < 2 then if not nullargs(2-sp+mks) then go to fctfail;     44380000
   aa ~ valu[pst[mks]];                                                 44390000
   if not numval(pst[mks+1],i1) or i1<0 then go to fctfail;             44400000
   returnval ~ tempcell;                                                44410000
   ac ~ string(i1|(j~aa.s),returnval);                                  44420000
   if death then go to fctfail;                                         44430000
   i2 ~ ac.ch;                                                          44440000
   for i ~ 1 step 1 until i1 do                                         44450000
      begin move(j,firstchar(aa),data[ac.r,i2.w],i2.c);                 44460000
      i2 ~ i2 + j;                                                      44470000
      end;                                                              44480000
   valu[returnval] ~ ac;                                                44490000
   go to succeed;                                                       44500000
   end copy;                                                            44510000
% 49: search(file)  does a disk search for $file, if $file is an i/o    44520000
   % string to a file; otherwise search fails.  failure also occurs     44530000
   % if the file is not present.  if it is present, the value is of     44540000
   % the following form:                                                44550000
   %     <mfid> / <fid> : <security> : <rec size> : <blck size> :       44560000
   %            <eof addr> : <open cnt>                                 44570000
   % where the  security status,  <security>, is defined by:            44580000
   %     <security> ::= <s> <r> <w>                                     44590000
   %     <s>   ::= "1" if user can alter security status                44600000
   %     <r>   ::= "1" if can read                                      44610000
   %     <w>   ::= "1" if can write                                     44620000
   begin                                                                44630000
   alpha array st[0:6];                                                 44640000
   integer array size[1:6];                                             44650000
   if sp { mks then go to fctfail;                                      44660000
   indirect(mks);                                                       44670000
   aa ~ pst[mks];                                                       44680000
   if valu[aa].iouse=0 or i~io[aa].filno=0 then go to fctfail;          44690000
   search(iofile[i],st[*]);                                             44700000
   if st[0] < 0 then go to fctfail;                                     44710000
   for j ~ 1,2 do                                                       44720000
      begin i1 ~ scanchar(" ",0,st[j],1);                               44730000
      size[j] ~ if i1 > 7 then 7 else i1;                               44740000
      end;                                                              44750000
   for j ~ 3,4 do st[j] ~ st[j] | 8; % convert to characters            44760000
   for j ~ 3,4,5,6 do size[j] ~ digits(st[j]);                          44770000
   write(bufout[*],fdksearch,                                           44780000
      size[1], size[2],                                                 44790000
      st[0].[45:1],st[0].[46:1],st[0].[47:1],                           44800000
      for j ~ 3,4,5,6 do [size[j],st[j]]);                              44810000
   mv(size[1],st[1],1,bufout[*],0);    % <mfid>                         44820000
   mv(size[2],st[2],1,bufout[*],size[1]+1); % <fid>                     44830000
   i1 ~ 9;                                                              44840000
   for j ~ 1 step 1 until 6 do i1 ~ i1+size[j];                         44850000
   returnval ~ tempcell;                                                44860000
   aa ~ string(i1,returnval);                                           44870000
   move(i1,bufout[*],0,firstchar(aa));                                  44880000
   valu[returnval] ~ aa;                                                44890000
   go to succeed;                                                       44900000
   end search;                                                          44910000
% 50: .ranf(n)  produces a "random" number; 1 { .ranf(n) { n            44920000
   begin define k=7557#, c=1#;                                          44930000
   if sp { mks then go to fctfail;                                      44940000
   if not numval(pst[mks],i1) or i1 { 0 then go to fctfail;             44950000
   randno ~ real(boolean(randno~randno|k+c) and boolean(33554431));     44960000
   returnval ~ tempval(i1|(randno/33554432)+0.5);                       44970000
   go to succeed;                                                       44980000
   end random function;                                                 44990000
% 51: clear() sets all variables to null, at their top level only.      45000000
   begin alpha k;                                                       45010000
   integer i, j;                                                        45020000
   for i ~ 0 step 1 until scatterno do                                  45030000
       for j ~ 0 step 1 while j < scattersize do                        45040000
          begin                                                         45050000
          k ~ j & i concstr;                                            45060000
          do if name[k].type = 0 then valu[k].loc ~ 0                   45070000
             until k~name[k].link = 0;                                  45080000
          end;                                                          45090000
   go to succeed;                                                       45100000
   end clear;                                                           45110000
   end function cases;                                                  45120000
%********intrinsic functions***********                                 45130000
%**************************************                                 45140000
   go to undeffct;                                                      45150000
definedfct:    % program-defined function                               45160000
   begin                                                                45170000
   label toodeep, ret;                                                  45180000
   boolean fctfailure;                                                  45190000
   alpha array                                                          45200000
      preserve[0:5,0:stacksize],                                        45210000
      lvs[0:7];                                                         45220000
   alpha lv, k;                                                         45230000
   % if inform then inform0(5);                                         45240000
   fctfailure ~ false;                                                  45250000
   movewds(30,backreflag,preserve[0,16]); % interpreter variables       45260000
   movewds(sp,pname[*],preserve[1,*]);                                  45270000
   movewds(sp,ppoint[*],preserve[2,*]);                                 45280000
   movewds(sp,psize[*],preserve[3,*]);                                  45290000
   movewds(sp,ptype[*],preserve[4,*]);                                  45300000
   movewds(sp,pst[*],preserve[5,*]);                                    45310000
   mv(j~fctv.s,data[fctv.r,fctv.w],fctv.c,lvs[*],0);                    45320000
   % assign to temporary locs:                                          45330000
   for i ~ sp - 1 step -1 until mks do if pname[i] then                 45340000
      begin                                                             45350000
      k ~ pst[i];                                                       45360000
      aa ~ tempcell;                                                    45370000
      ab ~ string(valu[k].s,aa);                                        45380000
      k ~ valu[k];                                                      45390000
      valu[aa] ~ ab;                                                    45400000
      move(stringloc(k),firstchar(ab));                                 45410000
      pst[i] ~ aa;                                                      45420000
      end;                                                              45430000
   % push params & loc vars and assign values:                          45440000
   mv(2,lvs[*],0,lv,6);                                                 45450000
   if not push(lv,0) then go to fctfail;                                45460000
   if not checkoutuse(lv) then fctfailure ~ true;                       45470000
   k ~ 2; i ~ mks ;                                                     45480000
   j ~ j - 2;                                                           45490000
   for k ~ 2 step 2 until j do                                          45500000
      begin                                                             45510000
      mv(2,lvs[*],k,lv,6);                                              45520000
      if not push(lv,if i<sp then pst[i] else 0) then go to fctfail;    45530000
      if not checkoutuse(lv) then fctfailure ~ true;                    45540000
      i ~ i + 1;                                                        45550000
      end;                                                              45560000
   if fctfailure then go to ret;                                        45570000
   if death then die;                                                   45580000
   for i ~ 0 step 1 until 15 do if usedst[i] then                       45590000
      begin preserve[0,i] ~ templist[i];                                45600000
      templist[i] ~ 0;                                                  45610000
      end;                                                              45620000
   entry ~ fctv.link;                                                   45630000
   if entry = 0 then go to undeffct;                                    45640000
   %                                                                    45650000
   interpreter;         % call function                                 45660000
   %                                                                    45670000
   movewds(30,preserve[0,16],backreflag); % interpreter variables       45680000
   movewds(sp,preserve[1,*],pname[*]);                                  45690000
   movewds(sp,preserve[2,*],ppoint[*]);                                 45700000
   movewds(sp,preserve[3,*],psize[*]);                                  45710000
   movewds(sp,preserve[4,*],ptype[*]);                                  45720000
   movewds(sp,preserve[5,*],pst[*]);                                    45730000
   for i ~ 0 step 1 while i { 15 and usedst[i] do                       45740000
   templist[i] ~ preserve[0,i];                                         45750000
   mv(2,lvs[*],0,lv,6);                                                 45760000
   returnval ~ tempcell;     % to save value returned.                  45770000
   if death then go to fctfail;                                         45780000
   ab ~ valtabl[lv.str,lv.stw];                                         45790000
   if ab.ch } 3 then   % move pointer                                   45800000
      begin i ~ ab.ch - 2;                                              45810000
      mv(2,returnval,6,data[ab.r,i.w],i.c);                             45820000
      end;                                                              45830000
   valu[returnval] ~ ab.loc;                                            45840000
   % the value is now in the temporary location; the symbol loc         45850000
   % lv (with same name as fct) is invalid, but will soon be wiped      45860000
   % out by the call of pop(lv).                                        45870000
ret: j ~ fctv.s - 2;                                                    45880000
   for k ~ 0 step 2 until j do                                          45890000
      begin mv(2,lvs[*],k,lv,6);                                        45900000
      if not pop(lv) then                                               45910000
         if printmessages then                                          45920000
            begin messagei(20,instno);                                  45930000
            messagetti(20,instno);                                      45940000
            end;                                                        45950000
      if not checkoutuse(lv) then fctfailure ~ true;                    45960000
      end;                                                              45970000
   % if inform then inform0(6);                                         45980000
   ptype[mks] ~ 1;                                                      45990000
   go to if fctfailure then fctfail else                                46000000
      if result then succeed else fctfail;                              46010000
   toodeep:   % function depth > maxlevel                               46020000
      messagei(11,instno);                                              46030000
      messagetti(11,instno);                                            46040000
      die;                                                              46050000
   end defined;                                                         46060000
undeffct:      % undefined function called                              46070000
   begin segment                                                        46080000
   write(print[dbl],fbl);                                               46090000
   write(bufout[*],fundeffct);                                          46100000
   aa ~ name[fct];                                                      46110000
   move(i~min(aa.s,100),firstchar(aa),bufout[*],29);                    46120000
   write(print[dbl],17,bufout[*]);                                      46130000
   if datacomf then % write on teletype:                                46140000
      begin i ~ i + 29;                                                 46150000
      mv(2,crlf,5,dcwrite[*],0);  % "{!"                                46160000
      move(i,bufout[*],2,dcwrite[*],2); % message                       46170000
      mv(3,crlf,5,dcwrite[i.w],i.c+2); % "{!~"                          46180000
      if output then;                                                   46190000
      if debugging then % suspend                                       46200000
         begin suspendreason[3] ~ true;                                 46210000
         debug(setgo);                                                  46220000
         fctv ~ valu[fct]; % retreive new def., if any.                 46230000
         go to branch;      % try to execute.                           46240000
         end;                                                           46250000
      end;                                                              46260000
   die;                                                                 46270000
   end;                                                                 46280000
fctfail:       % failure exit for functions                             46290000
   if boolean(valu[fct].outuse) then                                    46300000
      if tracefctreturn(fct,false) then;                                46310000
   fail;                                                                46320000
succeed:                                                                46330000
   pst[mks] ~ returnval;                                                46340000
   if boolean(valu[fct].outuse) then                                    46350000
      if not tracefctreturn(fct,true) then fail;                        46360000
   pname[mks] ~ false;                                                  46370000
   sp ~ mks + 1;                                                        46380000
   relativepointer ~ 4;                                                 46390000
   go to pscan;                                                         46400000
end function;                                                           46410000
%********function*******************************************************46420000
%********literal*************************                               46430000
% 11: "#"  literal:                                                     46440000
   % 2-char pointer to symb table loc.                                  46450000
   begin ptype[sp] ~ 1;                                                 46460000
   pst[sp] ~ temp.[18:12];                                              46470000
   pname[sp] ~ false;                                                   46480000
   sp ~ sp + 1;                                                         46490000
   relativepointer ~ 3;                                                 46500000
   go to pscan;                                                         46510000
   end;                                                                 46520000
%********literal*************************                               46530000
%********qmark*************************                                 46540000
% 12: qmark  end inst, no go-to part                                    46550000
   begin                                                                46560000
   mv(6,controlpoint+1,aa,2);                                           46570000
   instno ~ aa.[12:12];                                                 46580000
   sloc ~ aa.[24:12];                                                   46590000
   floc ~ aa.[36:12];                                                   46600000
   instruct ~ (nearpoint~nearpoint+7).w + instruct;                     46610000
   nearpoint ~ nearpoint.c;                                             46620000
   % if inform then checksymbtabl;                                      46630000
   if rules[level].c = 7 then returntemps;                              46640000
   go to interpret;                                                     46650000
   end;                                                                 46660000
%********qmark*************************                                 46670000
%********go-to*************************                                 46680000
% 13: ":"  go-to                                                        46690000
   begin                                                                46700000
   aa ~ aa.[18:12];                                                     46710000
setgo:                                                                  46720000
   % aa must contain the symbol table address of the next inst.         46730000
   valu[aa].link ~ (ab~valu[aa]).link + 1;  % bump reference count.     46740000
   if boolean(ab.outuse) then % label is being traced;                  46750000
      begin segment                                                     46760000
      ac ~ name[aa];                                                    46770000
      i1 ~ min(ac.s,63);                                                46780000
      i2 ~ i1 + 3 - i1.[46:2];                                          46790000
      i ~ ab.link + 1;                                                  46800000
      write(bufout[*],ftracel,i2,digits(i),i,1,digits(instno),instno);  46810000
      mv(i1,firstchar(ac),bufout[*],3);                                 46820000
      write(print,fbl);                                                 46830000
      write(print[no],17,bufout[*]);                                    46840000
      end label tracing output;                                         46850000
   if entry ! aa then                                                   46860000
      begin                                                             46870000
      entry ~ aa;                                                       46880000
      if i ~ ab.s < 7 then go to undefined;                             46890000
      if i { 63 then                                                    46900000
         mv(i,firstchar(ab),inst[*],0) else                             46910000
         move(i,firstchar(ab),inst[*],0);                               46920000
      end;                                                              46930000
   mv(6,inst[*],3,aa,2);                                                46940000
   instno ~ aa.[12:12];                                                 46950000
   sloc ~ aa.[24:12];                                                   46960000
   floc ~ aa.[36:12];                                                   46970000
   instruct ~ relativepointer ~ 0;                                      46980000
   nearpoint ~ 9;                                                       46990000
   % if inform then checksymbtabl;                                      47000000
   if rules[level].c = 7 then returntemps;                              47010000
   if debugging then % check label limits                               47020000
      for i ~ 0 step 1 until nlabellimit do                             47030000
        if entry = labellimit[i] then                                   47040000
            begin suspendreason[2] ~ true;                              47050000
            debug(setgo);                                               47060000
            go to interpret;                                            47070000
            end;                                                        47080000
   go to interpret;                                                     47090000
   end;                                                                 47100000
%********go-to*************************                                 47110000
   ;;;;;;;;;;;                                                          47120000
%********input check*******************                                 47130000
% 25: "i" check input use of last element                               47140000
   begin aa ~ pst[sp-1];                                                47150000
   if boolean(valu[aa].inuse) then if not snblin(aa) then fail;         47160000
   relativepointer ~ 1;                                                 47170000
   go to pscan;                                                         47180000
   end;                                                                 47190000
%********input check*******************                                 47200000
%********arithmetic********************                                 47210000
% 26: "."  arithmetic operator                                          47220000
   begin                                                                47230000
   intovr ~ arithovfl;                                                  47240000
   expovr ~ arithovfl;                                                  47250000
   case dottype[aa.c3] of                                               47260000
      begin                                                             47270000
   % 0: error                                                           47280000
      go to perror;                                                     47290000
   % 1: ".n"  negation:                                                 47300000
      begin                                                             47310000
      if (mks~sp-1) < 0 then go to perror;                              47320000
      if ptype[mks] = -1                                                47330000
         then ab ~ pst[mks]                                             47340000
         else if not numval(pst[mks],ab) then go to nonnumeric;         47350000
      pst[mks] ~ -ab;                                                   47360000
      ptype[mks] ~ -1;                                                  47370000
      end;                                                              47380000
   % 2: arithmetic  operator:                                           47390000
      begin                                                             47400000
      if (mks~sp-2) < 0 then go to perror;                              47410000
      if ptype[mks] = -1                                                47420000
         then ab ~ pst[mks]                                             47430000
         else if not numval(pst[mks],ab) then go to nonnumeric;         47440000
      if ptype[mks+1] = -1                                              47450000
         then ac ~ pst[mks+1]                                           47460000
         else if not numval(pst[mks+1],ac) then go to nonnumeric;       47470000
      if i~aa.c3 = "+" then i1 ~ ab + ac else                           47480000
      if i = "-" then i1 ~ ab - ac else                                 47490000
      if i = "|" then i1 ~ ab | ac else                                 47500000
      if i = "/" then if ac=0 then go to dvdzero else                   47510000
         case dividemode of                                             47520000
            begin                                                       47530000
         % 0: round                                                     47540000
            i1 ~ ab/ac;                                                 47550000
         % 1: truncation                                                47560000
            i1 ~ entier(ab/ac);                                         47570000
         % 2: integer                                                   47580000
            if (i1~aa~ab/ac) ! entier(aa) then fail                     47590000
            end divide cases else                                       47600000
      if i = "*" then                                                   47610000
         if ac = 0 then i1 ~ 1 else                                     47620000
            begin                                                       47630000
            if ac < 0 then                                              47640000
               begin ac ~ -ac;                                          47650000
               aa ~ 1/ab;                                               47660000
               end else aa ~ ab;                                        47670000
            for i ~ 1 step 1 until ac do aa ~ aa | ab;                  47680000
            i1 ~ aa;                                                    47690000
            end else                                                    47700000
         go to perror;  % invalid char after "."                        47710000
      pst[mks] ~ i1;                                                    47720000
      ptype[mks] ~ -1;                                                  47730000
      end;                                                              47740000
   % 3: ".s"   convert to string                                        47750000
      begin                                                             47760000
      if mks~sp-1 < 0  or ptype[mks] ! -1 then                          47770000
         begin inform0(9);                                              47780000
         go to perror;                                                  47790000
         end;                                                           47800000
      pst[mks] ~ tempval(pst[mks]);                                     47810000
      ptype[mks] ~ 1;                                                   47820000
      pname[mks] ~ false;                                               47830000
      end                                                               47840000
      end arith cases;                                                  47850000
   %                                                                    47860000
   sp ~ mks + 1;                                                        47870000
   relativepointer ~ 2;                                                 47880000
   intovr ~ 0;                                                          47890000
   go to pscan;                                                         47900000
arithovfl: % integer overflow in arithmetic:                            47910000
   if printmessages then                                                47920000
      begin messagei(0,instno);                                         47930000
      messagetti(0,instno);                                             47940000
      end;                                                              47950000
   fail;                                                                47960000
nonnumeric: % non-numeric argument to arithmetic:                       47970000
   if printmessages then                                                47980000
      begin messagei(17,instno);                                        47990000
      messagetti(17,instno);                                            48000000
      end;                                                              48010000
   fail;                                                                48020000
dvdzero: % divide-by-zero in arithmetic                                 48030000
   if printmessages then                                                48040000
      begin messagei(18,instno);                                        48050000
      messagetti(18,instno);                                            48060000
      end;                                                              48070000
   fail;                                                                48080000
   end arithmetic;                                                      48090000
%********arithmetic********************                                 48100000
   ;;                                                                   48110000
%********grouping**********************                                 48120000
% 29: "("  grouping                                                     48130000
   begin                                                                48140000
   mks ~ sp - aa.c3;                                                    48150000
   i1 ~ 0;     % to keep size in                                        48160000
   for i ~ mks step 1 until sp-1 do                                     48170000
      begin                                                             48180000
      i ~ i;                                                            48190000
      if ptype[i] ! 1 then                                              48200000
         begin informi(1,ptype[i]);                                     48210000
         systemerror ~ true;                                            48220000
         go to dead;                                                    48230000
         end;                                                           48240000
      aa ~ pst[i];                                                      48250000
      i1 ~ i1 + valu[aa].s;                                             48260000
      end;                                                              48270000
   ac ~ tempcell;                                                       48280000
   valu[ac] ~ ab ~ string(i1,ac);                                       48290000
   i1 ~ ab.ch;                                                          48300000
   i2 ~ ab.r;                                                           48310000
   for i ~ mks step 1 while i<sp do                                     48320000
      begin                                                             48330000
      i ~ i;                                                            48340000
      aa ~ pst[i];                                                      48350000
      aa ~ valu[aa];                                                    48360000
      if j~aa.s > 0 then                                                48370000
         begin                                                          48380000
         if j { 63 then                                                 48390000
           mv(j,firstchar(aa),data[i2,i1.w],i1.c) else                  48400000
           move(j,firstchar(aa),data[i2,i1.w],i1.c);                    48410000
        i1 ~ i1 + j;                                                    48420000
        end;                                                            48430000
     end;                                                               48440000
   pst[mks] ~ ac;                                                       48450000
   sp ~ mks + 1;                                                        48460000
   pname[mks] ~ false;                                                  48470000
   relativepointer ~ 2;                                                 48480000
   go to pscan;                                                         48490000
   end;  % grouping                                                     48500000
%********grouping**********************                                 48510000
   ;                                                                    48520000
%********replacement*******************                                 48530000
% 31: "~" replacement or assignment                                     48540000
   begin relativepointer ~ 1;                                           48550000
   if selfreflag then   % str ref used as str var                       48560000
      begin                                                             48570000
      if printmessages then                                             48580000
         begin messagei(3,instno);                                      48590000
         messagetti(3,instno);                                          48600000
         end;                                                           48610000
      go to goto;                                                       48620000
      end;                                                              48630000
   % if inform then inform0(3);                                         48640000
   size ~ (ab~valtabl[refi~pst[0].str,refj~pst[0].stw]).s;              48650000
   noreplaces ~ sp - 1;                                                 48660000
   % calculate size of new str ref:                                     48670000
   for sp ~ 1 step 1 until noreplaces do                                48680000
      begin aa ~ pst[sp];                                               48690000
      i1 ~ valu[aa].s;                                                  48700000
      rsize ~ rsize + i1;                                               48710000
      end;                                                              48720000
   % if new str ref is not larger than the old, the same string         48730000
   % can be used.  ab still points to the str ref.                      48740000
   if rsize > size then                                                 48750000
      begin b1 ~ true;  % str ref in new string                         48760000
      aa ~ string(rsize,pst[0]);                                        48770000
      ab ~ valtabl[refi,refj];                                          48780000
      end else                                                          48790000
      begin b1 ~ false; % use same string for str ref.                  48800000
      if rsize < size then valtabl[refi,refj].s ~ rsize;                48810000
      aa ~ ab;                                                          48820000
      end;                                                              48830000
   % aa points to new value.                                            48840000
   % ab points to old value.                                            48850000
   I ~ aa.r;                                                            48860000
   j ~ ab.r;                                                            48870000
   if b1 then if frontend > 0 then                                      48880000
      if frontend { 63 then                                             48890000
         mv(frontend,data[j,ab.w],ab.c,data[i,aa.w],aa.c) else          48900000
         move(frontend,data[j,ab.w],ab.c,data[i,aa.w],aa.c);            48910000
   i1 ~ frontend + aa.ch;    % pointer to next char to be overwritten.  48920000
   % rewrite matched portion:                                           48930000
   for sp ~ 1 step 1 until noreplaces do                                48940000
      begin ac ~ pst[sp];                                               48950000
      ac ~ valu[ac];                                                    48960000
      if (i2~ac.s) > 0 then                                             48970000
         begin if i2 { 63 then                                          48980000
            mv(i2,data[ac.r,ac.w],ac.c,data[i,i1.w],i1.c) else          48990000
            move(i2,data[ac.r,ac.w],ac.c,data[i,i1.w],i1.c);            49000000
         i1 ~ i1 + i2;                                                  49010000
         end;                                                           49020000
      end;                                                              49030000
   if rearend > 0 then if b1 or rsize ! size then                       49040000
      begin i2 ~ ab.ch + size - rearend;                                49050000
      if rearend > 0 then if rearend { 63 then                          49060000
         mv(rearend,data[j,i2.w],i2.c,data[i,i1.w],i1.c) else           49070000
         move(rearend,data[j,i2.w],i2.c,data[i,i1.w],i1.c);             49080000
      end;                                                              49090000
   if b1 then valtabl[refi,refj].loc ~ aa;                              49100000
   if boolean(ab.outuse) then                                           49110000
      if not snblout(pst[0]) then go to failed;                         49120000
   go to goto;                                                          49130000
   end;                                                                 49140000
%********replacement*******************                                 49150000
   ;;;                                                                  49160000
%********label indirection*************                                 49170000
% 35: "l"  indirect to produce label                                    49180000
   begin                                                                49190000
   if sp ! 1 then go to perror;                                         49200000
   aa ~ valu[pst[0]];                                                   49210000
   aa ~ enterst (aa.s,data[aa.r,*],aa.ch,"inst");                       49220000
   go to setgo;                                                         49230000
   end;                                                                 49240000
%********label indirection*************                                 49250000
   ;;;;;;                                                               49260000
%********indirection*******************                                 49270000
% 42: "$"  indirection                                                  49280000
   begin                                                                49290000
   % if inform then inform0(16);                                        49300000
   if (sp~sp-1) < 0 then                                                49310000
      begin informi(23,instno);                                         49320000
      systemerror ~ inform ~ true;                                      49330000
      go to dead;                                                       49340000
      end;                                                              49350000
   ab ~ pst[sp];                                                        49360000
   for i ~ aa.c3 step -1 until 1 do                                     49370000
      begin                                                             49380000
      ac ~ valu[ab];                                                    49390000
      if boolean(ac.inuse) then                                         49400000
         begin if not snblin(ab) then go to failed;                     49410000
         ac ~ valu[ab];  % input may move value                         49420000
         end;                                                           49430000
      if printmessages then if ac.s = 0 then                            49440000
         begin messagei(19,instno);                                     49450000
         messagetti(19,instno);                                         49460000
         end;                                                           49470000
      ab ~ enterst(ac.s,data[ac.r,*],ac.ch,"symb");                     49480000
      if death then go to dead;                                         49490000
      end;                                                              49500000
   pst[sp] ~ ab;                                                        49510000
   pname[sp] ~ true;                                                    49520000
   sp ~ sp + 1;                                                         49530000
   relativepointer ~ 2;                                                 49540000
   go to pscan;                                                         49550000
   end;                                                                 49560000
%********indirection*******************                                 49570000
%********str var***********************                                 49580000
% 43: "*"  string variable                                              49590000
   begin                                                                49600000
   relativepointer ~ 2;                                                 49610000
   varflag ~ true;                                                      49620000
   sp ~ sp - 1;                                                         49630000
   case aa.c3 of                                                        49640000
      begin                                                             49650000
   % error                                                              49660000
      go to perror;                                                     49670000
   % 1: arb var                                                         49680000
      begin ptype[sp] ~ 2;                                              49690000
      psize[sp] ~ 0;                                                    49700000
      end;                                                              49710000
   % 2: bal var                                                         49720000
      begin ptype[sp] ~ 4;                                              49730000
      psize[sp] ~ 1;                                                    49740000
      end;                                                              49750000
   % 3: fixed-length                                                    49760000
      begin                                                             49770000
      % if size < 0 then rule fails.                                    49780000
      if (if ptype[sp] = 7                                              49790000
            then i1~pst[sp] < 0                                         49800000
            else not numval(pst[sp],i1) or i1<0)                        49810000
         then go to fixerr;                                             49820000
      psize[sp~sp-1] ~ i1;                                              49830000
      ptype[sp] ~ 3;                                                    49840000
      end                                                               49850000
      end var cases;                                                    49860000
   sp ~ sp + 1;                                                         49870000
   go to pscan;                                                         49880000
   end;                                                                 49890000
%********str var***********************                                 49900000
%********reserved label****************                                 49910000
% 44: "-"  reserved label                                               49920000
   if i~aa.c3 = "r" then                                                49930000
      begin result ~ true;                                              49940000
      go to return;                                                     49950000
      end else                                                          49960000
   if i = "f" then                                                      49970000
      begin result ~ false;                                             49980000
      go to return;                                                     49990000
      end else                                                          50000000
   if i = "e" then                                                      50010000
      begin result ~ true;                                              50020000
      go to endterpret;                                                 50030000
      end;                                                              50040000
%********reserved label****************                                 50050000
   ;;;;                                                                 50060000
%********go-to part********************                                 50070000
% 49: "/" go-to part delimiter after pattern                            50080000
goto:                                                                   50090000
   begin                                                                50100000
   % if inform then inform0(26);                                        50110000
   nearpoint ~ if success then sloc else floc;                          50120000
   instruct ~ nearpoint.w;                                              50130000
   nearpoint ~ nearpoint.c;                                             50140000
   relativepointer ~ sp + 0;                                            50150000
   ingotopart ~ true;                                                   50160000
   go to pscan;                                                         50170000
   end;                                                                 50180000
%********go-to part********************                                 50190000
%********end str ref*******************                                 50200000
% 50: "s"  end of string reference, before pattern                      50210000
   begin                                                                50220000
   if boolean(valu[pst[0]].inuse) then                                  50230000
      if not snblin(pst[0]) then fail;                                  50240000
   ptype[0] ~ anchormode;                                               50250000
   psize[0] ~ anchorsize;                                               50260000
   ppoint[0] ~ 0;                                                       50270000
   relativepointer ~ 1;                                                 50280000
   go to pscan;                                                         50290000
   end;                                                                 50300000
%********end str ref*******************                                 50310000
   ;;;;                                                                 50320000
%********syntax error******************                                 50330000
% 55: "x"  syntax error in original code                                50340000
   begin messagei(1,instno);                                            50350000
   messagetti(1,instno);                                                50360000
   go to dead;                                                          50370000
   end;                                                                 50380000
%********syntax error******************                                 50390000
   ;;;                                                                  50400000
%********non-input string**************                                 50410000
% 59: "%"  non-input string name                                        50420000
   begin ptype[sp] ~ 1;                                                 50430000
   pst[sp] ~ aa.[18:12];                                                50440000
   pname[sp] ~ true;                                                    50450000
   sp ~ sp + 1;                                                         50460000
   relativepointer ~ 3;                                                 50470000
   go to pscan;                                                         50480000
   end;                                                                 50490000
%********non-input string**************                                 50500000
   ;                                                                    50510000
%********pattern match*****************                                 50520000
% 61: "="  patern match                                                 50530000
   begin                                                                50540000
   % if  sp { 1 then go to perror;                                      50550000
   relativepointer ~ 1;                                                 50560000
   pminleft[sp] ~ ptype[sp] ~ 0;   % to end scan.                       50570000
   nopatterns ~ sp - 1;                                                 50580000
   backreflag ~ false;                                                  50590000
   for i ~ nopatterns step -1 until 1 do                                50600000
      begin                                                             50610000
      if i1 ~ ptype[i] = 1 then                                         50620000
      for j ~ i-1 step -1 until 0 do                                    50630000
         begin                                                          50640000
         if pst[i]  = pst[j]                                            50650000
            then if ptype[j] ! 1                                        50660000
               then begin                                               50670000
               ptype[i] ~ i1 ~ 5;                                       50680000
               pback[i] ~ j;                                            50690000
               psize[i] ~ psize[j];                                     50700000
               backreflag ~ true;                                       50710000
               go to minlef;                                            50720000
               end;                                                     50730000
         end else if i1 { 4 then                                        50740000
            if pst[i] = pst[0]                                          50750000
               then selfreflag ~ true;                                  50760000
      if i1 = 1 then    % set plength & lloc fields                     50770000
         begin ab ~ pst[i];                                             50780000
         psize[i] ~ (ploc[i] ~ valu[ab]).s;                             50790000
         end;                                                           50800000
minlef:  % the minleft word holds the minimum size of the               50810000
      % remainder of the pattern.                                       50820000
      pminleft[i] ~ pminleft[i+1] + psize[i];                           50830000
      end;                                                              50840000
   refloc ~ (aa~valtabl[refi~pst[0].str,refj~pst[0].stw]).ch;           50850000
   size ~ aa.s;                                                         50860000
   rpr ~ ab.r;                                                          50870000
   sp ~ 0;                                                              50880000
   nobackorbal ~ true;                                                  50890000
newpoint:                                                               50900000
   ppoint[sp+1] ~ ppoint[sp] + psize[sp];                               50910000
nextpattern:                                                            50920000
   sp ~ sp + 1;                                                         50930000
   if pminleft[sp] + ppoint[sp] > size then go to sizefailure;          50940000
   case ptype[sp] of                                                    50950000
      begin                                                             50960000
   % 0: end of scan, if after last pattern element:                     50970000
      go to if sp > nopatterns then scansuccess else scanerr;           50980000
   % 1: constant pattern element                                        50990000
      begin                                                             51000000
      aa ~ ploc[sp];                                                    51010000
      refpt ~ refloc + ppoint[sp];                                      51020000
      go to if (if (i~aa.s) { 63 then                                   51030000
            eq(i,firstchar(aa),data[rpr,refpt.w],refpt.c) else          51040000
            equal(i,firstchar(aa),data[rpr,refpt.w],refpt.c))           51050000
         then newpoint                                                  51060000
         else dropback;                                                 51070000
      end;                                                              51080000
   % 2: arbitrary string variable                                       51090000
      begin ppoint[sp+1] ~ ppoint[sp];                                  51100000
      go to nextpattern;                                                51110000
      end;                                                              51120000
   % 3: fixed-length string variable                                    51130000
      go to newpoint;                                                   51140000
   % 4: balanced string variable                                        51150000
      begin nobackorbal ~ true;                                         51160000
      increase ~ 0;                                                     51170000
      refpt ~ refloc + ppoint[sp];                                      51180000
balance:                                                                51190000
      count ~ 0;                                                        51200000
      do begin                                                          51210000
         if ppoint[sp] + increase~increase+1 > size then go to dropback;51220000
         if aa~char(data[rpr,refpt.w],refpt.c) = "(" then               51230000
            count ~ count + 1 else                                      51240000
         if aa = ")" then                                               51250000
            count ~ count - 1;                                          51260000
         refpt ~ refpt + 1;                                             51270000
         end until count { 0;                                           51280000
      if count < 0 then go to dropback;                                 51290000
      ppoint[sp+1] ~ ppoint[sp] + psize[sp]~increase;                   51300000
      go to nextpattern;                                                51310000
      end;                                                              51320000
   % 5: back reference:                                                 51330000
      begin nobackorbal ~ false;                                        51340000
      increase ~ ppoint[pback[sp]+1] - i1~ppoint[pback[sp]];            51350000
      if ppoint[sp] + increase > size then go to sizefailure;           51360000
      i1 ~ refloc + i1;                                                 51370000
      refpt ~ refloc + ppoint[sp];                                      51380000
      if not equal(increase,data[rpr,i1.w],i1.c,                        51390000
         data[rpr,refpt.w],refpt.c) then go to dropback;                51400000
      ppoint[sp+1] ~ ppoint[sp] + increase;                             51410000
      go to nextpattern;                                                51420000
      end                                                               51430000
      end cases;                                                        51440000
   go to scanerr;                                                       51450000
sizefailure:                                                            51460000
   if nobackorbal then go to scanfailure;                               51470000
dropback:                                                               51480000
   do if (sp~sp-1) < 0 then go to scanfailure                           51490000
      until not boolean(ptype[sp]);                                     51500000
   % non-extendable if constant, fixed-length or  back-reference        51510000
   % can only be extended for simple & balanced variables.              51520000
   if ptype[sp] = 2 then     % arbitrary variable:                      51530000
      begin                                                             51540000
      go to if pminleft[sp+1] + ppoint[sp+1]~ppoint[sp+1]+1 { size      51550000
         then nextpattern                                               51560000
         else sizefailure;                                              51570000
      end else %  balanced variable:                                    51580000
      begin                                                             51590000
      refpt ~ refloc + ppoint[sp] + increase~psize[sp];                 51600000
      go to balance;                                                    51610000
      end;                                                              51620000
scanerr:                                                                51630000
   begin segment                                                        51640000
   informii(3,instno,sp);                                               51650000
   writestack(nopatterns+1);                                            51660000
   abort;                                                               51670000
   end;                                                                 51680000
scansuccess:                                                            51690000
   % if inform then writestack(nopatterns+1);                           51700000
   if ptype[sp-1] = 2 then ppoint[sp] ~ size;                           51710000
% assignment of string variables:                                       51720000
   % if inform then inform0(0);                                         51730000
   frontend ~ ppoint[1];                                                51740000
   rearend ~ size - ppoint[nopatterns+1];                               51750000
   rsize  ~ frontend + rearend;                                         51760000
   if varflag then                                                      51770000
   begin                                                                51780000
   if selfreflag then                                                   51790000
      begin % make copy of str ref value:                               51800000
      tempref ~ tempcell;                                               51810000
      aa ~ string(size,tempref);                                        51820000
      if death then die;                                                51830000
      ab ~ valtabl[refi,refj];                                          51840000
      move(size,firstchar(ab),firstchar(aa));                           51850000
      valu[tempref] ~ ab ~ aa;                                          51860000
      end else                                                          51870000
      begin tempref ~ pst[0];                                           51880000
      ab ~ valu[tempref];                                               51890000
      end;                                                              51900000
   for sp ~ 1 step 1 until nopatterns do                                51910000
      if ptype[sp]>1 then if ptype[sp]<5 then if ac~pst[sp]!0 then      51920000
      begin                                                             51930000
      % string variable assignment:                                     51940000
      if (j~ppoint[sp+1]-ppoint[sp]) = 0 then                           51950000
         valu[ac].s ~ 0 else                                            51960000
         begin                                                          51970000
         if (aa~valu[ac]).s < j then                                    51980000
            % need new string--new value larger than old.               51990000
            begin aa ~ string(j,ac);                                    52000000
            ab ~ valu[tempref];                                         52010000
            valu[ac].loc ~ aa;                                          52020000
            end else                                                    52030000
            % can use old value--new value short enough                 52040000
            valu[ac].s ~ j;                                             52050000
         i1 ~ ab.ch + ppoint[sp];                                       52060000
         if j { 63 then                                                 52070000
            mv(j,data[ab.r,i1.w],i1.c,firstchar(aa)) else               52080000
            move(j,data[ab.r,i1.w],i1.c,firstchar(aa));                 52090000
         end;                                                           52100000
      if boolean(valu[ac].outuse) then if not snblout(ac) then fail;    52110000
      end;                                                              52120000
   end assignment of str vars;                                          52130000
   sp ~ 1;                                                              52140000
   go to pscan;                                                         52150000
   end;                                                                 52160000
%********pattern match*****************                                 52170000
   ;                                                                    52180000
%********string  name******************                                 52190000
% 63: """  string name, with input check                                52200000
   begin ptype[sp] ~ 1;                                                 52210000
   pst[sp] ~ i ~ aa.[18:12];                                            52220000
   if boolean(valu[i].inuse) then if not snblin(i) then fail;           52230000
   pname[sp] ~ true;                                                    52240000
   sp ~ sp + 1;                                                         52250000
   relativepointer ~ 3;                                                 52260000
   go to pscan;                                                         52270000
   end                                                                  52280000
%********string name*******************                                 52290000
   end pscan cases;                                                     52300000
perror:                                                                 52310000
   begin segment                                                        52320000
   informi(5,instno);                                                   52330000
   write(print,17,inst[*]);                                             52340000
   clear(bufout,17);                                                    52350000
   if instruct | 8 + nearpoint  < 132 then                              52360000
      mv(1,qmark,7,bufout[instruct],nearpoint);                         52370000
   write(print,17,bufout[*]);                                           52380000
   result ~ false;                                                      52390000
   abort;                                                               52400000
   end;                                                                 52410000
fixerr:                                                                 52420000
   if printmessages then                                                52430000
   begin segment                                                        52440000
   write(print,fbl);                                                    52450000
   aa ~ valu[pst[sp]];                                                  52460000
   write(bufout[*],ffixvarsize,aa.s,instno);                            52470000
   move(min(aa.s,116),firstchar(aa),bufout[*],16);                      52480000
   write(print,17,bufout[*]);                                           52490000
   if inform then writestack(sp);                                       52500000
   fail;                                                                52510000
   end;                                                                 52520000
scanfailure:                                                            52530000
%  if inform then                                                       52540000
%     begin inform0(8);                                                 52550000
%     writestack(nopatterns+1);                                         52560000
%     end;                                                              52570000
failed:                                                                 52580000
   % if inform then inform0(4);                                         52590000
   if ingotopart then   % go-to part has failed--fatal error            52600000
      begin                                                             52610000
      messagei(2,instno);                                               52620000
      messagetti(2,instno);                                             52630000
      die;                                                              52640000
      end;                                                              52650000
   if death then die;                                                   52660000
   success ~ false;                                                     52670000
   go to goto;                                                          52680000
dead:    % fatal error has occurred--terminate program.                 52690000
   % error message should already have been printed.                    52700000
   begin segment                                                        52710000
   if systemerror then abort                                            52720000
   if debugging then  % suspend:                                        52730000
      begin suspendreason[3] ~ true;                                    52740000
      death ~ false;                                                    52750000
      debug(setgo);                                                     52760000
      end;                                                              52770000
   messagetti(13,instno);                                               52780000
   result ~ false;                                                      52790000
   go to endterpret;                                                    52800000
   end;                                                                 52810000
limithit:     % system limit of some sotr passed--print all limits.     52820000
   begin segment                                                        52830000
   dmpstr ~ true;                                                       52840000
   messagei(4,instno);                                                  52850000
   messagetti(4,instno);                                                52860000
   if cpulimitexists then                                               52870000
      begin messagei(5,cpulimit/60);                                    52880000
      messagetti(5,cpulimit/60);                                        52890000
      end;                                                              52900000
   if iolimitexists then                                                52910000
      begin messagei(6,iolimit/60);                                     52920000
      messagetti(6,iolimit/60);                                         52930000
      end;                                                              52940000
   if rulelimitexists then                                              52950000
      begin messagei(7,rulelimit);                                      52960000
      messagetti(7,rulelimit);                                          52970000
      end;                                                              52980000
   result ~ false;                                                      52990000
   die;                                                                 53000000
   end limithit;                                                        53010000
undefined:    % attempted transfer to undefined label.                  53020000
   % aa must contain symb table address of label.                       53030000
   begin alpha ac, ab;                                                  53040000
   dmpstr ~ true;                                                       53050000
   write(print,fbl);                                                    53060000
   ab ~ name[aa];                                                       53070000
   write(bufout[*],fundeflabel);                                        53080000
   move(i~min(90,ab.s),firstchar(ab),bufout[*],40);                     53090000
   write(print,17,bufout[*]);                                           53100000
   if datacomf then % write message on teletype:                        53110000
      begin mv(2,crlf,5,dcwrite[*],0);                                  53120000
      move(i~i+38,bufout[*],2,dcwrite[*],2);                            53130000
      mv(3,crlf,5,dcwrite[i.w],i.c+2);                                  53140000
      if output then;                                                   53150000
      if debugging then % suspend                                       53160000
         begin suspendreason[3] ~ true;                                 53170000
         ac ~ aa;                                                       53180000
         debug(setgo);                                                  53190000
         % see if label defined now:                                    53200000
         go to if valu[aa~ac].s } 10 then setgo else undefined;         53210000
         end;                                                           53220000
      end;                                                              53230000
   result ~ false;                                                      53240000
   die;                                                                 53250000
   end;                                                                 53260000
return:                                                                 53270000
   % inform them  informi(10,level);   % end of this level.             53280000
   returntemps;                                                         53290000
   if level~level-1 { 0 then % return, no function called               53300000
      begin message0(22);                                               53310000
      messagetti(14,instno);                                            53320000
      die;                                                              53330000
      end;                                                              53340000
end interpreter;                                                        53350000
%********interpreter****************************************************53360000
%********intrinsic******************************************************53370000
% given a function name (s chars--starting p chars past l[0]),          53380000
% intrinsic returns the index for the branch to intrinsic fcts in the   53390000
% interpreter.  if the function isnot an instrinsic, 0 is returned.     53400000
integer procedure intrinsic(l,p,s);                                     53410000
value p, s;                                                             53420000
alpha array l[0];                                                       53430000
integer p, s;                                                           53440000
begin label  fin, non;                                                  53450000
alpha f;                                                                53460000
integer i;                                                              53470000
boolean fx;                                                             53480000
%                                                                       53490000
if s > 7 or s < 3 then go to non;                                       53500000
f ~ 0;                                                                  53510000
mv(s,l[p.w],p.c,f,8-s);                                                 53520000
fx ~ not boolean(f);                                                    53530000
for i ~ intrinsfct[s,0] step -1 until 1 do                              53540000
   if real(not(boolean(intrinsfct[s,i]) eqv fx)) = teenyneg then        53550000
      begin intrinsic ~ intrinsndx[s,i];                                53560000
      i ~ intrinsndx[s,i];   % for tracing                              53570000
      go to fin;                                                        53580000
      end;                                                              53590000
non: intrinsic ~ 0;                                                     53600000
fin:                                                                    53610000
end intrinsic;                                                          53620000
%********intrinsic******************************************************53630000
%********loader*********************************************************53640000
% loader reads the program material in the file program, and            53650000
% causes the program to be compiled.  instructions are put into a       53660000
% single array row and passed to compile.  control cards are            53670000
% similarly passed to processcontrolcard.  when an end card is found,   53680000
% the work on the file is terminated.  if this was the global file,     53690000
% compilation is  completed by initializing various global items,       53700000
% and the loader returns to the control code at the end of the          53710000
% deck, causing the interpreter to be called.  note that the highest    53720000
% level of recursive calls of loader may be using the teletype (if      53730000
% programfromremote is true), in which case the program file is not     53740000
% used.                                                                 53750000
procedure loader(program); file program;                                53760000
%                                                                       53770000
%                                                                       53780000
begin                                                                   53790000
integer                                                                 53800000
   i,                                                                   53810000
   j;                                                                   53820000
alpha array                                                             53830000
   inst[0:1022];                                                        53840000
label                                                                   53850000
   a,                                                                   53860000
   cont,                                                                53870000
   control,                                                             53880000
   en,                                                                  53890000
   eof,                                                                 53900000
   fin,                                                                 53910000
   gotinst,                                                             53920000
   initialize,                                                          53930000
   labeled,                                                             53940000
   load,                                                                53950000
   rd,                                                                  53960000
   ttlost,                                                              53970000
   unlabeled;                                                           53980000
switch instbr ~                                                         53990000
   rd,                                                                  54000000
   cont,                                                                54010000
   control,                                                             54020000
   en,                                                                  54030000
   unlabeled,                                                           54040000
   labeled;                                                             54050000
%                                                                       54060000
rd: if death then go to fin;                                            54070000
   instsize ~ 0;                                                        54080000
   if programfromremote then                                            54090000
   begin write(dcwrite[*],fcrlf); if output then;                       54100000
   if input then                                                        54110000
      begin clear(bufout,10);                                           54120000
      while char(dcread[(i1~dcsize-1).w],i1.c) = "#" do                 54130000
         begin                                                          54140000
         write(dcwrite[*],fagain);                                      54150000
         if not output then go to eof;                                  54160000
         if not input then go to eof;                                   54170000
         end;                                                           54180000
      move(dcsize,dcread[*],0,inst[*],0);                               54190000
      move(80-dcsize,bufout[*],0,inst[dcsize.w],dcsize.c);              54200000
      instsize ~ dcsize;                                                54210000
      i ~ max(80,instsize);                                             54220000
      mv(3,stopper,5,inst[i.w],i.c);                                    54230000
      lst(inst);                                                        54240000
      end else go to eof                                                54250000
   end datacomm input else                                              54260000
      begin                                                             54270000
      if not bufferfull then                                            54280000
         begin read(program,10,buffer[*]) [eof];                        54290000
         bufferfull ~ true;                                             54300000
         end;                                                           54310000
      if convertf then convert(buffer);                                 54320000
      lst(buffer);                                                      54330000
      move(fieldsize,buffer[*],0,inst[*],0);                            54340000
      bufferfull ~ false;                                               54350000
      instsize ~ fieldsize;                                             54360000
      read(program,10,buffer[*]) [eof];                                 54370000
      bufferfull ~ true;                                                54380000
      while char(buffer[*],0) = "." do                                  54390000
         begin if convertf then convert(buffer);                        54400000
         lst(buffer);                                                   54410000
         mv(1,blank,7,buffer[*],0);                                     54420000
         move(fieldsize,buffer[*],0,inst[instsize.w],instsize.c);       54430000
         bufferfull ~ false;                                            54440000
         instsize ~ instsize + fieldsize;                               54450000
         read(program,10,buffer[*]) [eof];                              54460000
         bufferfull ~ true;                                             54470000
         end;                                                           54480000
      mv(3,stopper,5,inst[instsize.w],instsize.c);                      54490000
      end;                                                              54500000
gotinst:                                                                54510000
   if slastlabel = 0 then if cardtype(inst[*]) } 5 then                 54520000
      begin                                                             54530000
      if not symbtablsetup then initializesymbtabl;                     54540000
      slastlabel ~ enterst(scanchar(" "," ",inst[*],0),                 54550000
         inst[*],0,"inst");                                             54560000
      if instnum = 0 then entry ~ slastlabel;                           54570000
      ptr ~ 2;                                                          54580000
      go to load;                                                       54590000
      end;                                                              54600000
   go to instbr[cardtype(inst[*])];                                     54610000
   syntaxerr(22,0);                                                     54620000
   comment unrecognized instruction type;                               54630000
   go to rd;                                                            54640000
control:                                                                54650000
   processcontrolcard(inst);                                            54660000
   go to rd;                                                            54670000
cont:                                                                   54680000
   message0(15);                                                        54690000
   messagett0(15);                                                      54700000
   comment illegal continuation--ignored;                               54710000
   go to rd;                                                            54720000
labeled:                                                                54730000
   i ~ enterst(scanchar(" "," ",inst[*],0),inst[*],0,"inst");           54740000
   if nextsegment = 0 then nextsegment ~ i;                             54750000
   if gtf and gts then go to a;                                         54760000
   aa ~ nextsegment & "/:"[24:36:12];                                   54770000
   j ~ if gt then 3 else 4;                                             54780000
   storechars(j,aa,8-j);                                                54790000
   if not gts then                                                      54800000
      begin sloc ~ ptr - 3;                                             54810000
      mv(2,sloc,6,code[marker.w],marker.c+3);                           54820000
      end;                                                              54830000
   if not gtf then                                                      54840000
      begin floc ~ ptr - 3;                                             54850000
      mv(2,floc,6,code[marker.w],marker.c+5);                           54860000
      end;                                                              54870000
   gt ~ gts ~ gtf ~ true;                                               54880000
a: ab ~ string(ptr,slastlabel);                                         54890000
   mv(2,nextsegment,6,code[0],0); % fill  in loc of next segment.       54900000
   nextsegment ~ 0;     % reset for next segment                        54910000
   move(ptr,code[*],0,firstchar(ab));                                   54920000
   valu[slastlabel].loc ~ ab;                                           54930000
   if ptr > maxinstsize then maxinstsize ~ ptr;                         54940000
   % check whether label has occurred before:                           54950000
   if (aa~valu[i]).ch } 3 then                                          54960000
      begin message0(16);                                               54970000
      messagetti(22,instnum);                                           54980000
      mv(2,firstchar(aa),nextsegment,6);                                54990000
      mv(2,nextsegment,6,code[0],0);                                    55000000
      end else code[0] ~ nextsegment ~ 0;                               55010000
   ptr ~ 2;                                                             55020000
   slastlabel ~ i;                                                      55030000
   go to load;                                                          55040000
unlabeled:                                                              55050000
   if gts and gtf then                                                  55060000
      begin message0(17);                                               55070000
      messagetti(16,instnum);                                           55080000
      messages ~ messages + 1;                                          55090000
   end;                                                                 55100000
load:                                                                   55110000
   marker ~ ptr;                                                        55120000
   aa ~ instnum & qmark[30:42:6];                                       55130000
   storechars(3,aa,5);                                                  55140000
   sloc ~ floc ~ 0;                                                     55150000
   storechars(5,0,3);                                                   55160000
   compile(inst);                                                       55170000
   instnum ~ instnum + 1;                                               55180000
   go to rd;                                                            55190000
eof:                                                                    55200000
   % either eof on program file or no input from teletype:              55210000
   if programfromremote then % no input from teletype:                  55220000
      begin                                                             55230000
      write(dcwrite[*],fnoinput,qmark);                                 55240000
      if not output then go to ttlost;                                  55250000
      if not input then go to ttlost;                                   55260000
      while j~char(dcread[*],skipchar(" ",dcread[*],0)) = "y"           55270000
            and j ! "n" do                                              55280000
         begin write(dcwrite[*],fyesorno);                              55290000
         if not output then go to ttlost;                               55300000
         if not input then go to ttlost;                                55310000
         end;                                                           55320000
      go to if j = "y" then rd else ttlost;                             55330000
      end;                                                              55340000
   if loaderlevel > 0 then  % eof for sub-program file                  55350000
      begin                                                             55360000
      if instsize >  0 then go to gotinst;                              55370000
      % last card has been compiled:                                    55380000
      go to fin;                                                        55390000
      end;                                                              55400000
   % eof at level 0:                                                    55410000
   if instsize > 0 then go to gotinst;                                  55420000
   % no card in inst[*]--end card  missing.                             55430000
   write(print,message[25]);                                            55440000
   execute ~ false;                                                     55450000
   go to fin;                                                           55460000
ttlost:                                                                 55470000
   message0(9);                                                         55480000
   execute ~ false;                                                     55490000
   go to fin;                                                           55500000
en:      % end card encountered:                                        55510000
   if slastlabel ! 0 then    % finish up last instruction:              55520000
   begin define dummy=#;                                                55530000
   if not (gtf and gts) then                                            55540000
      begin i ~ if gt then 3 else 4;                                    55550000
      if nextsegment = 0 then                                           55560000
         begin aa ~ "/-E";                                              55570000
         i ~ if gt then 2 else 3;                                       55580000
         j ~ 2;                                                         55590000
         end else                                                       55600000
      % patch--tie to next segment                                      55610000
         begin i ~ if gt then 3 else 4;                                 55620000
         aa ~ nextsegment & "/:"[24:36:12];                             55630000
         j ~ 3;                                                         55640000
         end;                                                           55650000
      storechars(i,aa,8-i);                                             55660000
   if not gts then                                                      55670000
      begin sloc ~ ptr - j;                                             55680000
      move(2,sloc,6,code[marker.w],marker.c+3);                         55690000
      end;                                                              55700000
   if not gtf then                                                      55710000
      begin floc ~ ptr - j;                                             55720000
      move(2,floc,6,code[marker.w],marker.c+5);                         55730000
      end;                                                              55740000
      end;                                                              55750000
   temp ~ string(ptr,slastlabel);                                       55760000
   move(ptr,code[*],0,firstchar(aa));                                   55770000
   valu[slastlabel].loc ~ aa;                                           55780000
   slastlabel ~ 0;                                                      55790000
   if ptr > maxinstsize then maxinstsize ~ ptr;                         55800000
   end;                                                                 55810000
% find entry point, if any:                                             55820000
   p ~ 4 + skipchar(" ",inst[*],4);                                     55830000
   if p < instsize then                                                 55840000
      begin temp ~ p;                                                   55850000
      p ~ p + scanchar(" ",qmark,inst[p.w],p.c);                        55860000
      if p > instsize then p ~ instsize;                                55870000
      entry ~ enterst(p-temp,inst[*],temp,"inst");                      55880000
      end;                                                              55890000
initialize: if loaderlevel = 0 then    % finish up loading:             55900000
   begin alpha array specialinst[0:1];                                  55910000
   if not(ioeof[2] or programfromremote) then                           55920000
      begin move(80,buffer[*],0,nextrecord[2,*],0);                     55930000
      lookf[2] ~ true;                                                  55940000
      end;                                                              55950000
   % check for non-existent labels:                                     55960000
   if printmessages then                                                55970000
      for i ~ 0 step 1 until strmax do                                  55980000
         for j ~ 0 step 1 until stwmax do                               55990000
            if (aa~namtabl[i,j]).[1:2] = 3 then                         56000000
               if valtabl[i,j].s < 9 then                               56010000
                  begin write(bufout[*],message[50]);                   56020000
                  move(min(aa.s,115),firstchar(aa),bufout[*],19);       56030000
                  write(print,17,bufout[*]);                            56040000
                  end;                                                  56050000
   if inform then informa(0,entry);                                     56060000
   if valu[entry].s { 10 then                                           56070000
      begin message0(18); messagett0(18);                               56080000
      execute ~ false;                                                  56090000
      go to fin;                                                        56100000
      end checking entry point;                                         56110000
   %                                                                    56120000
   % initialization of special snobol identifies:                       56130000
   %                                                                    56140000
   % return instructions:                                               56150000
   i ~ enterst(6,words[*],54,"inst");                                   56160000
   if valu[i].s = 0 then                                                56170000
      begin fill specialinst[*] with oct0000140000000000,"0.r00000";    56180000
      specialinst[0].[18:12] ~ instnum;                                 56190000
      aa ~ string(11,i);                                                56200000
      mv(11,specialinst[*],0,firstchar(aa));                            56210000
      valu[i].loc ~ aa;                                                 56220000
      end;                                                              56230000
   %                                                                    56240000
   % freturn instruction:                                               56250000
   %                                                                    56260000
   i ~ enterst(7,words[*],53,"inst");                                   56270000
   if valu[i].s = 0 then                                                56280000
      begin fill specialinst[*] with oct0000140000000000,"0.f00000";    56290000
      specialinst[0].[18:12] ~ instnum;                                 56300000
      aa ~ string(11,i);                                                56310000
      mv(11,specialinst[*],0,firstchar(aa));                            56320000
      valu[i].loc ~ aa;                                                 56330000
      end;                                                              56340000
   %                                                                    56350000
   % initialize quote to """                                            56360000
   %                                                                    56370000
   i ~ enterst(5,words[*],135,"symb");                                  56380000
   valu[i].loc ~ aa ~ string(1,i);                                      56390000
   move(1,quote,7,firstchar(aa));                                       56400000
   %                                                                    56410000
   % initialize qmark to illegal char                                   56420000
   %                                                                    56430000
   i ~ enterst(5,words[*],140,"symb");                                  56440000
   valu[i].loc ~ aa ~ string(1,i);                                      56450000
   move(1,qmark,7,firstchar(aa));                                       56460000
   %                                                                    56470000
   % initialize arrow to "~"                                            56480000
   %                                                                    56490000
   i ~ enterst(5,words[*],145,"symb");                                  56500000
   valu[i].loc ~ aa ~ string(1,i);                                      56510000
   move(1,arrow,7,firstchar(aa));                                       56520000
   %                                                                    56530000
   % the input string read gives the rest of the file program.          56540000
   %                                                                    56550000
   i ~ enterst(4,words[*],150,"symb");                                  56560000
   valu[i].iouse ~ 2;                                                   56570000
   io[i] ~ 0 & 2 cfilno & 1 ciotype & 2 ciouse;                         56580000
   iousage[2] ~ i & 2 ciouse & 1 ciotype;                               56590000
   %                                                                    56600000
   % input string card is from the card-image file named card.          56610000
   %                                                                    56620000
   i ~ enterst(4,words[*],174,"symb");                                  56630000
   valu[i].iouse ~ 3;                                                   56640000
   io[i] ~ 0 & 1 cfilno & 1 ciotype & 3 ciouse;                         56650000
   iousage[1] ~ i & 3 ciouse & 1 ciotype;                               56660000
   %                                                                    56670000
   % print is output to the line printer file print                     56680000
   %                                                                    56690000
   i ~ enterst(5,words[*],154,"symb");                                  56700000
   printloc ~ i;   % save value for trace function                      56710000
   iospace[3] ~ 1;                                                      56720000
   valu[i].iouse ~ 1;                                                   56730000
   io[i] ~ 0 & 3 cfilno & 1 ciotype & 1 ciouse;                         56740000
   iousage[3] ~ i & 1 ciouse & 1 ciotype;                               56750000
   %                                                                    56760000
   % punch is output to the card punch                                  56770000
   %                                                                    56780000
   i ~ enterst(5,words[*],159,"symb");                                  56790000
   valu[i].iouse ~ 1;                                                   56800000
   io[i] ~ 0 & 4 cfilno & 1 ciotype & 1 ciouse;                         56810000
   iousage[4] ~ i & 1 ciouse & 1 ciotype;                               56820000
   %                                                                    56830000
   % look is non-reading input from the rest of program.                56840000
   %                                                                    56850000
   i ~ enterst(4,words[*],164,"symb");                                  56860000
   valu[i].iouse ~ 2;                                                   56870000
   io[i] ~ 0 & 2 cfilno & 2 ciotype & 2 ciouse;                         56880000
   %                                                                    56890000
   % syspot--see cdc 3600 snobol                                        56900000
   %                                                                    56910000
   i ~ enterst(6,words[*],168,"symb");                                  56920000
   valu[i].iouse ~ 1;                                                   56930000
   io[i] ~ 0 & 3 cfilno & 5 ciotype & 1 ciouse;                         56940000
   %                                                                    56950000
   % newdisk is output to the new disk file newdisk                     56960000
   i ~ enterst(7,words[*],178,"symb");                                  56970000
   valu[i].iouse ~ 3;                                                   56980000
   io[i] ~ 0 & 5 cfilno & 1 ciotype & 3 ciouse;                         56990000
   iousage[5] ~ i & 3 ciouse & 1 ciotype;                               57000000
   %                                                                    57010000
   % initialize teletype i/o string;                                    57020000
   % i/o on teletypes is through the tring teletype, which              57030000
   % fails on input if the waiting time is exceeded, and fails          57040000
   % on output if the waiting time is exceeded or if the                57050000
   % break key is used.                                                 57060000
   i ~ enterst(8,words[*],96,"symb");                                   57070000
   valu[i].iouse ~ 3;                                                   57080000
   io[i] ~ 0 & 0 cfilno & 3 ciotype & 3 ciouse;                         57090000
   %                                                                    57100000
   fill iosize[*] with 80,80,132,80,80;                                 57110000
   fill record[*] with -1,-1,-1,-1,-1,-1,-1,-1,-1,-1;                   57120000
   end;                                                                 57130000
fin:                                                                    57140000
   if death then execute ~ false;                                       57150000
end loader;                                                             57160000
%********loader*********************************************************57170000
%********loadlibrary****************************************************57180000
% the procedure loads a library ("object") file created by a -library   57190000
% card during an earlier run.                                           57200000
procedure loadlibrary(mfid,fid);                                        57210000
value mfid, fid;                                                        57220000
alpha mfid, fid;                                                        57230000
begin integer i, j;                                                     57240000
real l1, l2, l3;                                                        57250000
boolean b1, b2, b3;                                                     57260000
alpha array x[0:7];                                                     57270000
monitor index;                                                          57280000
label fail, fin;                                                        57290000
file in lib disk serial (15,6,60);                                      57300000
%                                                                       57310000
index ~ fail;                                                           57320000
fill lib with mfid, fid;                                                57330000
search(lib,x[*]);                                                       57340000
if x[0] { 0 then                                                        57350000
   begin message0(11);                                                  57360000
   messagett0(11);                                                      57370000
   go to fin;                                                           57380000
   end;                                                                 57390000
read(lib,4,bufout[*])  [fail:fail];                                     57400000
write(x[*],flib0,entier(version));                                      57410000
% test validity of file--should match flib0:                            57420000
if not eq(32,bufout[*],0,x[*],0) then  % not a valid libe file          57430000
   begin if eq(20,bufout[*],0,x[*],0) then  % created by earlier version57440000
      begin write(print,fliboldlp);                                     57450000
      write(dcwrite[*],fliboldtt);                                      57460000
      if datacomf then if output then;                                  57470000
      end;                                                              57480000
   go to fin;                                                           57490000
   end;                                                                 57500000
read(lib,flib1,scatterno,maxinstsize,b1,l1,b2,l2,b3,l3)  [fail:fail];   57510000
if scatterno > 15 or maxinstsize > 8181 then go to fail;                57520000
if b1 then begin cpulimitexists~true; cpulimit~l1; end;                 57530000
if b2 then begin iolimitexists~true; iolimit~l2; end;                   57540000
if b3 then begin rulelimitexists~true; rulelimit~l3; end;               57550000
read(lib,flib2,entry,for i~0 step 1 until 15 do usedst[i],instnum)      57560000
    [fail:fail];                                                        57570000
if entry > 4095 then go to fail;                                        57580000
read(lib,flib3,for i~0 step 1 until 15 do nextcell[i])[fail:fail];      57590000
for i ~ 0 step 1 until 15 do                                            57600000
   if usedst[i] then                                                    57610000
      for j ~ 0 step 2 until 254 do                                     57620000
         read(lib,flib4,namtabl[i,j],valtabl[i,j],iotabl[i,j],          57630000
            namtabl[i,j+1],valtabl[i,j+1],iotabl[i,j+1])[fail:fail];    57640000
read(lib,flib5,for i~0 step 1 until 31 do usedrow[i])[fail:fail];       57650000
read(lib,flib6,for i~0 step 1 until 31 do dpntr[i])[fail:fail];         57660000
for i ~ 0 step 1 until 31 do if dpntr[i] > 8183 then go to fail;        57670000
for i ~ 0 step 1 while usedrow[i] do                                    57680000
   for j ~ 0 step 6 until dpntr[i].w do                                 57690000
      begin read(lib,6,x[*])[fail:fail];                                57700000
      if j < 1020                                                       57710000
         then movewds(6,x[*],data[i,j])                                 57720000
         else movewds(3,x[*],data[i,j]);                                57730000
      end;                                                              57740000
symbtablsetup ~ true;                                                   57750000
checksymbtabl;                                                          57760000
go to fin;                                                              57770000
%                                                                       57780000
fail: message0(5);                                                      57790000
   messagett0(5);                                                       57800000
   death ~ true;                                                        57810000
fin:                                                                    57820000
end loadlibrary;                                                        57830000
%********loadlibrary****************************************************57840000
%********lst************************************************************57850000
% lst lists the card-image in a[*]                                      57860000
procedure lst(a);                                                       57870000
   alpha array a[0];                                                    57880000
begin                                                                   57890000
integer i;                                                              57900000
%                                                                       57910000
if cardtype(a[*]) } 4                                                   57920000
      then write(bufout[*],fi7,instnum)                                 57930000
      else write(bufout[*],fbl);                                        57940000
for i ~ listspaces step -1 until 1 do write(print,fbl);                 57950000
move(80,a[*],0,bufout[*],8);                                            57960000
if lstf then write(print,12,bufout[*]);                                 57970000
if punchf then write(punch,10,a[*]);                                    57980000
if dclist then if datacomf then                                         57990000
   begin for i ~ 8 step -1 while i } 0 and                              58000000
      equal(8,blanks,0,bufout[i],0) do;                                 58010000
   write(dcwrite[*],fvcrlf,8|i+1);                                      58020000
   move(8|i,bufout[*],0,dcwrite[*],0);                                  58030000
   if output then;                                                      58040000
   end;                                                                 58050000
end lst;                                                                58060000
%********lst************************************************************58070000
%********message procedures*********************************************58080000
procedure message0(i);                                                  58090000
value i; integer i;                                                     58100000
begin switch format msg0 ~                                              58110000
   ("**program segment too long--insert dummy label after last ",       58120000
    "label and before this instruction."),                           %0058130000
   (//"**define failure--error in local variable list"),             %0158140000
   (//"**define failure--error in first argument"),                  %0258150000
   (//"**define failure--no ( in first argument"),                   %0358160000
   (//"**define failure--no first argument"),                        %0458170000
   (//"**unable to read library file"),                              %0558180000
   (/"The names in use are:"/),                                      %0658190000
   (/"the labels are:"/),                                            %0758200000
   (/"**dummy fmt--msg0[8]"),                                           58210000
   (//"**teletype lost--quitting."),                                 %0958220000
   (//"**invalid parameter."),                                       %1058230000
   ("**file not available"),                                         %1158240000
   (/"**dummy format msg0[12]"),                                     %1258250000
   ("**function already defined--former value lost"),                %1358260000
   (//"**symbol table full"),                                        %1458270000
   ("**illegal continuation card"),                                  %1558280000
   ("**label already defined--former value lost"),                   %1658290000
   ("**this statement can not be reached"),                          %1758300000
   (///"**entry point undefined."///),                               %1858310000
   ("***missing quote"),                                             %1958320000
   ("**unrecognized control card"),                                  %2058330000
   ("**missing parameter"),                                          %2158340000
   ("**attempted return with no function called"),                   %2258350000
   (/"**end format--msg0");                                             58360000
write(print,msg0[i]);                                                   58370000
end message0;                                                           58380000
%***************************************                                58390000
procedure messageai(i,p1,p2);                                           58400000
value i, p1, p2;                                                        58410000
integer i, p2;                                                          58420000
alpha p1;                                                               58430000
begin switch format msgai ~                                             58440000
   (//"**non-numeric argument to .",a2,"() in statement ",i4),          58450000
   (//"**end format--msgai",a6,i10);                                    58460000
write(print,msgai[i],p1,p2);                                            58470000
end messageai;                                                          58480000
%***************************************                                58490000
procedure messagei(i,p);                                                58500000
value i, p;                                                             58510000
integer i, p;                                                           58520000
begin switch format msgi ~                                              58530000
   (//"**integer overflow in statement ",i6),                        %0058540000
   (//"**attempted execution of instruction with syntax error--",       58550000
      "statement ",i6),                                              %0158560000
   (//"**failure of go-to part in statement ",i6),                   %0258570000
   (//"**attempted replacement with string reference used in string"    58580000
      " variable--statement ",i6/x10,"replacement not attempted."//),%0358590000
   (//"**program limit reached in statement ",i6),                   %0458600000
   ("**cpu time limit = ",i12," seconds."),                          %0558610000
   ("**i/o time limit = ",i12," seconds."),                          %0658620000
   ("**rule limit = ",i12),                                          %0758630000
   (//"**illegal second parameter to close in statement ",i6),       %0858640000
   (//"**define failure in statement ",i6),                          %0958650000
   (//"**dump requested in statement ",i6, " :"),                    %1058660000
   (//"**function depth beyond system capacity in statement ",i6),   %1158670000
   (//"**out of space in string storage area--unable to find room for"  58680000
      " a string of ",i6," characters."//),                          %1258690000
   (//"**program died in statement ",i6/),                           %1358700000
   (//"**unable to open file in statement ",i6,"--too many files ",     58710000
      "already in use."/),                                           %1458720000
   (//"**file() error in statement ",i6,"--i/o type (2nd parameter)",   58730000
      " must be null or start with ",""","i","""," or ",""","o","""),%1558740000
   (//"**file() error in statement ",i6,"--number of buffers (3rd ",    58750000
      "parameter) must be numeric and } 1"),                         %1658760000
   (//"**non-numeric arithmetic operand in statement ",i6),          %1758770000
   (//"**divide by zero in statement ",i6),                          %1858780000
   (//"**indirect on null string in statement ",i6),                 %1958790000
   (//"**push-down stack overpopped at function return in statement ",  58800000
      i6),                                                           %2058810000
   (//"**function redefined in statement ",i6),                      %2158820000
   (//"**max number of params & local variables is ",i3),            %2258830000
   (//"**end format--msgi",i10);                                        58840000
write(print,msgi[i],p);                                                 58850000
end messagei;                                                           58860000
%***************************************                                58870000
procedure messagett0(i);                                                58880000
    value i;                                                            58890000
    integer i;                                                          58900000
begin switch format msgt0 ~                                             58910000
   ("{!**program segment too long~"),                                %0058920000
   ("{!**define failure--error in local variable list~"),            %0158930000
   ("{!**define failure--error in first argument~"),                 %0258940000
   ("{!**define failure--no ( in first argument~"),                  %0358950000
   ("{!**define failure--no first argument~"),                       %0458960000
   ("{!bad library file{!~"),                                        %0558970000
   ("{!dump() called{!~"/),                                          %0658980000
   ("{!!snobol wiped out--sorry{!!~"),                               %0758990000
   ("{!interpreter stack overflow--statement too complex{!~"),       %0859000000
   ("{!dummy fmt--msgt0[9]{!!~"),                                    %0959010000
   ("{!**invalid parameter.~"),                                      %1059020000
   ("{!file not available~"),                                        %1159030000
   ("{!dummy format msg0[12]--show to system authors.{!!"),          %1259040000
   ("{!**function already defined--former value lost~"),             %1359050000
   ("{!symbol table full{!"),                                        %1459060000
   ("{!illegal continuation card{!~"),                               %1559070000
   ("{!dummy fmt--msgt0[16]{!!~"),                                   %1659080000
   ("{!dummy fmt--msgt0[17]{!!~"),                                   %1759090000
   ("{!!entry point undefined.{!~"),                                 %1859100000
   ("{!missing quote{!~"),                                           %1959110000
   ("{!illegal control card{!~"),                                    %2059120000
   ("{!missing parameter{!~"),                                       %2159130000
   ("{!end format--msgt0{!!~");                                         59140000
if datacomf then                                                        59150000
   begin write(dcwrite[*],msgt0[i]);                                    59160000
   if output then;                                                      59170000
   end;                                                                 59180000
end messagett0;                                                         59190000
%***************************************                                59200000
procedure messagetta(i,p);                                              59210000
    value i, p;                                                         59220000
    integer i;                                                          59230000
    alpha p;                                                            59240000
begin switch format msgta ~                                             59250000
   ("{!eh",a1,"{!~"),                                               %00 59260000
   ("{!end fmt msgta ",a6,"{!!~");                                      59270000
if datacomf then                                                        59280000
   begin write(dcwrite[*],msgta[i]);                                    59290000
   if output then;                                                      59300000
   end;                                                                 59310000
end;                                                                    59320000
%***************************************                                59330000
procedure messagettai(i,p1,p2);                                         59340000
   value i, p1, p2;                                                     59350000
   integer i, p2;                                                       59360000
   alpha p1;                                                            59370000
begin switch format msgtai ~                                            59380000
   ("{!non-numeric argument to .",a2,"() in stmt ",i*,"{!~"),      %00  59390000
   ("{!!end fmt msgtai ",i*,a6,"{!!~");                                 59400000
if datacomf then                                                        59410000
   begin write(dcwrite[*],msgtai[i],p1,digits(p2),p2);                  59420000
   if output then;                                                      59430000
   end;                                                                 59440000
end;                                                                    59450000
%***************************************                                59460000
procedure messagetti(i,p);                                              59470000
   value i, p;                                                          59480000
   integer i, p;                                                        59490000
begin switch format msgti ~                                             59500000
   ("{!**integer overflow in stmt ",i*,"{!~"),                       %0059510000
   ("{!!**attempted execution of stmt with syntax error--",             59520000
      "stmt ",i*,"{!~"),                                             %0159530000
   ("{!!**go-to part in stmt ",i*," failed{!~"),                     %0259540000
   ("{!**attempted replacement with string reference used in string ",  59550000
      " variable, in stmt ",i*,"{!**replacement not attempted{!~"),  %0359560000
   ("{!**program limit reached in statement ",i*,"{!~"),             %0459570000
   ("{!cpu time limit = ",i*," seconds{!~"),                         %0559580000
   ("{!i/o time limit = ",i*," seconds{!~"),                         %0659590000
   ("{!rule limit = ",i*,"{!~"),                                     %0759600000
   ("{!illegal 2nd param to close in stmt ",i*,"{!~"),               %0859610000
   ("{!define failure in statement ",i*,"{!~"),                      %0959620000
   ("{!!fatal error in statment ",i*,"{!~"),                         %1059630000
   ("{!**function depth beyond system capacity in stmt ",i*,"{!~"),  %1159640000
   ("{!**out of space--unable to find room for string of ",i*,          59650000
      " characters{!~"),                                             %1259660000
   ("{!**program died in statement ",i*,"{!~"),                      %1359670000
   ("{!**attempted return with no function called--stmt ",i*,"{!~"), %1459680000
   ("# ",i*,"{!~"),                                                  %1559690000
   ("{!stmt. ",i*," cant be reached.{!~"),                           %1659700000
   ("{!non-numeric arithmetic operand in statement ",i*,"{!~"),      %1759710000
   ("{!divide by zero in statement ",i*,"{!~"),                      %1859720000
   ("{!indirect on null string in stmt ",i*,"{!~"),                  %1959730000
   ("{!push-down stack overpopped at fct return in stmt ",i*,"{!~"), %2059740000
   ("{!**function re-defined in statement ",i*,"{!~"),               %2159750000
   ("{!**label re-defined in statement ",i*,"{!~"),                  %2259760000
   ("{!!**normal termination in statement ",i*,"{!~"),               %2359770000
   ("{!**max number of params & loc vars is ",i*,"{!~"),            %24 59780000
   ("{!!end fmt--msgti",i*,"{!~");                                      59790000
if datacomf then                                                        59800000
   begin write(dcwrite[*],msgti[i],digits(p),p);                        59810000
   if output then;                                                      59820000
   end;                                                                 59830000
end;                                                                    59840000
%********message procedures*********************************************59850000
%********min************************************************************59860000
integer procedure min(a,b); value a,b; integer a,b;                     59870000
min ~ if a { b then a else b;                                           59880000
%********min************************************************************59890000
%********mnemno*********************************************************59900000
% the string between a[p.w],p.c and the next blank is searched for      59910000
% in the n-th list of mnemonics, and the appropriate index is returned. 59920000
integer procedure mnemno(n,a,p);                                        59930000
   value n;                                                             59940000
   integer n, p;                                                        59950000
   array a[0];                                                          59960000
begin label fin;                                                        59970000
integer i, j;                                                           59980000
alpha aa;                                                               59990000
if i~scanchar(" ","~",a[p.w],p.c) > 6                                   60000000
   then mnemno ~ 0 else                                                 60010000
   begin aa ~ 0;                                                        60020000
   mv(i,a[p.w],p.c,aa,8-i);                                             60030000
   aa ~ aa;                                                             60040000
   for j~mnemonic[n,0] step -1 until 1 do                               60050000
      if aa = mnemonic[n,j] then                                        60060000
         begin mnemno ~ j;                                              60070000
         p ~ p + i;                                                     60080000
         go to fin;                                                     60090000
         end;                                                           60100000
   mnemno ~ 0;                                                          60110000
   end;                                                                 60120000
fin:                                                                    60130000
end mnemno;                                                             60140000
%********mnemno*********************************************************60150000
%********newcell********************************************************60160000
% newcell returns the address of an available symbol table cell--using  60170000
% row i if possible.  cells given by newcell are "permanent" in the     60180000
% sense that returncell is needed to return them to available space.    60190000
% compare tempcell, which returns a cell that will only last until      60200000
% the end of the instruction                                            60210000
alpha procedure newcell(i);                                             60220000
value i; integer i;                                                     60230000
begin label rowfull, return;                                            60240000
integer c;                                                              60250000
if nextcell[i] = 0 then go to rowfull;                                  60260000
c ~ nextcell[i];                                                        60270000
   nextcell[i] ~ name[c].link;                                          60280000
go to return;                                                           60290000
rowfull: for i ~ 0 step 1 while i { 15 and usedst[i] do                 60300000
   if nextcell[i] ! 0 then                                              60310000
      begin c ~ nextcell[i];                                            60320000
      nextcell[i] ~ name[c].link;                                       60330000
      go to return;                                                     60340000
      end;                                                              60350000
   if i { 15 then                                                       60360000
      begin newstrow(i);                                                60370000
      c ~ 0 & i concstr;                                                60380000
      go to return;                                                     60390000
      end;                                                              60400000
message0(14);                                                           60410000
messagett0(14);                                                         60420000
death ~ true;                                                           60430000
c ~ 0;                                                                  60440000
return:                                                                 60450000
% if nextcell[i] > usedcell[i] then usedcell[i] ~ nextcell[i];          60460000
name[c] ~ 0;                                                            60470000
valu[c] ~ 0;                                                            60480000
newcell ~ c;                                                            60490000
% if inform then informia(1,i,c);                                       60500000
end newcell;                                                            60510000
%********newcell********************************************************60520000
%********newstrow*******************************************************60530000
% newstrow opens up row i of the symbol table, and initializes an       60540000
% available space list in this row.                                     60550000
procedure newstrow(i); value i; integer i;                              60560000
begin integer j;                                                        60570000
namtabl[i,0].link ~ 1 & i concstr;                                      60580000
for j ~ 1 step 1 while j < stwmax do                                    60590000
   namtabl[i,j].link ~ (j+1) & i concstr;                               60600000
usedst[i] ~ true;                                                       60610000
nextcell[i] ~ 1 & i concstr;                                            60620000
end newtrow;                                                            60630000
%********newstrow*******************************************************60640000
%********nullargs*******************************************************60650000
% interpreter procedure:                                                60660000
% nullargs(n) puts n null strings on top of the stack.                  60670000
boolean procedure nullargs(n); value n; integer n;                      60680000
begin label return;                                                     60690000
integer i;                                                              60700000
if sp + n } stacksize then                                              60710000
   begin                                                                60720000
   informi(4,instno);                                                   60730000
   nullargs ~ false;                                                    60740000
   go to return;                                                        60750000
   end;                                                                 60760000
for i ~ sp+n-1 step -1 until sp do                                      60770000
   pst[i] ~ ptype[i] ~ psize[i] ~ 0;                                    60780000
sp ~ sp + n;                                                            60790000
nullargs ~ true;                                                        60800000
return:                                                                 60810000
end nullargs;                                                           60820000
%********nullargs*******************************************************60830000
%********numval*********************************************************60840000
% interpreter procedure:                                                60850000
% if the string value of symb table entry st is non-numeric,            60860000
% false is returned and val is unaltered.  if the string is numeric,    60870000
% the value of the string is assigned to val, and true is returned.     60880000
boolean procedure numval(st,val);                                       60890000
value st; alpha st; integer val;                                        60900000
begin boolean stream procedure numeric(s,l,i); value s,i;               60910000
   begin label return;                                                  60920000
   tally ~ 0;                                                           60930000
      si ~ loc s; si ~ si + 7;                                          60940000
   if sc = "0" then                                                     60950000
      begin tally ~ 1; go to return; end;                               60960000
   si ~ l; si ~ si + i;                                                 60970000
   if sc = "-" then                                                     60980000
      begin si ~ si + 1; tally ~ s;                                     60990000
      tally ~ tally + 63; s ~ tally; tally ~ 0;                         61000000
      end;                                                              61010000
   s(if sc < "0" then jump out to return;                               61020000
      if sc > "9" then jump out to return;                              61030000
      si ~ si + 1);                                                     61040000
   tally ~ 1;                                                           61050000
   return: numeric ~ tally;                                             61060000
   end numeric;                                                         61070000
%                                                                       61080000
st ~ valu[st];                                                          61090000
if numeric(stringloc(st)) then                                          61100000
   begin if st.ch < 4096                                                61110000
      then read(data[st.r,*],fnum,st.ch,st.s,val)                       61120000
      else read(data[st.r,*],fint,st.w,st.c,st.s,val);                  61130000
      % this distinction is necessary because when an "x*" format       61140000
      % (as in fnum) is used, only the last 12 bits of the number       61150000
      % are used, and a ch field contains 13 bits.  on the other        61160000
      % hand, if "*d" is used (as in fint), and the number given        61170000
      % is zero, an infinite loop occurs, since 0 is taken to mean      61180000
      % "repeat indefinitely", and the rest of the format will never    61190000
      % be reached.  thus, two cases are necessary.                     61200000
   numval ~ true;                                                       61210000
   end else numval ~ false;                                             61220000
% if inform then informi(12,val);                                       61230000
end numval;                                                             61240000
%********numval*********************************************************61250000
%********output*********************************************************61260000
% teletype output procedure:                                            61270000
boolean procedure output;                                               61280000
begin                                                                   61290000
     label loop, nogo, broke, badnews, exit;                            61300000
     integer  cnt, q, r, timex;                                         61310000
     boolean gpmk;                                                      61320000
     real s;                                                            61330000
     array tank[0:bufoutsize-1];                                        61340000
     stream procedure stopper(a);                                       61350000
          begin di~a; di~di+7; ds~lit "~"  end stopper;                 61360000
     boolean stream procedure move(a,b,c);  value c;                    61370000
          begin  si~a; si~si+c; di~b; tally~0;                          61380000
               dcoutchar(if sc="~" then tally~1; ds~chr);               61390000
               move~tally                                               61400000
          end move;                                                     61410000
   % if inform then informii(5,stat[user].[9:4],stat[user].[14:4]);     61420000
   if not datacomf then go to exit;                                     61430000
   output ~ true;                                                       61440000
   if break then                                                        61450000
      begin if (break~boolean(status(stat[user],1).[26:1])) then        61460000
         begin when(5);                                                 61470000
         break ~ boolean(status(stat[user],1).[26:1]);                  61480000
         end;                                                           61490000
      if break then go to badnews;                                      61500000
      end;                                                              61510000
   stopper(dcwrite[(anssize-1).w]);                                     61520000
   timex ~ time(1);                                                     61530000
loop:   q~cnt div 8;  r~cnt mod 8;                                      61540000
     gpmk ~ move(dcwrite[q],tank[1],r);                                 61550000
   mv(1,arrow,7,tank[4],4);                                             61560000
   write(dcout(stat[user],0),bufoutsize,tank[*]) [nogo:broke];          61570000
   if boolean(status(stat[user],1).[26:1]) then go to broke;            61580000
   if gpmk then go to exit;                                             61590000
   cnt ~ cnt + dcoutchar;                                               61600000
   go to loop;                                                          61610000
broke:                                                                  61620000
   break ~ true;                                                        61630000
   output ~ false;                                                      61640000
   go to exit;                                                          61650000
nogo:                                                                   61660000
   % some fields in the status word are:                                61670000
   % [23:1] = 1 if abnormal condition sensed by adapter.                61680000
   % [24:1] = 1 if read ready.                                          61690000
   % [28:1] = 1 if buffer overflow (on input).                          61700000
   % [30:1] = 1 if not ready.                                           61710000
   s ~ status(stat[user],0);                                            61720000
   if boolean(s.[30:1]) then go to badnews;                             61730000
   if time(1) - timex > waittime then go to badnews;                    61740000
   if s.[23:2]!0 or boolean(s.[28:1]) then when(5);                     61750000
%  wait 5 secs if write did not time out                                61760000
   go to loop;                                                          61770000
badnews:                                                                61780000
   output ~ false;                                                      61790000
   findusers;                                                           61800000
exit:   end output;                                                     61810000
%========== end data com output procedure ==============================61820000
%********pop************************************************************61830000
boolean procedure pop(stloc); value stloc; alpha stloc;                 61840000
begin alpha t, st;                                                      61850000
integer i;                                                              61860000
% if inform then informa(2,stloc);                                      61870000
st ~ valu[stloc].link;                                                  61880000
if st = 0 then pop ~ false else                                         61890000
   begin valu[stloc] ~ t ~ valu[st];                                    61900000
   if t.ch } 3 then    % reset back-pointer to symb table.              61910000
      begin i ~ t.ch - 2;                                               61920000
      mv(2,stloc,6,data[t.r,i.w],i.c);                                  61930000
      end;                                                              61940000
   valu[stloc].link ~ valu[st].link;   % link to next cell on stack.    61950000
   returncell(st);     % put back on avsl.                              61960000
   pop ~ true;                                                          61970000
   end;                                                                 61980000
end pop;                                                                61990000
%********pop************************************************************62000000
%********processcontrolcard*********************************************62010000
% processcontrolcard uses char, movechars, controlparameter.            62020000
procedure processcontrolcard(a);                                        62030000
   alpha array a[0];                                                    62040000
begin integer i, p;                                                     62050000
label                                                                   62060000
   e,              % end of procedure                                   62070000
   illegal,        % illegal control card                               62080000
   nofile,         % file referenced which cant be read                 62090000
   paramerr,       % error in parameter to control card                 62100000
   parammissing;   % cant find a needed parameter to control card       62110000
%                                                                       62120000
p ~ i ~ 1 + skipchar(" ",a[*],1);                                       62130000
do p ~ p + 1 until p - i > 7 or chartype[char(a[*],p)] ! 3;             62140000
if p - i > 7 then go to illegal;                                        62150000
aa ~ 0;                                                                 62160000
mv(p-i,a[*],i,aa,8-p+i);                                                62170000
for i ~ numcontrolcards step -1 until 0 do                              62180000
   if aa = controlcard[i] then                                          62190000
   begin case i of                                                      62200000
%********control cards*****************                                 62210000
   begin go to illegal;                                                 62220000
% 1: -debug     turns on debug mode                                     62230000
   begin debugging ~ true;                                              62240000
   if nextsourcerecord = 0 then nextsourcerecord ~ 1;                   62250000
   debugrulelimitexists ~ alimitexists ~ true;                          62260000
   % this will cause suspension at the first instruction.               62270000
   end;                                                                 62280000
% 2: -pcc     causes all control cards to be printed                    62290000
   pcc ~ true;                                                          62300000
% 3: -list     causes the program to be listed.                         62310000
   begin if listspaces~controlparameter(a,p) < 0 then listspaces ~ 0;   62320000
   lstf ~ true;                                                         62330000
   end;                                                                 62340000
% 4: -unlist     causes the listing to stop                             62350000
   lstf ~ false;                                                        62360000
% 5: -punch     causes the program deck to be punched                   62370000
   punchf ~ true;                                                       62380000
% 6: -eject     ejects the line printer to the next page                62390000
   begin i ~ controlparameter(a,p);                                     62400000
   if i < -1 or i > 11 then go to paramerr;                             62410000
   if i < 1 then i ~ 1;                                                 62420000
   if lstf then write(print[i]);                                        62430000
   end;                                                                 62440000
% 7: -space <integer>    produces <integer> blank lines in the listing  62450000
   begin                                                                62460000
   i ~ controlparameter(a,p);                                           62470000
   for i ~ i-1 while i } 0 do write(print,fbl);                         62480000
   end;                                                                 62490000
% 8: -width <integer>    sets the number of chars in each card image    62500000
   % to be considered part of an instruction; all chars after the nth   62510000
   % are to be ignored by the compiler.                                 62520000
   % if this card isnt used, then fieldsize is assumed to be 72.        62530000
   begin                                                                62540000
   if i ~ controlparameter(a,p) > 80 or i < 0                           62550000
      then go to paramerr;                                              62560000
   fieldsize ~ i;                                                       62570000
   end;                                                                 62580000
% 9: -26      turns on character set conversion from the 026 keypunch   62590000
   begin convertf ~ true;                                               62600000
   convertstrings ~ false;                                              62610000
   end;                                                                 62620000
% 10: -3600    causes char set conversion and translation of i/o        62630000
   % strings are from cdc 3600 snobol.                                  62640000
   convertf ~ convertstrings ~ true;                                    62650000
% 11: -b5500    cancels the effect of previous -26 and -3600 cards.     62660000
   convertf ~ convertstrings ~ false;                                   62670000
% 12: -define a,b,c     acts like the intrinsic function define,        62680000
   % but sets up the function at compile time.  this saves the space    62690000
   % that a run-time definition would take for literals and instruc-    62700000
   % tion code, plus the time needed for compilation.                   62710000
   % a, b, and c must be literals.                                      62720000
   begin integer array st[1:3];                                         62730000
   integer j;                                                           62740000
   label def1, deferr;                                                  62750000
   %                                                                    62760000
   if not symbtablsetup then initializesymbtabl;                        62770000
   for j ~ 1,2,3 do st[j] ~ 0;                                          62780000
   for j ~ 1,2,3 do                                                     62790000
      begin p ~ p + scanchar(""",",",a[p.w],p.c);                       62800000
      if p } instsize then go to def1;                                  62810000
      if char(a[p.w],p.c) = "," then                                    62820000
         begin st[j] ~ 0;                                               62830000
         p ~ p + 1;                                                     62840000
         end else                                                       62850000
         begin p ~ p + 1;                                               62860000
         i ~ p + scanchar(""",qmark,a[p.w],p.c);                        62870000
         if i } instsize then go to deferr;                             62880000
         st[j] ~ newcell(0);                                            62890000
         aa ~ string(i-p,st[j]);                                        62900000
         move(i-p,a[p.w],p.c,data[aa.r,aa.w],aa.c);                     62910000
         valu[st[j]] ~ aa;                                              62920000
         p ~ i + scanchar(",",""",a[i.w],i.c+1) + 1;                    62930000
         if char(a[p.w],p.c) = "," then p ~ p + 1;                      62940000
         if p } instsize then go to def1;                               62950000
         end;                                                           62960000
      end;                                                              62970000
def1: if not snbldefine(st[1],st[2],st[3]) then go to paramerr;         62980000
   for j ~ 1,2,3 do if st[j] ! 0 then returncell(st[j]);                62990000
   go to e;                                                             63000000
deferr: message0(19); % missing quote                                   63010000
   messagett0(19);                                                      63020000
   end define;                                                          63030000
% 13: -wait <n>     sets the waiting time for remote i/o to n seconds.  63040000
   % if n is not > 0, then standardwaittime is used.                    63050000
   begin aa ~ controlparameter(a,p);                                    63060000
   if aa < 0 then go to paramerr;                                       63070000
   waittime ~ aa | 60;                                                  63080000
   end;                                                                 63090000
% 14: -limit <i> lsinteger>    puts a limit of <integer> to the         63100000
   % quantity <i>; this limit is checked at the start of the execution  63110000
   % of each instruction.  the current values of <i> are:               63120000
   %     rules puts a limit to the number of statements executed.       63130000
   %     process puts a limit (in seconds) to cpu time                  63140000
   %     io puts a limit (in seconds) to i/o time                       63150000
   begin label loop;                                                    63160000
loop: p ~ p + 1;                                                        63170000
   p ~ p + skipchar(" ",a[*],p);                                        63180000
   if p > instsize then go to paramerr;                                 63190000
   i ~ scanchar(" ","=",a[*],p);                                        63200000
   if i > instsize then go to paramerr;                                 63210000
   if i = 2 then                                                        63220000
      begin if eq(2,words[8],3,a[*],p)                                  63230000
         then i ~ 0 else go to loop;                                    63240000
      end else                                                          63250000
   if i = 5 then                                                        63260000
      begin if eq(5,words[8],5,a[*],p)                                  63270000
         then i ~ 1 else go to loop;                                    63280000
      end else                                                          63290000
   if i = 7 then                                                        63300000
      begin if eq(7,words[9],2,a[*],p)                                  63310000
         then i ~ 2 else go to loop;                                    63320000
      end else                                                          63330000
      go to loop;                                                       63340000
      if (p~controlparameter(a,p)) < 0 then go to paramerr;             63350000
      case i of                                                         63360000
         begin                                                          63370000
         begin iolimit ~ p | 60;                                        63380000
         iolimitexists ~ true;                                          63390000
         end;                                                           63400000
         begin rulelimit ~ p;                                           63410000
         rulelimitexists ~ true;                                        63420000
         end;                                                           63430000
         begin cpulimit ~ p | 60;                                       63440000
         cpulimitexists ~ true;                                         63450000
         end                                                            63460000
         end cases;                                                     63470000
   alimitexists ~ true;                                                 63480000
   end lmt;                                                             63490000
% 15: -size <n>    tells the compiler how many scatter areas to set     63500000
   % aside in symbtabl.  this control card must appear before any snobol63510000
   % instructions; the value of <n> should be approximately the number  63520000
   % of instructions in the program                                     63530000
   begin define dummy=#;                                                63540000
   if symbtablsetup then go to illegal;                                 63550000
   i ~ controlparameter(a,p);                                           63560000
   if i < 0 then go to paramerr;                                        63570000
   if i < 150 then begin scatterno ~ 0; go to e; end;                   63580000
   if i < 300 then begin scatterno ~ 1; go to e; end;                   63590000
   if i < 475 then begin scatterno ~ 2; go to e; end;                   63600000
   if i < 600 then begin scatterno ~ 3; go to e; end;                   63610000
   if i < 800 then begin scatterno ~ 4; go to e; end;                   63620000
   scatterno ~ 5;                                                       63630000
   end;                                                                 63640000
% 16: -set <name> <literal>     sets the variable <name> to             63650000
   % have the initial value of <literal>.                               63660000
   begin integer p1, p2;                                                63670000
   if not symbtablsetup then initializesymbtabl;                        63680000
   % find name:                                                         63690000
   i ~ p ~ p + skipchar(" ",a[*],p);                                    63700000
   while chartype[char(a[p.w],p.c)] = 3 do p ~ p + 1;                   63710000
   if p } instsize or p = i then go to parammissing;                    63720000
   aa ~ enterst(p-i,a[*],i,"symb");                                     63730000
   % find value:                                                        63740000
   p1 ~ p + scanchar(""",""",a[p.w],p.c);                               63750000
   if p1 } instsize then go to parammissing;                            63760000
   p ~ p1 ~ p1 + 1;                                                     63770000
   while p < instsize do                                                63780000
      begin p2 ~ p + scanchar(""",""",a[p.w],p.c);                      63790000
      if p2 } instsize then  % missing quote:                           63800000
         begin message0(19);                                            63810000
         messagett0(19);                                                63820000
         go to e;                                                       63830000
         end;                                                           63840000
      p ~ p2 + scanchar(""",""",a[p2.w],p2.c+1) + 1;                    63850000
      if p < instsize then   % squeeze instruction:                     63860000
         begin move(instsize-p-1,a[p.w],p.c+1,a[p2.w],p2.c);            63870000
         instsize ~ instsize - (p - p2 + 1);                            63880000
         p ~ p2 + 1;                                                    63890000
         end;                                                           63900000
      end;                                                              63910000
   % p1, p2 now delimit the value.                                      63920000
   ab ~ string(p2-p1,aa);                                               63930000
   move(p2-p1,a[p1.w],p1.c,firstchar(ab));                              63940000
   valtabl[aa.str,aa.stw] ~ ab;                                         63950000
   end set;                                                             63960000
% 17: -library <fid>/<mfid>     creates a library copy of the           63970000
   % snobol program begin compiled, with the name <mfid>/<fid>.         63980000
   % this library file can be loaded for a later run with the control   63990000
   % card -load <mfid>/<fid>.                                           64000000
   begin define dummy =#;                                               64010000
   if entry = 0 then go to illegal;                                     64020000
   if loadf then if slastlabel ! 0 then                                 64030000
      begin i ~ ptr;                                                    64040000
      if not (gts and gtf) then                                         64050000
         begin                                                          64060000
         storechars(if gt then 2 else 3,"/-e",if gt then 6 else 5);     64070000
         if not gt then i ~ i + 1;                                      64080000
         if not gts then                                                64090000
            begin sloc ~ i;                                             64100000
            mv(2,sloc,6,code[marker.w],marker.c+3);                     64110000
            end;                                                        64120000
         if not gtf then                                                64130000
            begin floc ~ i;                                             64140000
            mv(2,floc,6,code[marker.w],marker.c+5);                     64150000
            end;                                                        64160000
         end;                                                           64170000
      aa ~ string(ptr,slastlabel);                                      64180000
      move(ptr,code[*],0,firstchar(aa));                                64190000
      valu[slastlabel].loc ~ aa;                                        64200000
      if ptr > maxinstsize then maxinstsize ~ ptr;                      64210000
      ptr ~ i;                                                          64220000
      end;                                                              64230000
   p ~ p + skipchar(" ",a[*],p);                                        64240000
   i ~ p + scanchar("/"," ",a[*],p);                                    64250000
   if i } fieldsize or char(a[i.w],i.c) ! "/" then go to paramerr;      64260000
   aa ~ 0;                                                              64270000
   mv(7,blanks,1,aa,1);                                                 64280000
   ab ~ aa;                                                             64290000
   mv(min(7,i-p),a[p.w],p.c,aa,1);                                      64300000
   p ~ i + 1;                                                           64310000
   i ~ p + scanchar(" ",qmark,a[p.w],p.c);                              64320000
   if i { p or i > instsize then go to paramerr;                        64330000
   mv(min(7,i-p),a[p.w],p.c,ab,1);                                      64340000
   createlibrary(aa,ab);                                                64350000
   end library;                                                         64360000
% 18: -load <a>/<b>    cause the disk file <a>/<b> to be                64370000
   % considered a compiled snobol program, and loaded.  this card       64380000
   % is illegal if instructions, -define or -set cards have been        64390000
   % already encountered.  in addition, only one -load card is          64400000
   % accepted per job.                                                  64410000
   begin define dummy=#;                                                64420000
   if symbtablsetup then go to illegal;                                 64430000
   p ~ p + skipchar(" ",a[*],p);                                        64440000
   i ~ p + scanchar("/"," ",a[*],p);                                    64450000
   if i } instsize  or char(a[i.w],i.c) ! "/" then go to paramerr;      64460000
   aa ~ 0;                                                              64470000
   mv(7,blanks,1,aa,1);                                                 64480000
   ab ~ aa;                                                             64490000
   mv(min(7,i-p),a[p.w],p.c,aa,1);                                      64500000
   p ~ i + 1;                                                           64510000
   i ~ p + scanchar(" ",qmark,a[p.w],p.c);                              64520000
   if i { p or i > instsize then go to paramerr;                        64530000
   mv(min(7,i-p),a[p.w],p.c,ab,1);                                      64540000
   loadlibrary(aa,ab);                                                  64550000
   if death then go to endterpret;                                      64560000
   end load;                                                            64570000
% 19: -compile <a>/<b>     tells the loader to compile the disk file    64580000
   % <a>/<b> into the program at the point where this card appears.     64590000
   begin file in prog disk serial (1,10,30);                            64600000
   boolean rmt, buffull;                                                64610000
   alpha array buf[0:10], x[0:6];                                       64620000
   integer s1, s2;                                                      64630000
   alpha aa, ab;                                                        64640000
   %                                                                    64650000
   p ~ p + skipchar(" ",a[*],p);                                        64660000
   i ~ p + scanchar("/"," ",a[*],p);                                    64670000
   if i } instsize or char(a[i.w],i.c) ! "/" then go to paramerr;       64680000
   aa ~ 0;                                                              64690000
   mv(7,blanks,1,aa,1);                                                 64700000
   ab ~ aa;                                                             64710000
   mv(s1~min(7,i-p),a[p.w],p.c,aa,1);                                   64720000
   p ~ i + 1;                                                           64730000
   i ~ p + scanchar(" ",qmark,a[p.w],p.c);                              64740000
   if i { p or i > instsize then go to paramerr;                        64750000
   mv(s2~min(7,i-p),a[p.w],p.c,ab,1);                                   64760000
   fill prog with aa,ab;                                                64770000
   search(prog,x[*]);                                                   64780000
   if x[0] { 0 then go to nofile;                                       64790000
   if buffull~bufferfull then movewds(10,buffer[0],buf[0]);             64800000
   read(prog,10,buffer[*]) [nofile:nofile];                             64810000
   bufferfull ~ true;                                                   64820000
   loaderlevel ~ loaderlevel + 1;                                       64830000
   rmt ~ programfromremote; programfromremote ~ false;                  64840000
   loader(prog);                                                        64850000
   write(bufout[*],fendprog);                                           64860000
   mv(s1,aa,1,bufout[*],22);                                            64870000
   mv(1,slash,7,bufout[*],22+s1);                                       64880000
   mv(s2,ab,1,bufout[*],23+s1);                                         64890000
   write(print,5,bufout[*]);                                            64900000
   if datacomf then                                                     64910000
      begin mv(2,crlf,5,dcwrite[*],0);                                  64920000
      mv(21+s1+s2,bufout[*],2,dcwrite[*],2);                            64930000
      mv(3,crlf,5,dcwrite[*],23+s1+s2);                                 64940000
      if output then;                                                   64950000
      end;                                                              64960000
   if bufferfull~buffull then movewds(10,buf[0],buffer[0]);             64970000
   loaderlevel ~ loaderlevel - 1;                                       64980000
   programfromremote ~ rmt;                                             64990000
   end compile card;                                                    65000000
% 20: -inform     turns on informative diagnostics.  if the system-     65010000
   % degbuggin flag is true, then the system debugging aids             65020000
   % are enabled.                                                       65030000
   begin inform ~ systemdebugging;                                      65040000
   printmessages ~ true;                                                65050000
   end;                                                                 65060000
% 21: -silence    turns off diagnostic messages turned on by -inform    65070000
   inform ~ printmessages ~ false;                                      65080000
   end control cards case statement;                                    65090000
%********control cards*****************                                 65100000
   go to e;                                                             65110000
   end;                                                                 65120000
illegal:                                                                65130000
   message0(20);                                                        65140000
   messagett0(20);                                                      65150000
   messages ~ messages + 1;                                             65160000
   go to e;                                                             65170000
parammissing:                                                           65180000
   message0(21);                                                        65190000
   messagett0(21);                                                      65200000
   messages ~ messages + 1;                                             65210000
   go to e;                                                             65220000
nofile:                                                                 65230000
   message0(11);                                                        65240000
   messagett0(11);                                                      65250000
   go to e;                                                             65260000
paramerr:                                                               65270000
   message0(10);                                                        65280000
   messagett0(10);                                                      65290000
   messages ~ messages + 1;                                             65300000
e: end processcontrolcard;                                              65310000
%********processcontrolcard*********************************************65320000
%********push***********************************************************65330000
boolean procedure push(stloc,newval);                                   65340000
   value stloc, newval; alpha stloc, newval;                            65350000
begin alpha st, t, t1;                                                  65360000
integer i;                                                              65370000
label return;                                                           65380000
% if inform then informa(1,stloc);                                      65390000
st ~ newcell(stloc.str);                                                65400000
if death then                                                           65410000
   begin push ~ false; go to return; end;                               65420000
valu[st] ~ t1 ~ valu[stloc];                                            65430000
if t1.ch } 3 then  % if < 3 there is no string being pointed to.        65440000
   begin i ~ t1.ch - 2;                                                 65450000
   mv(2,st,6,data[t1.r,i.w],i.c);                                       65460000
   end;                                                                 65470000
valu[st].link ~ valu[stloc].link;                                       65480000
valu[stloc] ~ 0 & t1 [1:1:4] & st clink;                                65490000
if newval ! 0 then  % assign new value                                  65500000
   begin if stloc = newval    % push(n,n) called.                       65510000
      then newval ~ st;       % re-assign old value.                    65520000
   st ~ valu[newval].s;                                                 65530000
   t ~ string(st,stloc);                                                65540000
   if death then                                                        65550000
      begin push ~ false; go to return; end;                            65560000
   newval ~ valu[newval];                                               65570000
   move(st,firstchar(newval),firstchar(t));                             65580000
   valu[stloc].loc ~ t;                                                 65590000
   end;                                                                 65600000
push ~ true;                                                            65610000
return:                                                                 65620000
end push;                                                               65630000
%********push***********************************************************65640000
%********returncell*****************************************************65650000
procedure returncell(n); value n; alpha n;                              65660000
begin define dummy=#;                                                   65670000
% if inform then imforma(3,n);                                          65680000
name[n] ~ 0 & nextcell[n.str] clink;                                    65690000
valu[n] ~ 0;                                                            65700000
nextcell[n.str] ~ n;                                                    65710000
end returncell;                                                         65720000
%********returncell*****************************************************65730000
%********returntemp*****************************************************65740000
procedure returntemps;                                                  65750000
begin integer i; alpha st,p;                                            65760000
% if inform then inform0(7);                                            65770000
for i ~ 0 step 1 until 15 do if usedst[i] then                          65780000
   if templist[i] ! 0 then                                              65790000
      begin st ~ templist[i];                                           65800000
      p ~ nextcell[i];                                                  65810000
      templist[i] ~ 0;                                                  65820000
      nextcell[i] ~ name[st].link;                                      65830000
      name[st] ~ 0 & p clink;                                           65840000
      end;                                                              65850000
end returntemps;                                                        65860000
%********returntemp*****************************************************65870000
%********scatter********************************************************65880000
alpha procedure scatter(size,loc,p,x);                                  65890000
value size, p, x;                                                       65900000
integer size, p;                                                        65910000
alpha array loc[0];                                                     65920000
alpha x;                                                                65930000
begin alpha i, j, k;                                                    65940000
j ~ if size = 0 then 1/x else size/x;                                   65950000
for i ~ 1 step 1 until size do                                          65960000
   j ~ j + x / (i + char(loc[(k~p+i-1).w],k.c));                        65970000
k ~ j.[8:30];                                                           65980000
i.str ~ entier(k mod (scatterno+1));                                    65990000
j.[1:9] ~ 0;                                                            66000000
%  literals are scattered into a different area than other quantities:  66010000
i.stw ~ if x = "lit"                                                    66020000
   then scattersize + entier(j mod 16)                                  66030000
   else entier(j mod scattersize);                                      66040000
if i = 0 then i ~ 1;                                                    66050000
scatter ~ i;                                                            66060000
end scatter;                                                            66070000
%********scatter********************************************************66080000
%********searchst*******************************************************66090000
alpha procedure searchst(n,l,p,x);                                      66100000
value n, p, x;                                                          66110000
integer n, p;                                                           66120000
alpha array l[0];                                                       66130000
alpha x;                                                                66140000
begin alpha j, k;                                                       66150000
integer i, xtest;                                                       66160000
label found, fail;                                                      66170000
%                                                                       66180000
xtest ~ if x = "symb" then 0 else                                       66190000
        if x = "fct"  then 2 else                                       66200000
        if x = "inst" then 3 else 0;                                    66210000
i ~ scatter(n,l,p,x);                                                   66220000
while i ! 0 do                                                          66230000
   begin if (if n ! (k~name[i]).s                                       66240000
             then false                                                 66250000
             else equal(n,l,p,firstchar(k)))                            66260000
         then if (if n = 0 then k.loc ! 0 else true)                    66270000
              then if k.type = xtest                                    66280000
                   then go to found;                                    66290000
   i ~ k.link                                                           66300000
   end;                                                                 66310000
fail:                                                                   66320000
   i ~ -1;                                                              66330000
found:                                                                  66340000
   searchst ~ i;                                                        66350000
end searchst;                                                           66360000
%********searchst*******************************************************66370000
%********snbldefine*****************************************************66380000
% snbldefine sets up program-defined functions.  the three parameters   66390000
% should be the symbol table locations of the three parameters for      66400000
% the snobol define.                                                    66410000
% snbldefine uses char, scanchar, enterst, min, string, movechars.      66420000
boolean procedure snbldefine(st1,st2,st3);                              66430000
value st1, st2, st3;                                                    66440000
alpha st1, st2, st3;                                                    66450000
%                                                                       66460000
begin                                                                   66470000
define parammax = 30 #;  % max number of params & loc vars allowed.     66480000
integer i, p1, p2, lvno;                                                66490000
alpha prot, ent, lvars, stloc;                                          66500000
integer array lv[0:parammax];                                           66510000
label proterr, lverr, renvoi, toomany;                                  66520000
if st1 = 0 then                                                         66530000
   begin % no first param (prototype).                                  66540000
   message0(4);                                                         66550000
   messagett0(4);                                                       66560000
   go to renvoi;                                                        66570000
   end;                                                                 66580000
prot ~ valu[st1];                                                       66590000
ent  ~ if st2.stw = 0 then 0 else valu[st2];                            66600000
lvars~ if st3.stw = 0 then 0 else valu[st3];                            66610000
%                                                                       66620000
% find name:                                                            66630000
p1 ~ prot.ch + skipchar(" ",data[prot.r,prot.w],prot.c);                66640000
p2 ~ p1 + scanchar("(",qmark,data[prot.r,p1.w],p1.c);                   66650000
if p2 - p1 > prot.s then                                                66660000
   begin message0(3);                                                   66670000
   messagett0(3);                                                       66680000
   go to renvoi;                                                        66690000
   end;                                                                 66700000
stloc ~ enterst(p2-p1,data[prot.r,*],p1,"fct");                         66710000
lv[lvno~0] ~ enterst(p2-p1,data[prot.r,*],p1,"symb");                   66720000
if printmessages then % check whether already defined:                  66730000
   if valu[stloc].link ! 0 then                                         66740000
      if loadf then                                                     66750000
         begin message0(13); messagett0(13); end else                   66760000
            begin messagei(21,instno); messagetti(21,instno); end;      66770000
%                                                                       66780000
% find entry point:                                                     66790000
ent ~ if ent.s = 0                                                      66800000
   then enterst(p2-p1,data[prot.r,*],p1,"inst")                         66810000
   else enterst(ent.s,data[ent.r,*],ent.ch,"inst");                     66820000
%                                                                       66830000
% process formal parameters:                                            66840000
i ~ prot.ch + scanchar(")",qmark,data[prot.r,prot.w],prot.c);           66850000
if i < p2 - prot.ch then go to proterr;                                 66860000
p1 ~ p2 + 1;                                                            66870000
while p1 < i do                                                         66880000
   begin p1 ~ p1 + skipchar(" ",data[prot.r,p1.w],p1.c);                66890000
   p2 ~ p1 + min(                                                       66900000
      scanchar(",",")",data[prot.r,p1.w],p1.c),                         66910000
      scanchar(" ",qmark,data[prot.r,p1.w],p1.c));                      66920000
   if p2 > i then p2 ~ i;                                               66930000
   if p1 = p2 then go to proterr;                                       66940000
   if lvno ~ lvno+1 > parammax then go to toomany;                      66950000
   lv[lvno] ~ enterst(p2-p1,data[prot.r,*],p1,"symb");                  66960000
   p2 ~ p2 + skipchar(" ",data[prot.r,p2.w],p2.c);                      66970000
   if p2 < i and char(data[prot.r,p2.w],p2.c) ! "," then go to proterr; 66980000
   p1 ~ p2 + 1;                                                         66990000
   end;                                                                 67000000
%                                                                       67010000
% process local variables:                                              67020000
i ~ lvars.ch + lvars.s;                                                 67030000
p1 ~ lvars.ch;                                                          67040000
i ~ p1 + lvars.s;                                                       67050000
while p1 < i do                                                         67060000
   begin p1 ~ p1 + skipchar(" ",data[lvars.r,p1.w],p1.c);               67070000
   p2 ~ p1 + min(                                                       67080000
      scanchar(",",")",data[lvars.r,p1.w],p1.c),                        67090000
      scanchar(" ",qmark,data[lvars.r,p1.w],p1.c));                     67100000
   if p2 > i then p2 ~ i;                                               67110000
   if lvno~lvno+1 > parammax then go to toomany;                        67120000
   lv[lvno] ~ enterst(p2-p1,data[lvars.r,*],p1,"symb");                 67130000
   p2 ~ p2 + skipchar(" ",data[lvars.r,p2.w],p2.c);                     67140000
   if p2 < i and char(data[lvars.r,p2.w],p2.c) ! "," then go to lverr;  67150000
   p1 ~ p2 + 1;                                                         67160000
   end;                                                                 67170000
% finish symbol table entry:                                            67180000
i ~ string((lvno+1)|2,stloc);                                           67190000
valu[stloc] ~ i & 1[1:47:1] & ent clink;                                67200000
for p1 ~ 0 step 1 until lvno do                                         67210000
   move(2,lv[p1],6,data[i.r,(i+2|p1).w],(i+2|p1).c);                    67220000
if traceall then                                                        67230000
   begin valu[stloc].iouse ~ 3;                                         67240000
   io[stloc] ~ 0 & 3 cfilno & 3 ciouse & 2 ciotype;                     67250000
   end;                                                                 67260000
snbldefine ~ true;                                                      67270000
go to renvoi;                                                           67280000
toomany:                                                                67290000
   snbldefine ~ false;                                                  67300000
   messagei(22,parammax);                                               67310000
   messagetti(24,parammax);                                             67320000
   go to renvoi;                                                        67330000
proterr:                                                                67340000
   snbldefine ~ false;                                                  67350000
   messagett0(2);                                                       67360000
   message0(2); go to renvoi;                                           67370000
lverr:                                                                  67380000
   snbldefine ~ false;                                                  67390000
   message0(1);                                                         67400000
   messagett0(1);                                                       67410000
renvoi:                                                                 67420000
end snbldefine;                                                         67430000
%********snbldefine*****************************************************67440000
%********snblin*********************************************************67450000
boolean procedure snblin(st);                                           67460000
value st; alpha st;                                                     67470000
begin label return, fail, eof, par, nofile,                             67480000
   datacomm, inread, look, illegal;                                     67490000
alpha stn, stv, sio;                                                    67500000
integer size, type, t, unit;                                            67510000
switch readsw ~                                                         67520000
   inread,                                                              67530000
   look,                                                                67540000
   datacomm;                                                            67550000
%                                                                       67560000
stv ~ valu[st];                                                         67570000
sio ~ io[st];                                                           67580000
if not boolean(stv.inuse) then go to illegal;                           67590000
type ~ sio.iotype;                                                      67600000
unit ~ sio.filno;                                                       67610000
% if inform then if unit > 0 then informi(6,unit);                      67620000
go to readsw[type];                                                     67630000
go to illegal;                                                          67640000
%                                                                       67650000
datacomm:                                                               67660000
   begin % input from teletype:                                         67670000
   if not datacomf then                                                 67680000
      begin findusers;                                                  67690000
      if not datacomf then go to nofile;                                67700000
      end;                                                              67710000
   if not input then go to fail;                                        67720000
   valu[st].loc ~ t ~ if stv.s } dcsize                                 67730000
      then stv.loc & dcsize concs % use old string                      67740000
      else string(dcsize,st);     % need bigger string                  67750000
   move(dcsize,dcread[*],0,firstchar(t));                               67760000
   snblin ~ true;                                                       67770000
   break ~ false;                                                       67780000
   go to return;                                                        67790000
   end;                                                                 67800000
inread:                                                                 67810000
   begin comment input from io[unit];                                   67820000
   ioeof[unit] ~ false;                                                 67830000
   size ~ iosize[unit];                                                 67840000
   if lookf[unit] then                                                  67850000
      begin lookf[unit] ~ false;                                        67860000
      move(size,nextrecord[unit,*],0,buffer[*],0);                      67870000
      end else                                                          67880000
      % read next record:                                               67890000
      if record[unit] } 0 then                                          67900000
         begin                                                          67910000
         read(iofile[unit][record[unit]],1023,buffer[*])[eof:par];      67920000
         record[unit] ~ -1;                                             67930000
         end else                                                       67940000
         begin space(iofile[unit],iospace[unit])[eof:par];              67950000
         read(iofile[unit],1023,buffer[*])[eof:par];                    67960000
         end;                                                           67970000
   valu[st].loc ~ t ~                                                   67980000
      if stv.s < size                                                   67990000
         then string(size,st)                                           68000000
         else stv.loc & size concs;                                     68010000
   move(size,buffer[*],0,firstchar(t));                                 68020000
   snblin ~ true;                                                       68030000
   go to return;                                                        68040000
   end;                                                                 68050000
look:                                                                   68060000
   begin % non-reading input (look) from iofile[unit];                  68070000
   size ~ iosize[unit];                                                 68080000
   if not lookf[unit] then                                              68090000
      begin if record[unit] } 0 then                                    68100000
         read(iofile[unit][record[unit]],1023,nextrecord[unit,*])       68110000
            [eof:par] else                                              68120000
         begin space(iofile[unit],iospace[unit])[eof:par];              68130000
         read(iofile[unit],1023,nextrecord[unit,*])[eof:par];           68140000
         end;                                                           68150000
      ioeof[unit] ~ false;                                              68160000
      lookf[unit] ~ true;                                               68170000
      end;                                                              68180000
   valu[st].loc ~ t ~                                                   68190000
      if stv.s < size                                                   68200000
         then string(size,st)                                           68210000
         else stv.loc & size concs;                                     68220000
   move(size,nextrecord[unit,*],0,firstchar(t));                        68230000
   snblin ~ true;                                                       68240000
   go to return;                                                        68250000
   end;                                                                 68260000
par:                                                                    68270000
   begin define dummy=#;                                                68280000
   write(bufout[*],fparity);                                            68290000
   stn ~ name[st];                                                      68300000
   move(stringloc(stn),bufout[*],32);                                   68310000
   write(print,fbl);                                                    68320000
   write(print,17,bufout[*]);                                           68330000
   go to fail;                                                          68340000
   end;                                                                 68350000
illegal:                                                                68360000
   informa(5,st);                                                       68370000
   death  ~ systemerror ~ inform ~ true;                                68380000
   go to endterpret;                                                    68390000
nofile:                                                                 68400000
   if printmessages then                                                68410000
   begin define dummy=#;                                                68420000
   stn ~ name[st];                                                      68430000
   write(bufout[*],fclosedr);                                           68440000
   move(stn.s,firstchar(stn),bufout[*],36);                             68450000
   write(print,fbl);                                                    68460000
   write(print,17,bufout[*]);                                           68470000
   end;                                                                 68480000
   go to fail;                                                          68490000
eof:                                                                    68500000
   ioeof[unit] ~ true;                                                  68510000
fail:                                                                   68520000
   snblin ~ false;                                                      68530000
return:                                                                 68540000
end snblin;                                                             68550000
%********snblin*********************************************************68560000
%********snblout********************************************************68570000
boolean procedure snblout(st); value st; alpha st;                      68580000
begin                                                                   68590000
label return, fail, eof, par, nofile, syspot,                           68600000
   datacomm, iowrite, trace, illegal;                                   68610000
switch writesw ~                                                        68620000
      iowrite,                                                          68630000
      trace,                                                            68640000
      datacomm,                                                         68650000
      illegal,                                                          68660000
      syspot;                                                           68670000
alpha stn, stv, sio, aa, ab;                                            68680000
integer size, type, unit, is, ich, ir, t, i1, i2;                       68690000
%                                                                       68700000
stv ~ valu[st];                                                         68710000
sio ~ io[st];                                                           68720000
if not boolean(stv.outuse) then go to illegal;                          68730000
type ~ sio.iotype;                                                      68740000
unit ~ sio.filno;                                                       68750000
is ~ stv.s;                                                             68760000
ich ~ stv.ch;                                                           68770000
ir ~ stv.r;                                                             68780000
% if inform then if unit>0 then informi(13,unit);                       68790000
%                                                                       68800000
go to writesw[type];                                                    68810000
go to illegal;                                                          68820000
%                                                                       68830000
datacomm:                                                               68840000
   begin comment output to datacomm unit;                               68850000
   if not datacomf then                                                 68860000
      begin findusers;                                                  68870000
      if not datacomf then go to nofile;                                68880000
      end;                                                              68890000
   while is } 100 do                                                    68900000
      begin move(100,data[ir,ich.w],ich.c,dcwrite[*],0);                68910000
      mv(1,arrow,7,dcwrite[12],5);                                      68920000
      if not output then go to fail;                                    68930000
      is ~ is - 100;                                                    68940000
      ich ~ ich + 100;                                                  68950000
      end;                                                              68960000
   if is > 0 then                                                       68970000
      begin move(is,data[ir,ich.w],ich.c,dcwrite[*],0);                 68980000
      mv(1,arrow,7,dcwrite[is.w],is.c);                                 68990000
      if not output then go to fail;                                    69000000
      end;                                                              69010000
   snblout ~ true;                                                      69020000
   go to return;                                                        69030000
   end;                                                                 69040000
iowrite:                                                                69050000
   begin % output to file # unit.                                       69060000
   ioeof[unit] ~ false;                                                 69070000
   t ~ (iosize[unit]-1).w + 1;                                          69080000
   size ~ iosize[unit];                                                 69090000
   for i1~iospace[unit] step -1 until 1 do write(iofile[unit]);         69100000
   if is > size then if boolean(sio.ovfl) then                          69110000
      begin % write as many full records as possible:                   69120000
      movewds(1,blanks,bufout[*]);                                      69130000
      do begin                                                          69140000
         move(size,data[ir,ich.w],ich.c,bufout[*],0);                   69150000
         if record[unit] } 0                                            69160000
            then write(iofile[unit][record[unit]],t,bufout[*])[eof:par] 69170000
            else write(iofile[unit],t,bufout[*])[eof:par];              69180000
         record[unit] ~ -1;                                             69190000
         ich ~ ich + size;                                              69200000
         is ~ is - size;                                                69210000
         end until is { size;                                           69220000
      end else is ~ size;                                               69230000
   clear(bufout,t);                                                     69240000
   move(is,data[ir,ich.w],ich.c,bufout[*],0);                           69250000
   if record[unit] } 0                                                  69260000
      then write(iofile[unit][record[unit]],t,bufout[*])[eof:par]       69270000
      else write(iofile[unit],t,bufout[*])[eof:par];                    69280000
   record[unit] ~ -1;                                                   69290000
   snblout ~ true;                                                      69300000
   go to return;                                                        69310000
   end;                                                                 69320000
trace:                                                                  69330000
   begin define dummy=#;                                                69340000
   t ~ (iosize[unit]-1).w + 1;                                          69350000
   size ~ iosize[unit];                                                 69360000
   stn ~ name[st];                                                      69370000
   write(iofile[unit],fbl);                                             69380000
   i1 ~ min(stn.s,63);       % size of name                             69390000
   i2 ~ i1 + 3 - i1.[46:2];  % size of field for name.                  69400000
   write(bufout[*],ftrace,instno,i2);                                   69410000
   move(i1,firstchar(stn),bufout[*],8);                                 69420000
   if size - i2 - 12 > stv.s then                                       69430000
      begin move(stringloc(stv),bufout[*],i2+12);                       69440000
      mv(1,quote,7,bufout[(i1~stv.s+i2+12).w],i1.c);                    69450000
      write(iofile[unit][no],t,bufout[*]) [eof:par];                    69460000
      end else                                                          69470000
      begin                                                             69480000
      move(size-i2-12,firstchar(stv),bufout[*],12+i2);                  69490000
      write(iofile[unit][no],t,bufout[*]) [eof:par];                    69500000
      stv.s ~ stv.s - size + i2 + 12;                                   69510000
      stv.ch ~ stv.ch + size - i2 - 12;                                 69520000
      while stv.s } size do                                             69530000
         begin move(size,firstchar(stv),bufout[*],0);                   69540000
         write(iofile[unit],fbl);                                       69550000
         write(iofile[unit][no],t,bufout[*])[eof:par];                  69560000
         stv.s ~ stv.s - size;                                          69570000
         stv.ch ~ stv.ch + size;                                        69580000
         end;                                                           69590000
      clear(bufout,t);                                                  69600000
      move(stv.s,firstchar(stv),bufout[*],0);                           69610000
      mv(1,quote,7,bufout[(stv.s).w],(stv.s).c);                        69620000
      write(iofile[unit],fbl);                                          69630000
      write(iofile[unit][no],t,bufout[*]) [eof:par];                    69640000
      end;                                                              69650000
   snblout ~ true;                                                      69660000
   go to return;                                                        69670000
   end;                                                                 69680000
syspot:                                                                 69690000
   begin define dummy =#;                                               69700000
   if stv.s = 0 then go to return;                                      69710000
   aa ~ char(data[stv.r,stv.w],stv.c);                                  69720000
   if aa = "+" then iospace[3] ~ 0 else                                 69730000
   if aa = " " then iospace[3] ~ 1 else                                 69740000
   if aa = "0" then iospace[3] ~ 2 else                                 69750000
   if aa = "1" then                                                     69760000
      begin                                                             69770000
      write(print[page]);                                               69780000
      iospace[3] ~ 1;                                                   69790000
      end else                                                          69800000
   if aa = "*" then   % no skip at end of page                          69810000
      begin record[3] ~ 6;                                              69820000
      iospace[3] ~ 1;                                                   69830000
      end;                                                              69840000
   stn ~ tempcell;                                                      69850000
   ab ~ string(stv.s-1,stn);                                            69860000
   move(ab.s,firstchar(stv)+1,firstchar(ab));                           69870000
   aa ~ valu[printloc];                                                 69880000
   aa.loc ~ ab;                                                         69890000
   valu[stn] ~ aa;                                                      69900000
   io[stn] ~ io[printloc];                                              69910000
   if snblout(stn) then                                                 69920000
      begin                                                             69930000
      iospace[3] ~ 1;                                                   69940000
      snblout ~ true;                                                   69950000
      go to return;                                                     69960000
      end else                                                          69970000
      begin                                                             69980000
      iospace[3] ~ 1;                                                   69990000
      go to fail;                                                       70000000
      end;                                                              70010000
   end;                                                                 70020000
illegal:                                                                70030000
   informa(5,st);                                                       70040000
   death ~ systemerror ~ inform ~ true;                                 70050000
   go to endterpret;                                                    70060000
nofile:                                                                 70070000
   if printmessages then                                                70080000
   begin define dummy=#;                                                70090000
   stn ~ name[st];                                                      70100000
   write(bufout[*],fclosedw);                                           70110000
   move(stn.s,firstchar(stn),bufout[*],35);                             70120000
   write(print,fbl);                                                    70130000
   write(print,17,bufout[*]);                                           70140000
   end;                                                                 70150000
   go to fail;                                                          70160000
par:                                                                    70170000
   if printmessages then                                                70180000
   begin define dummy=#;                                                70190000
   stn ~ name[st];                                                      70200000
   write(bufout[*],fparity);                                            70210000
   move(stn.s,firstchar(stn),bufout[*],32);                             70220000
   write(print,fbl);                                                    70230000
   write(print,17,bufout[*]);                                           70240000
   end;                                                                 70250000
   go to fail;                                                          70260000
eof:                                                                    70270000
   ioeof[unit] ~ true;                                                  70280000
fail:                                                                   70290000
   snblout ~ false;                                                     70300000
return:                                                                 70310000
end snblout;                                                            70320000
%********snblout********************************************************70330000
%********storechars*****************************************************70340000
procedure storechars(n,loc,inc);                                        70350000
value n, inc; integer n, inc; alpha loc;                                70360000
begin define dummy =#;                                                  70370000
if ptr + n > 8180 then                                                  70380000
   begin                                                                70390000
   syntaxerr(42,0);                                                     70400000
   end else                                                             70410000
   begin                                                                70420000
   if n { 63                                                            70430000
      then mv(n,loc,inc,code[ptr.w],ptr.c)                              70440000
      else move(n,loc,inc,code[ptr.w],ptr.c);                           70450000
   ptr ~ ptr + n;                                                       70460000
   end;                                                                 70470000
end storechars;                                                         70480000
%********storechars*****************************************************70490000
%********string*********************************************************70500000
% string returns the location of an unused string of size n.            70510000
% if necessary, the garbage collector is called, or new rows are        70520000
% made available.                                                       70530000
alpha procedure string(n,stloc);                                        70540000
value n, stloc;                                                         70550000
integer n; alpha stloc;                                                 70560000
%                                                                       70570000
begin label l, e, fail;                                                 70580000
integer i;                                                              70590000
if dpntr[rw] + n } 8181 then                                            70600000
   begin integer j; j ~ 8181 - n;                                       70610000
   for i ~ 0 step 1 until datasize do                                   70620000
      if dpntr[i] < j and usedrow[i] then                               70630000
         begin rw ~ i; j ~ dpntr[i] end;                                70640000
   if dpntr[rw] + n } 8181 then                                         70650000
      begin garbagecollector;                                           70660000
      for i ~ 0 step 1 until datasize do                                70670000
         if dpntr[i] < j and usedrow[i] then                            70680000
            begin rw ~ i; j ~ dpntr[i] end;                             70690000
      if dpntr[rw] + n } 8181 then                                      70700000
         begin                                                          70710000
         if n } 8181 then go to fail else                               70720000
         for i ~ 0 step 1 until datasize do                             70730000
            if not usedrow[i] then                                      70740000
               begin usedrow[i] ~ true;                                 70750000
               rw ~ i; go to l;                                         70760000
               end;                                                     70770000
         end else go to l;                                              70780000
      go to fail;                                                       70790000
      end;                                                              70800000
   end;                                                                 70810000
l: stloc.[30:6] ~ qmark;                                                70820000
mv(3,stloc,5,data[rw,(i~dpntr[rw]).w],i.c);                             70830000
string ~ (i+3) & rw concr & n concs;                                    70840000
dpntr[rw] ~ i + n + 3;                                                  70850000
go to e;                                                                70860000
fail:                                                                   70870000
   messagei(12,n);                                                      70880000
   messagetti(12,n);                                                    70890000
   comment out of space in data[*,*];                                   70900000
   write(print,message[1]);                                             70910000
   death ~ true;                                                        70920000
e:                                                                      70930000
end string;                                                             70940000
%********string*********************************************************70950000
%********stringdump*****************************************************70960000
procedure stringdump(instno); value instno; integer instno;             70970000
begin                                                                   70980000
integer i, j, t, sn;                                                    70990000
alpha stn, stv;                                                         71000000
writetime(0,0);                                                         71010000
message0(6);                                                            71020000
if printmessages then messagett0(6);                                    71030000
for i ~ 0 step 1 while i { strmax and usedst[i] do                      71040000
   for j ~ 0 step 1 until stwmax do                                     71050000
      if (stn~namtabl[i,j]).[1:2] = 0 then if stn.loc > 1 then          71060000
            begin                                                       71070000
            sn ~ min(stn.s,63);                                         71080000
            t ~ max(sn+3-sn.[46:2],8);                                  71090000
            stv ~ valtabl[i,j];                                         71100000
            write(bufout[*],ftrace,instno,t);                           71110000
            move(sn,firstchar(stn),bufout[*],8);                        71120000
            if 120 - t > stv.s then                                     71130000
               begin move(stv.s,firstchar(stv),                         71140000
                  bufout[t.w],12+t.c);                                  71150000
               mv(1,quote,7,bufout[(i1~stv.s+t+12).w],i1.c);            71160000
               write(print,17,bufout[*]);                               71170000
               end else                                                 71180000
               begin                                                    71190000
               move(120-t,firstchar(stv),                               71200000
                  bufout[*],12+t);                                      71210000
               write(print,17,bufout[*]);                               71220000
               stv.s ~ stv.s - 120 + t;                                 71230000
               stv.ch ~ stv.ch + 120 - t;                               71240000
               while stv.s } 132 do                                     71250000
                  begin move(132,firstchar(stv),                        71260000
                     bufout[*],0);                                      71270000
                  write(print,17,bufout[*]);                            71280000
                  stv.s ~ stv.s-132;                                    71290000
                  stv.ch ~ stv.ch + 132;                                71300000
                  end;                                                  71310000
               clear(bufout,17);                                        71320000
               move(stv.s,firstchar(stv),bufout[*],0);                  71330000
               mv(1,quote,7,bufout[(stv.s).w],(stv.s).c);               71340000
               write(print,17,bufout[*]);                               71350000
               end;                                                     71360000
            end;                                                        71370000
message0(7);                                                            71380000
for i ~ 0 step 1 while i { strmax and usedst[i] do                      71390000
   for j ~ 0 step 1 until stwmax do                                     71400000
      if (stn ~ namtabl[i,j]).[1:2] = 3 then                            71410000
         begin sn ~ min(stn.s,63);                                      71420000
         t ~ max(sn+3-sn.[46:2],8);                                     71430000
         i1 ~ valtabl[i,j].link;                                        71440000
         write(bufout[*],ftracel,t,digits(i1),i1);                      71450000
         mv(sn,firstchar(stn),bufout[*],3);                             71460000
         write(print,17,bufout[*]);                                     71470000
         end;                                                           71480000
writetime(0,0);                                                         71490000
end stringdump;                                                         71500000
%********stringdump*****************************************************71510000
%********syntaxerr******************************************************71520000
procedure syntaxerr(n,p); value n,p; integer n,p;                       71530000
begin                                                                   71540000
define dummy = #;                                                       71550000
p ~ p mod fieldsize;                                                    71560000
if p > 0 then                                                           71570000
   begin                                                                71580000
   clear(bufout,17);                                                    71590000
   move(1,qmark,7,bufout[p.w],p.c+8);                                   71600000
   write(print,17,bufout[*]);                                           71610000
   end;                                                                 71620000
write(print,message[n]);                                                71630000
ptr ~ marker + 8;                                                       71640000
storechars(1,"x",7);                                                    71650000
messages ~ messages + 1;                                                71660000
errors ~ errors + 1;                                                    71670000
end syntaxerr;                                                          71680000
%********syntaxerr******************************************************71690000
%********tempcel********************************************************71700000
% tempcell produces a temporary cell in the symbol table.               71710000
% this cell can generally be assumed to be gone after the end of an     71720000
% instruction. (this is actually not always true, but it is rather      71730000
% difficult to predict when a cell will stay around longer.) see also   71740000
% the procedure newcell for getting permanent cells.                    71750000
alpha procedure tempcell;                                               71760000
begin integer st, i, j;                                                 71770000
label fail, return;                                                     71780000
define row=temprow#;                                                    71790000
%                                                                       71800000
% if inform then informi(7,row);                                        71810000
st ~ nextcell[row];                                                     71820000
if st = 0 then                                                          71830000
   begin                                                                71840000
   for row ~ 0 step 1 while st = 0 do                                   71850000
      if row > 15 then go to fail else                                  71860000
      if usedst[row]                                                    71870000
         then st ~ nextcell[row]                                        71880000
         else begin newstrow(row);                                      71890000
            st ~ 0 & row concstr;                                       71900000
            end;                                                        71910000
   row ~ row - 1;  % then "step" was executed one time too many.        71920000
   end;                                                                 71930000
nextcell[row] ~ name[st].link;                                          71940000
if (i~templist[row]) = 0 then                                           71950000
   begin templist[row] ~ st;                                            71960000
   name[st] ~ 0 & st clink;                                             71970000
   end else                                                             71980000
   begin j ~ name[i].link;                                              71990000
   name[i].link ~ st;                                                   72000000
   name[st] ~ 0 & j clink;                                              72010000
   end;                                                                 72020000
valu[st] ~ 0;                                                           72030000
tempcell ~ st;                                                          72040000
% if usedcell[row] < st then usedcell[row] ~ st;                        72050000
go to return;                                                           72060000
fail:                                                                   72070000
   message0(14);                                                        72080000
   messagett0(14);                                                      72090000
   write(print,message[1]);                                             72100000
   death ~ true;                                                        72110000
return:                                                                 72120000
% if inform then informia(0,row,st);                                    72130000
end tempcel;                                                            72140000
%********tempcel********************************************************72150000
%********tempval********************************************************72160000
% tempval produces a temporary symb table cell whose value is the       72170000
% string representation of the integer i.                               72180000
alpha procedure tempval(i);                                             72190000
value i; integer i;                                                     72200000
begin alpha array num[0:1];                                             72210000
alpha aa, ab; integer j;                                                72220000
%                                                                       72230000
write(num[*],fi16,i);                                                   72240000
j ~ 16 - skipchar(" ",num[0],0);                                        72250000
tempval ~ aa ~ tempcell;                                                72260000
ab ~ string(j,aa);                                                      72270000
mv(j,num[0],16-j,data[ab.r,ab.w],ab.c);                                 72280000
valtabl[aa.str,aa.stw] ~ ab;                                            72290000
end tempval;                                                            72300000
%********tempval********************************************************72310000
%********tracefctcall***************************************************72320000
boolean procedure tracefctcall(f);                                      72330000
   value f;                                                             72340000
   integer f;  % symbol table loc of function                           72350000
begin                                                                   72360000
label fail, fin;                                                        72370000
alpha fctn, fio, pv;                                                    72380000
integer i, j, size, p, ps, pc, pr;                                      72390000
define writerecord = if writebuff(bufout,p,size) then go to fail #;     72400000
%                                                                       72410000
fctn ~ name[f];                                                         72420000
fio ~ io[f];                                                            72430000
if fio.iotype = 2 then  % output to file.                               72440000
   begin                                                                72450000
   unit ~ fio.filno;                                                    72460000
   size ~ iosize[unit];                                                 72470000
   i ~ min(63,fctn.s);                                                  72480000
   write(bufout[*],ftracefctcall,instno,i);                             72490000
   mv(i,firstchar(fctn),bufout[*],8);                                   72500000
   p ~ i + 8;                                                           72510000
   if sp { mks then p ~ p + 1 else                                      72520000
   for i ~ mks step 1 while i { sp do                                   72530000
      begin  % move param into bufout[*];                               72540000
      if p~p+1 } size then writerecord;                                 72550000
      mv(1,quote,7,bufout[p.w],p.c);                                    72560000
      p ~ p + 1;                                                        72570000
      pv ~ valu[pst[i]];                                                72580000
      pr ~ pv.r;                                                        72590000
      ps ~ pv.s;                                                        72600000
      pc ~ pv.ch;                                                       72610000
      while ps+p } size do                                              72620000
         begin  % move in part of param, and write:                     72630000
         if p < size then                                               72640000
            begin                                                       72650000
            move(size-p,data[pr,pc.w],pc.c,bufout[p.w],p.c);            72660000
            ps ~ ps - size + p;                                         72670000
            pc ~ pc + size - p;                                         72680000
            end;                                                        72690000
         writerecord;                                                   72700000
         end;                                                           72710000
      move(ps,data[pr,pc.w],pc.c,bufout[p.w],p.c);                      72720000
      p ~ p + ps;                                                       72730000
      if p+1 } size then writerecord;                                   72740000
      mv(1,quote,7,bufout[p.w],p.c);                                    72750000
      if (p~p+1)+1 } size then writerecord;                             72760000
      mv(1,comma,7,bufout[p.w],p.c);                                    72770000
      end;                                                              72780000
   % change last "," to ")":                                            72790000
   aa ~ ")";                                                            72800000
   mv(1,aa,7,bufout[p.w],p.c);                                          72810000
   writerecord;                                                         72820000
   tracefctcall ~ true;                                                 72830000
   go to fin;                                                           72840000
   end file output else                                                 72850000
   % call tracing function:                                             72860000
   ; % net yet implemented.                                             72870000
fail:                                                                   72880000
   tracefctcall ~ false;                                                72890000
fin:                                                                    72900000
end tracefctcall;                                                       72910000
%********tracefctcall***************************************************72920000
%********tracefctreturn*************************************************72930000
boolean procedure tracefctreturn(f,suc);                                72940000
   value f, suc;                                                        72950000
   integer f;  % symbol table loc of function                           72960000
   boolean suc;     % true if succeeded.                                72970000
begin                                                                   72980000
label fail, fin, faut;                                                  72990000
integer i, p, sv, cv, rv, size;                                         73000000
alpha fctn, fio;                                                        73010000
define writerecord = if writebuff(bufout,p,size) then go to fail #;     73020000
%                                                                       73030000
fctn ~ name[f];                                                         73040000
fio ~ io[f];                                                            73050000
if fio.iotype = 2 then  % output to file                                73060000
   begin                                                                73070000
   unit ~ fio.filno;                                                    73080000
   size ~ iosize[unit];                                                 73090000
   i ~ min(63,fctn.s);                                                  73100000
   write(bufout[*],ftracefctret,instno,i);                              73110000
   mv(i,firstchar(fctn),bufout[*],8);                                   73120000
   p ~ i + 8;                                                           73130000
   write(iofile[unit],fbl) [fail:fail];                                 73140000
   if suc then                                                          73150000
      begin  % write out value:                                         73160000
      p ~ p + 6;                                                        73170000
      aa ~ valu[pst[mks]];  % = value;                                  73180000
      sv ~ aa.s;                                                        73190000
      cv ~ aa.ch;                                                       73200000
      rv ~ aa.r;                                                        73210000
      while sv+p } size do                                              73220000
         begin                                                          73230000
         move(size-p,data[rv,cv.w],cv.c,bufout[p.w],p.c);               73240000
         cv ~ cv + size - p;                                            73250000
         sv ~ sv - size + p;                                            73260000
         writerecord;                                                   73270000
         end;                                                           73280000
      if sv > 0 then                                                    73290000
         move(sv,data[rv,cv.w],cv.c,bufout[p.w],p.c);                   73300000
      if p~p+sv < size then  % room for quote                           73310000
         begin mv(1,quote,7,bufout[p.w],p.c);                           73320000
         write(iofile[unit][no],1023,bufout[*]) [fail:fail];            73330000
         end else                                                       73340000
         % put quote on next line:                                      73350000
         begin write(iofile[unit],1023,bufout[*])[fail:fail];           73360000
         mv(1,quote,7,bufout[*],0);                                     73370000
         mv(7,blanks,0,bufout[*],1);                                    73380000
         write(iofile[unit][no],1,bufout[*])[fail:fail];                73390000
         end;                                                           73400000
      end success case else                                             73410000
      % write "failed.":                                                73420000
      begin aa ~ "failed.";                                             73430000
      mv(7,aa,1,bufout[p.w],p.c+3);                                     73440000
      write(iofile[unit][no],1023,bufout[*])[fail:fail];                73450000
      end;                                                              73460000
   tracefctreturn ~ true;                                               73470000
   go to fin;                                                           73480000
   end file output else                                                 73490000
   % call tracing function:                                             73500000
   ;  % not yet implemented.                                            73510000
faut:                                                                   73520000
fail:                                                                   73530000
   tracefctreturn ~ false;                                              73540000
fin:                                                                    73550000
end tracefctreturn;                                                     73560000
%********tracefctreturn*************************************************73570000
%********ttindex********************************************************73580000
% st should be symbol table cell pointing to a teletype address in      73590000
% the standard form <t.u>/<b.a.>.  the value returned is the subscript  73600000
% to use with id[*] and stat[*] for this teletype.                      73610000
% if the teletype isnt attached, -1 is returned.                        73620000
integer procedure ttindex(st);                                          73630000
value st;                                                               73640000
alpha st;                                                               73650000
begin label fail, fin;                                                  73660000
integer ba, tu, i, j, k, n, ir, ic;                                     73670000
findusers;                                                              73680000
st ~ valu[st];                                                          73690000
ir ~ st.r; ic ~ st.ch;                                                  73700000
tu ~ ba ~ 0;                                                            73710000
n ~ st.s;                                                               73720000
i ~ scanchar("/",qmark,data[ir,ic.w],ic.c);                             73730000
if i } n or char(data[ir,ic.w],ic.c+i) ! "/" then go to fail;           73740000
for j ~ 0 step 1 while j < i do                                         73750000
   if k ~ char(data[ir,ic.w],ic.c+j) > 9                                73760000
      then go to fail                                                   73770000
      else tu ~ tu|10 + k;                                              73780000
if tu = 0 or tu > 15 then go to fail;                                   73790000
for j ~ i+1 step 1 while j < n do                                       73800000
   if k ~ char(data[ir,ic.w],ic.c+j) > 9                                73810000
      then go to fail                                                   73820000
      else ba ~ ba|10 + k;                                              73830000
if ba > 15 then go to fail;                                             73840000
ba ~ ba & tu[39:44:4];                                                  73850000
i ~ -1;                                                                 73860000
for j ~ 0 step 1 while j < numusers and i < 0 do                        73870000
   if ba = stat[j].[9:9] then i ~ j;                                    73880000
if i } 0 then                                                           73890000
   begin ttindex ~ i;                                                   73900000
   go to fin;                                                           73910000
   end;                                                                 73920000
fail:                                                                   73930000
   ttindex ~ -1;                                                        73940000
fin:                                                                    73950000
end ttindex;                                                            73960000
%********ttindex********************************************************73970000
%********writebuff******************************************************73980000
boolean procedure writebuff(bufout,p,size);                             73990000
   value size;                                                          74000000
   integer p, size;                                                     74010000
   array bufout[0];                                                     74020000
begin label fail, fin;                                                  74030000
write(iofile[unit],fbl);                                                74040000
write(iofile[unit][no],1023,bufout[*]) [fail:fail];                     74050000
p ~ 0;                                                                  74060000
clear(bufout,size.w);                                                   74070000
writebuff ~ false;                                                      74080000
go to fin;                                                              74090000
fail:                                                                   74100000
   writebuff ~ true;   % true if output fails                           74110000
fin:                                                                    74120000
end writebuff;                                                          74130000
%********writebuff******************************************************74140000
%********writedata******************************************************74150000
% dump of program/data areas:                                           74160000
procedure writedata;                                                    74170000
begin integer i;                                                        74180000
procedure writedatarow(i); value i; integer i;                          74190000
begin integer j; integer array buffer[0:14];                            74200000
j ~ 0;                                                                  74210000
write(buffer[*],message[37],i);                                         74220000
move(100,data[i,*],0,buffer[*],16);                                     74230000
move(4,blanks,0,buffer[14],4);                                          74240000
write(print,message[36]);                                               74250000
write(print,15,buffer[*]);                                              74260000
fill buffer[*] with "        ","        ";                              74270000
for j ~ j + 100 while j < 8084 do                                       74280000
   begin move(100,data[i,j.w],j.c,buffer[*],16);                        74290000
   write(print,15,buffer[*]);                                           74300000
   end;                                                                 74310000
move(84,data[i,1012],4,buffer[*],16);                                   74320000
for j ~ 100,108 do move(8,blanks,0,buffer[j.w],j.c);                    74330000
write(print,15,buffer[*]);                                              74340000
write(print,message[36]);                                               74350000
end writedatarow;                                                       74360000
writetime(0,0);                                                         74370000
write(print [page]);                                                    74380000
for i ~ 0 step 1 until 31 do                                            74390000
   begin write(print,message[35],i,usedrow[i],i,dpntr[i]);              74400000
   if usedrow[i] then writedatarow(i);                                  74410000
   end;                                                                 74420000
writetime(0,0);                                                         74430000
end writedata;                                                          74440000
%********writedata******************************************************74450000
%********writeinst******************************************************74460000
% writeinst prints out the code that has been produced so far           74470000
% by the compiler.                                                      74480000
procedure writeinst;                                                    74490000
begin define dummy=#;                                                   74500000
clear(bufout,17);                                                       74510000
move(min(ptr-marker,132),code[marker.w],marker.c,bufout[*],0);          74520000
write(print,17,bufout[*]);                                              74530000
end writeinst;                                                          74540000
%********writeinst******************************************************74550000
%********writest********************************************************74560000
% symbol table dump routine:                                            74570000
procedure writest;                                                      74580000
begin                                                                   74590000
format f(x5,a2,x1,i4," * ",2(4i1,x1,i2,x1,i3,x1,i4,x1,i2,x1,            74600000
      i4,"    "),a2,x12,i1,x4,i3,x3,i3,x4,l1,x4,i2),                    74610000
   f1(7("*"),x10,"namtabl[",i2,",*]",x16,"valtabl[",i2,",*]",x27,       74620000
      "iouse filno cycle ovfl iotype"),                                 74630000
   f2("nextcell[",i2,"] = ",a2,"; templist[",i2,"] = ",a2);             74640000
integer i, j, k;                                                        74650000
alpha l;                                                                74660000
write(print[1]);                                                        74670000
writetime(0,0);                                                         74680000
for i ~ 0 step 1 until strmax do if usedst[i] then                      74690000
   begin                                                                74700000
   write(print,f2,i,nextcell[i],i,templist[i]);                         74710000
   write(print,f1,i,i);                                                 74720000
   for k ~ 0 step 1 until stwmax do                                     74730000
      write(print,f,(k&i concstr),k,for l ~                             74740000
         namtabl[i,k],valtabl[i,k] do                                   74750000
            [l.[1:1],                                                   74760000
             l.[2:1],                                                   74770000
             l.[3:1],                                                   74780000
             l.[4:1],                                                   74790000
             l.[5:4],                                                   74800000
             l.[9:8],                                                   74810000
             l.s,                                                       74820000
             l.r,                                                       74830000
             l.ch],                                                     74840000
         (k&i concstr),                                                 74850000
         for l ~ iotabl[i,k] do                                         74860000
            [l.iouse,                                                   74870000
             l.filno,                                                   74880000
             l.cycle,                                                   74890000
             l.ovfl,                                                    74900000
             l.iotype]);                                                74910000
   end;                                                                 74920000
writetime(0,0);                                                         74930000
end writest;                                                            74940000
%********writest********************************************************74950000
%********writestack*****************************************************74960000
% writestack(n) prints out the contents of the stack, from word 0       74970000
% to word n.  n should be { stacksize.                                  74980000
procedure writestack(n);                                                74990000
value n;                                                                75000000
integer n;                                                              75010000
begin integer i;                                                        75020000
write(print,fstackhead);                                                75030000
for i ~ 0 step 1 until n do                                             75040000
   write(print,fstackentry,                                             75050000
      i,                                                                75060000
      ptype[i],                                                         75070000
      pst[i],                                                           75080000
      pname[i],                                                         75090000
      ploc[i].s, ploc[i].r, ploc[i].ch,                                 75100000
      psize[i],                                                         75110000
      ppoint[i],                                                        75120000
      pminleft[i],                                                      75130000
      pback[i]);                                                        75140000
end writestack;                                                         75150000
%********writestack*****************************************************75160000
%********writetime******************************************************75170000
% f is no longer in use here.                                           75180000
procedure writetime(f,n); value f,n; integer f,n;                       75190000
begin real t, ts;                                                       75200000
integer th, tm;                                                         75210000
t ~ time(1) / 60;                                                       75220000
th ~ entier(t / 3600);                                                  75230000
tm ~ entier((t - th | 3600) / 60);                                      75240000
ts ~ t - th | 3600 - tm | 60;                                           75250000
if n { 0 then                                                           75260000
   write(print,ftime[0],time(2)/60,time(3)/60) else                     75270000
if n { 1 then                                                           75280000
   begin alpha   d, m, y, x; alpha array mm[1:12];                      75290000
   x ~ date;                                                            75300000
   m ~ x.[1:5] | 10 + x.[6:6];                                          75310000
   d ~ x.[18:6] | 10 + x.[24:6];                                        75320000
   y ~ x.[36:12];                                                       75330000
   fill mm[*] with                                                      75340000
      "jan","feb","mar","apr","may","jun",                              75350000
      "jul","aug","sep","oct","nov","dec";                              75360000
   write(print,ftime[1],version,digits(d),d,mm[m],y,th,tm,ts);          75370000
   end else                                                             75380000
if n { 3 then                                                           75390000
   write(print,ftime[n],th,tm,ts) else                                  75400000
if n { 5 then                                                           75410000
   write(print,ftime[n],th,tm,ts,digits(level),level,                   75420000
      digits(instno),instno);                                           75430000
end  writetime;                                                         75440000
%********writetime******************************************************75450000
%***********************************************************************75460000
% end of procedure declarations                                         75470000
begin comment initialization;                                           75480000
alpha array users[0:31];                                                75490000
%                                                                       75500000
% b5500 character set:                                                  75510000
%    0    1    2    3     4    5    6    7    8    9                    75520000
%    #    @  qmark  :     >    }    +    A    B    C                    75530000
%    D    E    F    G     H    I    .    [    &    (                    75540000
%    <    ~    |    J     k    l    m    n    o    p                    75550000
%    q    r    %    *     -    )    ;    {  blank  /                    75560000
%    s    t    u    v     w    x    y    z    ,    %                    75570000
%    !    =    ]    "                                                   75580000
%                                                                       75590000
fill convertval[*] with                                                 75600000
    "0","1","2","3","4","5","6","7","8","9",                            75610000
    "=",""",""","{","%","[","<","A","B","C",                            75620000
    "D","E","F","G","H","I",".",")","+","}",                            75630000
    12, ";",12, "J","k","l","m","n","o","p",                            75640000
    "q","r","$","*","-",12, 12, ">"," ","/",                            75650000
    "s","t","u","v","w","x","y","z",",","(",                            75660000
    "]",12, 12, "&";                                                    75670000
%                                                                       75680000
%                                                                       75690000
fill chartype[*] with                                                   75700000
   3,  3,  3,  3,  3,  3,  3,  3,  3,  3,                               75710000
   0,  0,  13, 9,  0,  0,  10, 3,  3,  3,                               75720000
   3,  3,  3,  3,  3,  3,  3,  0,  0,  5,                               75730000
   0,  2,  10, 3,  3,  3,  3,  3,  3,  3,                               75740000
   3,  3,  8,  7,  10, 6,  14, 0,  1,  12,                              75750000
   3,  3,  3,  3,  3,  3,  3,  3,  11, 0,                               75760000
   0,  2,  0,  4;                                                       75770000
%                                                                       75780000
fill dottype[*] with                                                    75790000
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,                               75800000
   0,  0,  0,  0,  0,  0,  2,  0,  0,  0,                               75810000
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,                               75820000
   0,  0,  2,  0,  0,  0,  0,  1,  0,  0,                               75830000
   0,  0,  0,  2,  2,  0,  0,  0,  0,  2,                               75840000
   3,  0,  0,  0,  0,  0,  0,  0,  0,  0,                               75850000
   0,  0,  0,  0;                                                       75860000
% values for dottype:                                                   75870000
%  0  error                                                             75880000
%  1   .n                                                               75890000
%  2   .+,  .-,  .|,  ./,  .*                                           75900000
%  3   .s                                                               75910000
%                                                                       75920000
fill oplevel[*] with                                                    75930000
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                        75940000
   0, 0, 0, 0, 0, 0, 1, 0, 0, 0,                                        75950000
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                        75960000
   0, 0, 3, 0, 0, 0, 0, 0, 0, 0,                                        75970000
   0, 0, 0, 4, 2, 0, 0, 0, 0, 3,                                        75980000
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                        75990000
   0, 0, 0, 0;                                                          76000000
fill words[*] with                                                      76010000
   "unanchor","oundump ","integert","runcatio","ndisk in",              76020000
   "formsile","ncendfre","turndata","comiorul","esproces",              76030000
   "saverele","asepurge","teletype","debugrun","errdumpt",              76040000
   "runcated","verflowq","uoteqmar","karrowre","adprintp",              76050000
   "unchlook","syspotca","rdnewdis","k       ";                         76060000
fill mnemonic[0,*] with                                                 76070000
   6,                                                                   76080000
   "on","to","by","at","in","off";                                      76090000
fill mnemonic[1,*] with                                                 76100000
   2,                                                                   76110000
   "from","to";                                                         76120000
fill controlcard[*] with 0,                                             76130000
   "debug",                                                             76140000
   "pcc",                                                               76150000
   "list",                                                              76160000
   "unlist",                                                            76170000
   "punch",                                                             76180000
   "eject",                                                             76190000
   "space",                                                             76200000
   "width",                                                             76210000
   "26",                                                                76220000
   "3600",                                                              76230000
   "b5500",                                                             76240000
   "define",                                                            76250000
   "wait",                                                              76260000
   "limit",                                                             76270000
   "size",                                                              76280000
   "set",                                                               76290000
   "library",                                                           76300000
   "load",                                                              76310000
   "compile",                                                           76320000
   "inform",                                                            76330000
   "silence";                                                           76340000
fill intrinsfct[3,*] with                                               76350000
   8,".eq",".ne",".lt",".le",".gt",".ge","pop","eof";                   76360000
fill intrinsndx[3,*] with                                               76370000
   9, 21, 19, 16, 15, 14, 25, 8;                                        76380000
fill intrinsfct[4,*] with                                               76390000
   17,                                                                  76400000
   ".num","push","page","size","mode",                                  76410000
   "dump","date","trim","time",                                         76420000
   "file","look","wait","fill","user",                                  76430000
   "seek","copy";                                                       76440000
fill intrinsndx[4,*] with                                               76450000
   22, 26, 24, 30, 20, 7, 4, 36, 32,                                    76460000
   12, 18, 39, 13, 42, 43, 48;                                          76470000
fill intrinsfct[5,*] with                                               76480000
   10,                                                                  76490000
   "space","uneql","trace","close","rules",                             76500000
   "level","opsyn","callf",".ranf","clear";                             76510000
fill intrinsndx[5,*] with                                               76520000
   31, 38, 46, 3, 29, 17, 23, 2, 50, 51;                                76530000
fill intrinsfct[6,*] with                                               76540000
   14,                                                                  76550000
   ".remdr","anchor","unanch","equals","define",                        76560000
   "detach","tracef","rewind","tracel","status",                        76570000
   "traces","record","assign","search";                                 76580000
fill intrinsndx[6,*] with                                               76590000
   27, 1, 37, 10, 5, 6, 34, 28, 35, 41,                                 76600000
   33, 45, 47, 49;                                                      76610000
fill intrinsfct[7,*] with                                               76620000
   4,"execute","compile","suspend","release";                           76630000
fill intrinsndx[7,*] with                                               76640000
   11, 0, 40, 44;                                                       76650000
fill months[*] with 31,28,31,30,31,30,31,31,30,31,30,31;                76660000
if ((temp~time(0)).[24:6] + temp.[18:6] | 10) mod 4 = 0 then            76670000
   months[2] ~ 29;                                                      76680000
%                                                                       76690000
%                                                                       76700000
%                                                                       76710000
randno ~ 8388607;  % initialize random number generator                 76720000
crlf ~ "{!~";                                                           76730000
arrow ~ "~"; slash ~ "/";                                               76740000
eqsign ~ "=";                                                           76750000
qmark ~ 12; quote ~ """; blank ~ " "; colon ~ ":";                      76760000
star ~ "*"; comma ~ ",";                                                76770000
stopper ~ quote & qmark[36:42:6] & blank[30:42:6];                      76780000
blanks ~ "    "; move(4,blanks,4,blanks,0);                             76790000
teenyneg ~ real(not false);                                             76800000
anchormode ~ 2;                                                         76810000
traceall ~ boolean(common.[47:1]);                                      76820000
dumpall ~ boolean(common.[46:1]);                                       76830000
systemdebugging ~ boolean(common.[45:1]);                               76840000
usedrow[0] ~ true;                                                      76850000
execute ~ true;                                                         76860000
fieldsize ~ 72;                                                         76870000
waittime ~ 18000;  % 5 minutes                                          76880000
findusers;  % locate attached teletypes                                 76890000
if datacomf then                                                        76900000
   begin                                                                76910000
   if numusers = 1 then programfromremote ~ true;                       76920000
   for user ~ 0 step 1 until numusers-1 do                              76930000
      begin                                                             76940000
      write(dcwrite[*],ftthello,version);                               76950000
      if output then;                                                   76960000
      if not programfromremote then                                     76970000
         begin write(dcwrite[*],ffromremote,12);                        76980000
         if output then if input then                                   76990000
            begin                                                       77000000
            while j~char(dcread[*],skipchar(" ",dcread[*],0))!"y"       77010000
                  and j ! "n" do                                        77020000
               begin write(dcwrite[*],fyesorno);                        77030000
               if output then;                                          77040000
               if input then;                                           77050000
               end;                                                     77060000
            if j = "y" then                                             77070000
               begin programfromremote ~ true;                          77080000
               mainuser ~ user;                                         77090000
            end else                                                    77100000
            begin mv(3,crlf,5,dcwrite[*],0);                            77110000
            if output then;                                             77120000
            end;                                                        77130000
            end;                                                        77140000
         end;                                                           77150000
      end;                                                              77160000
   user ~ mainuser;                                                     77170000
   end;                                                                 77180000
if not programfromremote then                                           77190000
   begin read(program,10,buffer[*]);                                    77200000
   bufferfull ~ true;                                                   77210000
   end;                                                                 77220000
writetime(0,1);                                                         77230000
loadf ~ true;                                                           77240000
loader(program);                                                        77250000
loadf ~ false;                                                          77260000
if punchf then close(punch);                                            77270000
%                                                                       77280000
write(print,ferrs,digits(errors),errors);                               77290000
writetime(0,2);                                                         77300000
writetime(0,0);                                                         77310000
if inform then                                                          77320000
   begin writest;                                                       77330000
   writedata;                                                           77340000
   end;                                                                 77350000
%                                                                       77360000
%                                                                       77370000
if execute then                                                         77380000
   begin writetime(0,3);                                                77390000
   write(print,fasterisks);                                             77400000
   %                                                                    77410000
   interpreter;                                                         77420000
   %                                                                    77430000
   message0(22);                                                        77440000
   messagetti(14,instno);                                               77450000
   result ~ false;                                                      77460000
   write(print,fasterisks);                                             77470000
   writetime(0,5);                                                      77480000
   end;                                                                 77490000
go to endofrun;                                                         77500000
%                                                                       77510000
%                                                                       77520000
end initialization;                                                     77530000
%                                                                       77540000
abortion:    % fatal system error.                                      77550000
   messagett0(7);                                                       77560000
   result ~ false;                                                      77570000
   systemerror ~ true;                                                  77580000
%                                                                       77590000
endterpret:                                                             77600000
   write(print,fasterisks);                                             77610000
   writetime(0,if result then 4 else 5);                                77620000
   if result then messagetti(23,instno);                                77630000
endofrun:                                                               77640000
   begin define dummy=#;                                                77650000
   if not result then messagetti(10,instno);                            77660000
   if traceall then inform ~ true;                                      77670000
   writetime(0,0);                                                      77680000
   write(print,frules,rules[0]);                                        77690000
   if dumpall then dmpst ~ dmpdata ~ dmpstr ~ true;                     77700000
   if systemerror then                                                  77710000
      begin write(print[dbl],fbl);                                      77720000
      for i ~ 0,1,2,3 do write(print[no],fsendcopy);                    77730000
      inform ~ true;                                                    77740000
      write(print[dbl],fbl);                                            77750000
      end;                                                              77760000
   write(print,fgcs,digits(gcs),gcs,digits(gctimecp)+2,gctimecp,        77770000
      digits(gctimeio)+2,gctimeio);                                     77780000
   if inform or dmpst then writestack(stacksize);                       77790000
   if inform or dmpst then writest;                                     77800000
   if inform or dmpdata then writedata;                                 77810000
   if inform or dmpstr or (errdump and not result)                      77820000
      then stringdump(instno);                                          77830000
   end endofrun segment;                                                77840000
end algol procedures;                                                   77850000
end end end global stream procedures;                                   77860000
%***********************************************************************77870000
end program.                                                            77880000
end; end.       last card on 0crding tape                               99999999
?end
